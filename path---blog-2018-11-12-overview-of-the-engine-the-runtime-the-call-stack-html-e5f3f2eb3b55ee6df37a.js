webpackJsonp([0xb860df868973],{543:function(a,n){a.exports={data:{markdownRemark:{html:'<ul>\n<li>\n<p><a href="https://juejin.im/post/5c090bd9e51d45242973cad2">JavaScript 如何工作系列: 引擎、运行时、调用栈概述</a></p>\n</li>\n<li>\n<p><a href="https://juejin.im/post/5a102e656fb9a044fd1158c6">JavaScript 如何工作：在 V8 引擎里 5 个优化代码的技巧</a></p>\n</li>\n<li>\n<p><a href="https://juejin.im/post/5a2559ae6fb9a044fe4634ba">JavaScript 工作原理：内存管理 + 处理常见的4种内存泄漏</a></p>\n</li>\n<li>\n<p><a href="https://juejin.im/post/5a221d35f265da43356291cc">JavaScript 如何工作的: 事件循环和异步编程的崛起 + 5 个关于如何使用 async/await 编写更好的技巧</a></p>\n</li>\n<li>\n<p><a href="https://juejin.im/entry/5a731a955188257a6d634f3e">Event Loop</a></p>\n</li>\n<li>\n<p><a href="https://zhuanlan.zhihu.com/p/55511602?utm_source=wechat_session&#x26;utm_medium=social&#x26;utm_oi=880452006622420992">Event Loop in Node</a></p>\n</li>\n<li>\n<p><a href="https://github.com/xitu/gold-miner/blob/master/TODO/how-javascript-works-deep-dive-into-websockets-and-http-2-with-sse-how-to-pick-the-right-path.md">JavaScript 是如何工作的：深入剖析 WebSockets 和拥有 SSE 技术 的 HTTP/2，以及如何在二者中做出正确的选择</a></p>\n</li>\n<li>\n<p><a href="https://github.com/xitu/gold-miner/blob/master/TODO1/how-javascript-works-the-rendering-engine-and-tips-to-optimize-its-performance.md">JavaScript 是如何工作的：渲染引擎和性能优化技巧</a></p>\n</li>\n</ul>\n<p>JavaScript 越来越流行，在前端、后端、hybrid apps、嵌入式设备开发等方向上都有它活跃的身影。\n这篇文章是 How JavaScript Works 系列的开篇，该系列的文章旨在深入挖掘 JavaScript 及其实际的工作原理。我们认为了解 JavaScript 的构建块及其共同作用，可以帮助我们写出更优雅、更高效的代码和应用。\n正如 GitHut stats 所展示的一样，JavaScript 各方面的统计数据都是棒棒哒，顶多也就在个别统计项上落后了其他语言那么一丢丢。</p>\n<p>如果项目深度依赖 JavaScript，这意味着开发者需要对底层有极其深入的了解，并利用语言和生态提供的一切东西来构建出色的应用。</p>\n<p>然而，事实上，很多开发者虽然每天都在使用 JavaScript，却对其背后发生的事情一无所知。</p>\n<h3 id="概述"><a href="#%E6%A6%82%E8%BF%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>概述</h3>\n<p>几乎每个人都听说过 V8 引擎的概念，大多数人也都知道 JavaScript 是一门单线程语言或者知道它是基于回调队列的。</p>\n<p>在这篇文章中，我们将详细的介绍这些概念并且解释 JavaScript 实际的运行方式，通过对这些细节的了解，你可以写出更好、无阻塞的应用。</p>\n<p>如果你是一名 JavaScript 新手，这篇文章将帮助你理解为什么 JavaScript 和其它语言对比起来显得那么”奇怪”。</p>\n<p>如果你是一名老司机，希望能够为你带来一些对 JavaScript 运行时的新思考。</p>\n<h3 id="javascript-引擎"><a href="#javascript-%E5%BC%95%E6%93%8E" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 引擎</h3>\n<p>说起 JavaScript 引擎，不得不提的就是 Google 的 V8 引擎，Chrome 和 Nodejs 内部也是使用的 V8。这里有一个简单的视图：</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/V8-4d5a7011a294a4858925defb02b2579c-e663a.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 75.22211253701876%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABrklEQVQ4y5WSS0/CQBDH/Uwe/ARe/Goe8eTVeJILSqxNxVewkdDaIKU2aqKGVmwLEW0oLH3wd3fRimh5bDLZ2Z2Z38zuzApmrNFoNN6/ZPIua63Mg0XkBaOBChAVcdhObVngGcCYVxV396Adb+Byfx3hR+nHNg84mZXrScT1wN3FTm4N25urIF1xbKe2Sd9M4G+H8U78Kt6tLfh2DsOekdqmC/j3yd+GMAwxGBAQQqie/Kqg3+9zQUaT/lQYxzEuzs8gCgdURBwdCgiCHvpUJEmCIAgoFAool8uIoii7wu/Ltufi9ELGgwN0B28w7g2YtyZarRYUReE+SZJA0zQ0m830PBNYrijwPoCztoSSKeHx7hGvzivq9Xrq22g0FgO6joPrhg5Yz4BWg93pwKDBnufxZ7LdoT6VSgW2bS8AdF0oqjru8pDAsl9gGAYHybKMDk3A9KWAev0GJ1d0Bof0H9/aKVCliYIggO/7/A8ty5oPZIGieIQb3cbTk0UbUeVAliifz3MQa06xWOSNmgtko8AApqnTv9N5I9jcsZlkMHau1Wq8KWzEFhrsZdZ0zCfxunmcDBbmwQAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="V8"\n        title=""\n        src="/static/V8-4d5a7011a294a4858925defb02b2579c-acf85.png"\n        srcset="/static/V8-4d5a7011a294a4858925defb02b2579c-c1418.png 210w,\n/static/V8-4d5a7011a294a4858925defb02b2579c-5d5d8.png 420w,\n/static/V8-4d5a7011a294a4858925defb02b2579c-acf85.png 840w,\n/static/V8-4d5a7011a294a4858925defb02b2579c-e663a.png 1013w"\n        sizes="(max-width: 840px) 100vw, 840px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>就如JVM虚拟机一样，JS引擎中也有堆(Memory Heap)和栈(Call Stack)的概念。</p>\n<ul>\n<li>\n<p>栈-用来存储方法调用的地方，以及基础数据类型(如var a = 1)也是存储在栈里面的，会随着方法调用结束而自动销毁掉(入栈—>方法调用后—>出栈)。</p>\n</li>\n<li>\n<p>堆-JS引擎中给对象分配的内存空间是放在堆中的。如var foo = {name: ‘foo’} 那么这个foo所指向的对象是存储在堆中的。</p>\n</li>\n</ul>\n<p>此外，JS中存在闭包的概念，对于基本类型变量如果存在与闭包当中，那么也将存储在堆中。详细可见此处1,3</p>\n<p>关于闭包的情况，就涉及到Captured Variables。我们知道Local Variables是最简单的情形，是直接存储在栈中的。而Captured Variables是对于存在闭包情况和with,try catch情况的变量。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> x<span class="token punctuation">;</span> <span class="token comment">// local variables</span>\n  <span class="token keyword">var</span> y<span class="token punctuation">;</span> <span class="token comment">// captured variable, bar中引用了y</span>\n\n  <span class="token keyword">function</span> <span class="token function">bar</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// bar 中的context会capture变量y</span>\n    <span class="token function">use</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token keyword">return</span> bar<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>复制代码如上述情况，变量y存在与bar()的闭包中，因此y是captured variable，是存储在堆中的。</p>\n<h3 id="runtime"><a href="#runtime" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RunTime</h3>\n<p>JS在浏览器中可以调用浏览器提供的API，如window对象，DOM相关API等。这些接口并不是由V8引擎提供的，是存在与浏览器当中的。因此简单来说，对于这些相关的外部接口，可以在运行时供JS调用，以及JS的事件循环(Event Loop)和事件队列(Callback Queue)，把这些称为RunTime。有些地方也把JS所用到的core lib核心库也看作RunTime的一部分。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/RunTime-b8b9d51ed2ef32832a63c4430eb8a323-18f60.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 74.7534516765286%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACnElEQVQ4y5VTTW8SURSdf+KPcuEPcNFEV2o0ummbGjdqdOfGjXGh0USMGhMoFmgpXwPD90dLFRAsAsMwhWEoMAzHex8dShM16U1O3ps7M+eed+95Ei4R8/n8wt555MW25yInjcdjaJqGXq93Bp2edbE6OX4/mUxWiBxim4jGtFrLQtLu7i7C4TCSySQSioJEIoZMOgZFkWmvIJVKIRQKIRKJLChsW2hSNRuFgz6U1DHyJQ2VnxY0fQZJluULx7L116goNzDpuS4cT6Fiq/Hi1QmurbVw84GGtXsqrl7/jXefDEixWAyjkXlW2UYleQvPN67gMPFwUWA2g2EYQikfPZPJQe008MV7itsbHaw/6WLrmYb7j7r4FjQhRaNRTKfTZeWx7kf/+CWmg+h5jvrMCi3LwnA4oswM7z8buLOpYv2xhs2nGu5uqfD4iZA/7HQ6qFR+4Oj7EfQTU5CY5hSFQgGlUkkMhhWuRlQ5xRvXAK6vBj4Q3n4cIFscQ+KGB/f3ISdSKKTzkKkF/b4OWY4hm80il8uBBxePx52OCov8KySv14NgKIq6AcRNBeFkCPVaXShzgosyzr24ILUswuwcnJO829uIp9NAqw3tMIHUQQG/Go3lEBh+v39pm7+ZfDVHCr2IUx/nBhnUnCBfLKJBhOxLVVXR7Xbh8/mEV9kJDjhm5AAeFMPJSR7PNpJk4giJPCXDF4s51Go1QajrusDOzg72qc+stt1uL28Nv+OBcuHhcLgg3NvbAyOfKxLy4mj8MhgMgi3FPnW73aJAvV4nH2bItyNUq1XR53K5LMCOaDabC0L+OczTppUJuH9MzNPlXCAQAN+owWAgFHKv2Eq8Z3WMVqtF7uhDYvl8E1gVg/f8I6+maQrwftX8/4s/8K9LoLGupMYAAAAASUVORK5CYII=\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="V8"\n        title=""\n        src="/static/RunTime-b8b9d51ed2ef32832a63c4430eb8a323-acf85.png"\n        srcset="/static/RunTime-b8b9d51ed2ef32832a63c4430eb8a323-c1418.png 210w,\n/static/RunTime-b8b9d51ed2ef32832a63c4430eb8a323-5d5d8.png 420w,\n/static/RunTime-b8b9d51ed2ef32832a63c4430eb8a323-acf85.png 840w,\n/static/RunTime-b8b9d51ed2ef32832a63c4430eb8a323-18f60.png 1014w"\n        sizes="(max-width: 840px) 100vw, 840px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>同样，在Node.js中，可以把Node的各种库提供的API称为RunTime。所以可以这么理解，Chrome和Node.js都采用相同的V8引擎，但拥有不同的运行环境(RunTime Environments)</p>\n<h3 id="call-stack"><a href="#call-stack" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Call Stack</h3>\n<p>JS被设计为单线程运行的，这是因为JS主要用来实现很多交互相关的操作，如DOM相关操作，如果是多线程会造成复杂的同步问题(例如当两个线程同时操作同一个DOM元素的时候该如何处理)。因此JS自诞生以来就是单线程的，而且主线程都是用来进行界面相关的渲染操作 (为什么说是主线程，因为HTML5 提供了Web Worker，独立的一个后台JS，用来处理一些耗时数据操作。因为不会修改相关DOM及页面元素，因此不影响页面性能)，如果有阻塞产生会导致浏览器卡死。</p>\n<p>如果一个递归调用没有终止条件，是一个死循环的话，会导致调用栈内存不够而溢出，如：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>例子中foo函数循环调用其本身，且没有终止条件，浏览器控制台输出调用栈达到最大调用次数。</p>\n<p>JS线程如果遇到比较耗时操作，如读取文件，AJAX请求操作怎么办？这里JS用到了Callback回调函数来处理。\n对于Call Stack中的每个方法调用，都会形成它自己的一个执行上下文Execution Context，关于执行上下文的详细阐述请看<a href="https://juejin.im/post/5a5ee28f6fb9a01cbe655860">这篇文章</a></p>',frontmatter:{title:"How JavaScript Work: 引擎、运行时、调用栈概述",img:"./img/2015-03-25.jpg",author:["Sylvenas"],excerpt:null,catalogue:["概述","浏览器缓存过程分析","强制缓存","协商缓存","总结"]},fields:{date:"November 11, 2018",path:"blog/javascript/2018-11-12-overview-of-the-engine-the-runtime-the-call-stack.md",slug:"/blog/2018/11/12/overview-of-the-engine-the-runtime-the-call-stack.html"}},allMarkdownRemark:{edges:[{node:{frontmatter:{title:"被讨厌的勇气"},fields:{slug:"/blog/2020/05/14/被讨厌的勇气.html"}}},{node:{frontmatter:{title:"自然变换 - Natural Transformation"},fields:{slug:"/blog/2020/05/02/自然变换.html"}}},{node:{frontmatter:{title:"遍历与队列 - Traversable"},fields:{slug:"/blog/2020/04/25/遍历与队列.html"}}},{node:{frontmatter:{title:"加法是自然之道 - Monoid"},fields:{slug:"/blog/2020/03/02/加法是自然之道.html"}}},{node:{frontmatter:{title:"俄罗斯套娃娃 - Monad"},fields:{slug:"/blog/2020/02/12/俄罗斯套娃娃.html"}}},{node:{frontmatter:{title:"纪念刘和珍君"},fields:{slug:"/blog/2020/02/07/记念刘和珍君.html"}}},{node:{frontmatter:{title:"应用函子 - Applicative"},fields:{slug:"/blog/2020/02/05/应用函子.html"}}},{node:{frontmatter:{title:"动物庄园"},fields:{slug:"/blog/2020/02/01/动物庄园.html"}}},{node:{frontmatter:{title:"薛定谔的 Maybe - IO"},fields:{slug:"/blog/2020/01/30/薛定谔的Maybe.html"}}},{node:{frontmatter:{title:"Abort-Controller"},fields:{slug:"/blog/2020/01/18/abort-controller.html"}}}]}},pathContext:{slug:"/blog/2018/11/12/overview-of-the-engine-the-runtime-the-call-stack.html"}}}});