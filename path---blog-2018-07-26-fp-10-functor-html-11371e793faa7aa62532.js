webpackJsonp([28273515500037],{528:function(n,s){n.exports={data:{markdownRemark:{html:'<h3 id="the-mighty-box"><a href="#the-mighty-box" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>The Mighty Box</h3>\n<p><img src="../images/functor-box.jpg" alt="functor->box"></p>\n<p>我们已经知道如何书写函数式的程序了，即通过管道把数据在一系列纯函数间传递的程序。我们也知道了，这些程序就是声明式的行为规范。但是，控制流（control flow）、异常处理（error handling）、异步操作（asynchronous actions）和状态（state）呢？还有更棘手的作用（effects）呢？本章将对上述这些抽象概念赖以建立的基础作一番探究。</p>\n<p>首先我们将创建一个容器（Box）。这个容器必须能够装载任意类型的值；否则的话，像只能装木薯布丁的密封塑料袋是没什么用的。这个容器将会是一个对象，但我们不会为它添加面向对象观念下的属性和方法。是的，我们将把它当作一个百宝箱——一个存放宝贵的数据的特殊盒子。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Box</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Box(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\nBox<span class="token punctuation">.</span><span class="token keyword">of</span> <span class="token operator">=</span> Box<span class="token punctuation">;</span></code></pre>\n      </div>\n<p>这是讲解函数式编程的第一个容器，我们贴心地把它命名为<code class="gatsby-code-text">Box</code>。我们完全使用函数式返回对象的方式，而不是ES6<code class="gatsby-code-text">Class</code>的方式，是因为这样就不用到处去写糟糕的<code class="gatsby-code-text">new</code>关键字了，非常省心。同时我们统一使用<code class="gatsby-code-text">Box.of</code>的方法来统一作为Box的入口，尽管现在看起来完全多此一举，是为了统一接口(实际上不能这么简单地看待<code class="gatsby-code-text">of</code>函数，但暂时先认为它是把值放到容器里的一种方式),并且我们通过重写<code class="gatsby-code-text">inspect</code>方法让我们方便的检查容器内的值。</p>\n<p>我们来检验下这个崭新的盒子：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Box<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n<span class="token comment">//=> Box(3)</span>\n\nBox<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"hotdogs"</span><span class="token punctuation">)</span>\n<span class="token comment">//=> Box("hotdogs")</span>\n\nBox<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>Box<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">"yoda"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment">//=> Box(Box({name: "yoda" }))</span></code></pre>\n      </div>\n<p>在继续后面的内容之前，先澄清几点：</p>\n<p><code class="gatsby-code-text">Box</code>是个只有一个属性的对象。尽管容器可以有不止一个的属性，但大多数容器还是只有一个。我们很随意地把 <code class="gatsby-code-text">Box</code>的这个属性命名为<code class="gatsby-code-text">$value</code>。</p>\n<ul>\n<li><code class="gatsby-code-text">$value</code> 不能是某个特定的类型，不然<code class="gatsby-code-text">Box</code>就对不起它这个名字了。</li>\n<li>数据一旦存放到<code class="gatsby-code-text">Box</code>，就会一直待在那儿,不能通过别的方式修改这个值</li>\n<li>如果把容器想象成玻璃罐的话，上面这三条陈述的理由就会比较清晰了。但是暂时，请先保持耐心。</li>\n</ul>\n<h3 id="my-first-functor"><a href="#my-first-functor" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>My First Functor</h3>\n<p>现在我们已经可以把一个数据用一个<code class="gatsby-code-text">Box</code>包装起来了,现在我们需要一种方法来让别的函数操作他</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Box</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n    map<span class="token punctuation">:</span> <span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Box</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Box(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p>这个<code class="gatsby-code-text">map</code>跟数组那个著名的<code class="gatsby-code-text">map</code>一样，除了前者操作的是<code class="gatsby-code-text">Box(a)</code>而后者是<code class="gatsby-code-text">[a]</code>。它们的使用方式也几乎一致：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Box<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>two <span class="token operator">=></span> two <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token comment">// Box(4)</span>\n\nBox<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">\'flamethrowers\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">=></span> s<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token comment">// Box(\'FLAMETHROWERS\')</span>\n\nBox<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">\'bombs\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">\' away\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">prop</span><span class="token punctuation">(</span><span class="token string">\'length\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> \n<span class="token comment">// Box(10)</span></code></pre>\n      </div>\n<p>为什么要使用这样一种方法？因为我们能够在不离开Box的情况下操作容器里面的值。这是非常了不起的一件事情。Box里的值传递给<code class="gatsby-code-text">map</code>函数之后，就可以任我们操作；操作结束后，为了防止意外再把它放回它所属的<code class="gatsby-code-text">Box</code>。这样做的结果是，我们能连续地调用 <code class="gatsby-code-text">map</code>，运行任何我们想运行的函数。甚至还可以改变值的类型，就像上面最后一个例子中那样。</p>\n<p>等等，如果我们能一直调用<code class="gatsby-code-text">map</code>，那它不就是个组合（composition）么！这里边是有什么数学魔法在起作用？是<code class="gatsby-code-text">functor</code>。各位，这个数学魔法就是<code class="gatsby-code-text">functor</code>。</p>\n<blockquote>\n<p>functor是实现了<code class="gatsby-code-text">map</code>函数并遵守一些特定规则的容器类型。</p>\n</blockquote>\n<p>没错，<code class="gatsby-code-text">functor</code>就是一个签了合约的接口。我们本来可以简单地把它称为<code class="gatsby-code-text">Mappable</code>，但这样就没有<code class="gatsby-code-text">fun</code>（注：指 functor 中包含 fun 这个单词，是一双关语）了，对吧？<code class="gatsby-code-text">functor</code>是范畴学里的概念，我们将在本章末尾详细探索与此相关的数学知识；暂时我们先用这个名字很奇怪的接口做一些不那么理论的、实用性的练习。</p>\n<p>把值装进一个容器，而且只能使用<code class="gatsby-code-text">map</code>来处理它，这么做的理由到底是什么呢？如果我们换种方式来问，答案就很明显了：让容器自己去运用函数能给我们带来什么好处？</p>\n<p>答案是抽象，对于函数运用的抽象。</p>\n<p>当<code class="gatsby-code-text">map</code>一个函数的时候，我们请求容器来运行这个函数。不夸张地讲，这是一种十分强大的理念。</p>\n<p><code class="gatsby-code-text">map</code>知道如何在上下文中应该函数值。它首先会打开该容器，然后把值通过函数映射为另外一个值，最后把结果值再次包裹到一个新的同类型的容器中。拥有这种函数的类型被称为<strong>Functor</strong>。</p>\n<blockquote>\n<p>从本质上来说，<code class="gatsby-code-text">Functor</code>只是一个可以将函数应用到包裹的值上，并将结果再包裹起来的数据结构。</p>\n</blockquote>\n<p>map的一般定义为：\n<code class="gatsby-code-text">map :: (a -&gt; b) -&gt; Box(a) -&gt; Box(b)</code>\n(先接收一个<code class="gatsby-code-text">a-&gt;b</code>的函数，然后再接收一个<code class="gatsby-code-text">Box(a)</code>)作为参数，最后返回一个<code class="gatsby-code-text">Box(b)</code></p>\n<p>毫无疑问这种链式的连续调用太眼熟了。其实绝大多数的开发人员一直在使用<code class="gatsby-code-text">Functor</code>却没有意识到而已。比如：<code class="gatsby-code-text">Array</code>的<code class="gatsby-code-text">map</code>和<code class="gatsby-code-text">filter</code>方法都是返回同样类型的<code class="gatsby-code-text">Functor</code>,因此可以不断的连续调用。</p>\n<p>再看看另一个<strong>Functor</strong>：<code class="gatsby-code-text">compose</code>,这是一个从多个函数到一个函数的映射(也保持了类型的不变)。\n<code class="gatsby-code-text">const compose = (...fns) =&gt; x =&gt; fns.reduceRight((y, f) =&gt; f(y), x);</code></p>\n<p><strong>Functor</strong>具有如下一些重要的约束：</p>\n<ul>\n<li>\n<p>必须是无副作用的。如果一个Functor<code class="gatsby-code-text">map(x =&gt; x)</code>之后得到的结果和映射之前完全相同的值，则可以认为该Functor是无副作用的。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">map</span> <span class="token operator">=</span> f <span class="token operator">=></span> mappable <span class="token operator">=></span> mappable<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>\n<span class="token keyword">const</span> <span class="token function-variable function">id</span> <span class="token operator">=</span> x <span class="token operator">=></span> x</code></pre>\n      </div>\n</li>\n</ul>\n<p>// identity\nmap(id) === id;</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-text"><code class="gatsby-code-text">``` js\nconst idLaw1 = map(id);\nconst idLaw2 = id;\n\nidLaw1(Box.of(2))   // Box(2)\nidLaw2(Box.of(2))         // Box(2)</code></pre>\n      </div>\n<ul>\n<li>必须是可组合的。这个组合的意思时说<code class="gatsby-code-text">map</code>函数的组合，与分别<code class="gatsby-code-text">map</code>函数是一样的。比如下面两个表达式的效果是一样的。</li>\n</ul>\n<p><code class="gatsby-code-text">compose(map(f), map(g)) === map(compose(f, g))</code></p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> two <span class="token operator">=</span> Box<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> plus <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span>\n<span class="token keyword">const</span> plus3 <span class="token operator">=</span> <span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> plus5 <span class="token operator">=</span> <span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 分别map</span>\ntwo<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>plus3<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>plus5<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x<span class="token punctuation">)</span>         <span class="token comment">// Box(10)</span>\n<span class="token comment">// 组合函数，然后map</span>\ntwo<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">compose</span><span class="token punctuation">(</span>plus3<span class="token punctuation">,</span> plus5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x<span class="token punctuation">)</span>    <span class="token comment">// Box(10)</span>\n\n<span class="token keyword">const</span> <span class="token function-variable function">compose</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>fns<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> fns<span class="token punctuation">.</span><span class="token function">reduceRight</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>\n<span class="token keyword">const</span> <span class="token function-variable function">map</span> <span class="token operator">=</span> f <span class="token operator">=></span> mappable <span class="token operator">=></span> mappable<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>\n<span class="token keyword">const</span> <span class="token function-variable function">concat</span> <span class="token operator">=</span> concatableX <span class="token operator">=></span> concatableY <span class="token operator">=></span> concatableY<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>concatableX<span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> compLaw1 <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">" world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">" cruel"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> compLaw2 <span class="token operator">=</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">" world"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">" cruel"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">compLaw1</span><span class="token punctuation">(</span>Box<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">\'Good Bye\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">//=> Box(Good Bye cruel world)</span>\n<span class="token function">compLaw2</span><span class="token punctuation">(</span>Box<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">\'Good Bye\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">//=> Box(Good Bye cruel world)</span></code></pre>\n      </div>\n<p><strong>Functor</strong>的这些属性并不奇怪。遵守这些规则，可以免于抛出异常、篡改元素或者改变函数的行为。其实实际目的<strong>只是创建一个上下文或者抽象</strong>，以便可以安全的应用操作到值，而不是改变原来的值。这也是map可以将一个数组转换为另一个数组，而不是改变原数组的原因。而<strong>Functor</strong>就是这个概念的推广。</p>\n<p>在范畴学中，Functor接受一个范畴的对象和态射（morphism），然后把它们映射（map）到另一个范畴里去。根据定义，这个新范畴一定会有一个单位元（identity），也一定能够组合态射；我们无须验证这一点，前面提到的定律保证这些东西会在映射后得到保留。</p>\n<p>可能我们关于范畴的定义还是有点模糊。你可以把范畴想象成一个有着多个对象的网络，对象之间靠态射连接。那么 Functor 可以把一个范畴映射到另外一个，而且不会破坏原有的网络。如果一个对象<code class="gatsby-code-text">a</code>属于源范畴<code class="gatsby-code-text">C</code>，那么通过 Functor<code class="gatsby-code-text">F</code>把<code class="gatsby-code-text">a</code>映射到目标范畴<code class="gatsby-code-text">D</code>上之后，就可以使用 <code class="gatsby-code-text">F a</code> 来指代 <code class="gatsby-code-text">a</code> 对象（把这些字母拼起来是什么？！）。可能看图会更容易理解：</p>\n<p><img src="../images/catmap.png" alt="catmap"></p>\n<p>用<code class="gatsby-code-text">map</code>包裹每一个函数，用<code class="gatsby-code-text">Functor</code>包裹每一个类型。这样就能保证每个普通的类型和函数都能在新环境下继续使用组合。从技术上讲，代码中的 Functor 实际上是把范畴映射到了一个包含类型和函数的子范畴（sub category）上，使得这些 Functor 成为了一种新的特殊的 endofunctor。但出于本书的目的，我们认为它就是一个不同的范畴。</p>\n<p>可以用一张图来表示这种态射及其对象的映射：</p>\n<p><img src="../images/functormap.png" alt="functormap"></p>\n<p>这张图除了能表示态射借助Functor<code class="gatsby-code-text">F</code>完成从一个范畴到另一个范畴的映射之外，我们发现它还符合交换律，也就是说，顺着箭头的方向往前，形成的每一个路径都指向同一个结果。不同的路径意味着不同的行为，但最终都会得到同一个数据类型。这种形式化给了我们原则性的方式去思考代码——无须分析和评估每一个单独的场景，只管可以大胆地应用公式即可。来看一个具体的例子。</p>\n<p>也就是说对于一个值，无论是先通过<code class="gatsby-code-text">Functor.of</code>把它转换为一个<code class="gatsby-code-text">Functor</code>,然后再通过map映射为另一个Functor，和先通过map映射为另一个值，然后在用<code class="gatsby-code-text">Functor.of</code>转换为Functor的结果是一摸一样的。</p>\n<p>有人认为函数式编程只适用于枯燥无味的学术研究，而忽略了真实世界的问题，然而近年来发现，函数式编程可以把错误处理得比任何其他开发风格更为优雅。</p>\n<p>软件开发中的许多问题都是由于数据不经意间的变成了<code class="gatsby-code-text">null</code>和<code class="gatsby-code-text">undefined</code>,出现了异常，失去了网络连接等情况造成的，我们的代码需要不断的校验这类问题，增加了代码的复杂性，这就需要花大量的时间来确保所有的异常都能正确的被捕获，并且在所有可能会出现<code class="gatsby-code-text">null</code>或者<code class="gatsby-code-text">undefined</code>的地方做检查，最后的结果是什么呢？—越来越长、不能扩展、推理起来又十分费劲的庞大而复杂的代码？</p>\n<p>在许多情况下都会发生JavaScript的错误，特别是在与服务器通信的时候，或者在试图访问一个为<code class="gatsby-code-text">null/undefined</code>的对象的属性的时候，这个时候就需要开发者做好最坏的打算，在命令式的程序中，大多数的异常都是通过<code class="gatsby-code-text">try-catch</code>来实现的</p>\n<h3 id="try-catch处理错误"><a href="#try-catch%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>try-catch处理错误</h3>\n<p>try通常包裹住你认为不太安全的代码，一旦有异常发生，JavaScript会立即终止程序，并创建导致该问题的指令的函数跳用堆栈跟踪。有关错误的细节，如消息、行号、文件名，被填充到Error类型对象中，并传递到catch块，catch块就像程序的避风港，</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">decode</span> <span class="token operator">=</span> url <span class="token operator">=></span> <span class="token punctuation">{</span> \n    <span class="token keyword">try</span> <span class="token punctuation">{</span>\n        <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">decodeURIComponent</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span>\n        <span class="token keyword">return</span> result\n    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">uriError</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> \n        <span class="token keyword">throw</span> uriError\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<h3 id="空值检查问题"><a href="#%E7%A9%BA%E5%80%BC%E6%A3%80%E6%9F%A5%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>空值检查问题</h3>\n<p>另外一个和抛出异常一样烦人的错误是null返回值，虽然null返回值确保了函数的出口只有一个，但是也没有好到哪里去—给使用函数的用户带来需要null检查的负担。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">if</span> <span class="token punctuation">(</span>student <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> school <span class="token operator">=</span> student<span class="token punctuation">.</span>school<span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>school <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">const</span> schoolName <span class="token operator">=</span> school<span class="token punctuation">.</span>name<span class="token punctuation">;</span>\n        <span class="token function">appendSchoolName</span><span class="token punctuation">(</span>schoolName<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<h3 id="函数式程序中的异常"><a href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%A8%8B%E5%BA%8F%E4%B8%AD%E7%9A%84%E5%BC%82%E5%B8%B8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>函数式程序中的异常</h3>\n<p>命令式的JavaScript代码结构有很多缺陷，而且也会与函数式的设计有兼容性问题。会抛出异常的函数存在一下问题：</p>\n<ul>\n<li>难以与其他函数组合或链接</li>\n<li>违反了引用透明原则，因为抛出异常会导致函数调用出现另一个出口，所以不能确保单一的可预测的返回值</li>\n<li>会引起副作用，因为异常会在函数调用之外对堆栈引发不可预料的影响</li>\n<li>违反局域性的原则，因为用于恢复异常的代码和原始的函数调用渐行渐远，当发生错误的时候，函数会离开局部栈和环境</li>\n<li>不能只关心函数的返回值，调用者需要负责声明catch块中的异常匹配类型来管理特定的异常</li>\n<li>当有多个异常条件的时候会出现潜逃的异常处理块</li>\n</ul>\n<blockquote>\n<p>异常应该由一个地方抛出，而不是随处可见</p>\n</blockquote>\n<p>上面的描述和代码可以看出，不管是使用try-catch还是null检查，都是被动的解决方式，若是机能轻松的处理错误，又不需要这些啰嗦的检查，该有多好？</p>\n<h3 id="functor"><a href="#functor" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Functor</h3>\n<p>函数式以一种完全不同的方法应对软件系统的错误处理，其思想说起来也非常简单，就是创建一个安全的容器，来存放危险的代码,在函数式编程中，仍然会包裹这些危险的代码，但可以不用try-catch</p>\n<h4 id="box包裹不安全的值"><a href="#box%E5%8C%85%E8%A3%B9%E4%B8%8D%E5%AE%89%E5%85%A8%E7%9A%84%E5%80%BC" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Box包裹不安全的值</h4>\n<p>将值包裹起来是函数式编程的一个基本设计模式，因为这直接保证了值不会被人意的篡改，这又点像给值披铠甲，只能通过map操作来访问该容器中的值。实际上最常见的数组的map方法就是一个典型的例子，而所谓的数组，也不过就是值的容器。</p>\n<p>其实不仅仅只有数组可以映射，理论上来说，任何数据类型都可以映射，map只不过是一个函数，由于其引用透明性，只要输入相同，map永远会返回相同的结果。</p>\n<p>还可以认为map是可以使用lambda表达式变换容器内的值的途径！</p>\n<p>下面说明一下，怎么包装一个数据，使之成为mapable(可map)的对象，这对学习什么是Functor很有帮助</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">class</span> <span class="token class-name">Wrapper</span> <span class="token punctuation">{</span>\n    <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>_value <span class="token operator">=</span> value\n    <span class="token punctuation">}</span>\n\n    <span class="token function">map</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_value<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`Wrapper (</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>_value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// wrap :: A -> Wrapper(A)</span>\n<span class="token keyword">const</span> <span class="token function-variable function">wrap</span> <span class="token operator">=</span> val <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Wrapper</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span></code></pre>\n      </div>\n<p>要访问包裹内的对象，唯一的办法就是<code class="gatsby-code-text">map</code> <code class="gatsby-code-text">x =&gt; x</code>函数，虽然JavaScript允许用户通过<code class="gatsby-code-text">_value</code>属性来访问这个被包裹的属性值，但是一旦该值进入到容器中，我们就不应该继续直接获取或者修改该值了(就像一个虚拟的屏障)。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> wrapperValue <span class="token operator">=</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token string">\'functional pro\'</span><span class="token punctuation">)</span>\nwrapperValue<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x<span class="token punctuation">)</span>   <span class="token comment">// -> functional pro</span></code></pre>\n      </div>\n<p>其实还可以映射任何函数到该容器，比如打印日志，或者变换该值</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">wrapperValue<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span> \nwrapperValue<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// -> FUNCTIONAL PRO</span></code></pre>\n      </div>\n<p>如此以来，所有对值的操作都必须借助<code class="gatsby-code-text">Wrapper.map</code>“伸入”容器，从而使值得到一定的保护。</p>\n<p>还有一种更高级的map -> <code class="gatsby-code-text">fmap</code>;</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">class</span> <span class="token class-name">Wrapper</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ....</span>\n\n    <span class="token comment">/**\n     * Functor 函子\n     * fmap首先会打开容器，然后把值通过函数映射到另外一个值；\n     * 最后把结果值包裹到一个新的同类型容器中\n     * fmap总会返回相同的类型，这样就可以链式的调用fmap\n     * 完全类似于数组的map、filter、reduce方法\n     * @param {Function} fn \n     */</span>\n    <span class="token function">fmap</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">return</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_value<span class="token punctuation">)</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// ....</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p><code class="gatsby-code-text">map</code>知道如何在上下文中应该函数值。它首先会打开该容器，然后把值通过函数映射为另外一个值，最后把结果值再次包裹到一个新的同类型的容器中。拥有这种函数的类型被称为<strong>Functor</strong>。</p>\n<p>从本质上来说，<code class="gatsby-code-text">Functor</code>只是一个可以将函数应用到包裹的值上，并将结果再包裹起来的数据结构。</p>\n<p>fmap的一般定义为：\n<code class="gatsby-code-text">fmap :: (A -&gt; B) -&gt; Wrapper(A) -&gt; Wrapper(B)</code></p>\n<p>看一个简单的例子：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> plus <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token operator">=></span> a <span class="token operator">+</span> b<span class="token punctuation">)</span>\n<span class="token keyword">const</span> plus3 <span class="token operator">=</span> <span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> plus10 <span class="token operator">=</span> <span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p>现在可以把数字2放到Wrapper中：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> two <span class="token operator">=</span> <span class="token function">wrap</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p>在调用<code class="gatsby-code-text">fmap</code>把<code class="gatsby-code-text">plus3</code>映射到容器上：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> five <span class="token operator">=</span> two<span class="token punctuation">.</span><span class="token function">fmap</span><span class="token punctuation">(</span>plus3<span class="token punctuation">)</span>  <span class="token comment">// -> Wrapper(5) 返回一个被包裹的 5</span></code></pre>\n      </div>\n<p><code class="gatsby-code-text">fmap</code>返回同样类型的数据，因此可以链式的连续调用<code class="gatsby-code-text">fmap</code>，来转换值。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">two<span class="token punctuation">.</span><span class="token function">fmap</span><span class="token punctuation">(</span>plus3<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fmap</span><span class="token punctuation">(</span>plus10<span class="token punctuation">)</span> <span class="token comment">// -> Wrapper(5) 返回一个被包裹的 15</span></code></pre>\n      </div>\n<p>毫无疑问这种链式的连续调用太眼熟了。其实绝大多数的开发人员一直在使用<code class="gatsby-code-text">Functor</code>却没有意识到而已。比如：<code class="gatsby-code-text">Array</code>的<code class="gatsby-code-text">map</code>和<code class="gatsby-code-text">filter</code>方法都是返回同样类型的<code class="gatsby-code-text">Functor</code>,因此可以不断的连续调用。</p>\n<p>再看看另一个<strong>Functor</strong>：<code class="gatsby-code-text">compose</code>,这是一个从多个函数到一个函数的映射(也保持了类型的不变)。\n<code class="gatsby-code-text">const compose = (...fns) =&gt; x =&gt; fns.reduceRight((y, f) =&gt; f(y), x);</code></p>\n<p><strong>Functor</strong>具有如下一些重要的约束：</p>\n<ul>\n<li>\n<p>必须是无副作用的。如果一个Functor再映射之后，通过<code class="gatsby-code-text">x =&gt; x</code>函数取得和映射之前完全相同的值，则可以认为该Functor是无副作用的。</p>\n</li>\n<li>\n<p>必须是可组合的。这个组合的意思时说<code class="gatsby-code-text">fmap</code>函数的组合，与分别<code class="gatsby-code-text">fmap</code>函数是一样的。比如下面两个表达式的效果是一样的。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 分别fmap</span>\ntwo<span class="token punctuation">.</span><span class="token function">fmap</span><span class="token punctuation">(</span>plus3<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fmap</span><span class="token punctuation">(</span>plus5<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x<span class="token punctuation">)</span>        <span class="token comment">// Wrapper(10)</span>\n<span class="token comment">// 组合函数，然后fmap</span>\ntwo<span class="token punctuation">.</span><span class="token function">fmap</span><span class="token punctuation">(</span><span class="token function">compose</span><span class="token punctuation">(</span>plus3<span class="token punctuation">,</span> plus5<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x<span class="token punctuation">)</span>    <span class="token comment">// Wrapper(10)</span></code></pre>\n      </div>\n</li>\n</ul>\n<p><strong>Functor</strong>的这些属性并不奇怪。遵守这些规则，可以免于抛出异常、篡改元素或者改变函数的行为。其实实际目的<strong>只是创建一个上下文或者抽象</strong>，以便可以安全的应用操作到值，而不是改变原来的值。这也是map可以将一个数组转换为另一个数组，而不是改变原数组的原因。而<strong>Functor</strong>就是这个概念的推广。</p>\n<p><strong>Functor</strong>并不需要知道如何处理null,例如Ramda中的<code class="gatsby-code-text">R.compose</code>再接收到一个为null的函数引用时，就会抛出异常，这完全是预期的行为，并不是设计上的缺陷</p>\n<p>还有一个更为具体化的函数式数据类型<strong>Monad</strong>(单子),<strong>Monad</strong>可以简化代码中的错误处理，进而更流畅的进行函数组合。但是它跟<strong>Functor</strong>有什么关系呢？其实<strong>Monad</strong>就是<strong>Functor</strong><code class="gatsby-code-text">伸入</code>的容器。</p>\n<blockquote>\n<p>另一个比喻：Monad是一个宝盒(Wrapper)，而Functor就是深入到宝盒中的手(fmap)</p>\n</blockquote>\n<p>不要因为听到<strong>Monad</strong>这样的术语，就灰心丧气。其实大多数的JavaScript开发人员都接触过<strong>Monad</strong>，那就是Jquery的代码。<strong>Monad</strong>只是给一些资源提供了一个安全的抽象，例如：一个简单的价值，一个DOM元素、事件、Ajax调用，这样就可以安全的处理其中包含的数据。比如：<code class="gatsby-code-text">Jquery</code>就可以看作DOM的Monad：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">\'#some\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fadeIn</span><span class="token punctuation">(</span><span class="token number">3000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token string">\'hello world\'</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p>这段代码之所以像Monad，是因为jQuery可以安全的将fadeIn和text行为应用到DOM上，如果<code class="gatsby-code-text">#some</code>没有找到，将方法应用到空的Jquery方法上，就像什么也没有发生一样，也不会抛出异常。Monad旨在安全的传送错误，这样整个应用才能有比较好的容错性。</p>\n<blockquote>\n<p>或者说Monad是为了更好的包装数据，同时提供了错误数据的处理方案</p>\n</blockquote>',
frontmatter:{title:"FP10：Functor",img:"./img/2018-07-26.jpeg",author:["Sylvenas"],excerpt:null,catalogue:null},fields:{date:"July 25, 2018",path:"blog/functional/2018-07-26-FP10-Functor.md",slug:"/blog/2018/07/26/FP10-Functor.html"}},allMarkdownRemark:{edges:[{node:{frontmatter:{title:"加法是自然之道 - Monoid"},fields:{slug:"/blog/2020/03/02/加法是自然之道.html"}}},{node:{frontmatter:{title:"俄罗斯套娃娃 - Monad"},fields:{slug:"/blog/2020/02/12/俄罗斯套娃娃.html"}}},{node:{frontmatter:{title:"纪念刘和珍君"},fields:{slug:"/blog/2020/02/07/记念刘和珍君.html"}}},{node:{frontmatter:{title:"应用函子 - Applicative"},fields:{slug:"/blog/2020/02/05/应用函子.html"}}},{node:{frontmatter:{title:"动物庄园"},fields:{slug:"/blog/2020/02/01/动物庄园.html"}}},{node:{frontmatter:{title:"薛定谔的 Maybe - IO"},fields:{slug:"/blog/2020/01/30/薛定谔的Maybe.html"}}},{node:{frontmatter:{title:"Abort-Controller"},fields:{slug:"/blog/2020/01/18/abort-controller.html"}}},{node:{frontmatter:{title:"Catch React Error"},fields:{slug:"/blog/2020/01/02/catch-react-error.html"}}},{node:{frontmatter:{title:"Node.js 集群"},fields:{slug:"/blog/2019/11/12/node-cluster.html"}}},{node:{frontmatter:{title:"黑珍珠号的诅咒 - Functor"},fields:{slug:"/blog/2019/09/10/黑珍珠号的诅咒.html"}}}]}},pathContext:{slug:"/blog/2018/07/26/FP10-Functor.html"}}}});