webpackJsonp([0xaddb71e382d8],{461:function(n,a){n.exports={data:{markdownRemark:{html:'<h3 id="单例模式"><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单例模式</h3>\n<p>单例模式又被称为单体模式，在面向对象思想中，单例就是保证一个类只有一个实例，实现的方法一般是在类的内部提供一个<code>getInstance</code>方法用来创建实例(在类的外部不允许使用<code>new</code>关键字创建实例)，先判断类的实例是否存在，如果存在直接返回，如果不存在就创建了再返回，这样就可以确保一个类只有一个实例对象；</p>\n<p>从上面的描述，我们可以看出单例模式的核心在于系统中某些变量有且只有一个，暴露出来供外部使用。</p>\n<blockquote>\n<p>由于在js中创建对象实例的方法有很多不一定非要通过<code>class</code>、<code>new</code>等概念。</p>\n</blockquote>\n<h3 id="对象字面量模式"><a href="#%E5%AF%B9%E8%B1%A1%E5%AD%97%E9%9D%A2%E9%87%8F%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>对象字面量模式</h3>\n<p>对象字面量模式是项目开发中使用频率非常高的模式，例如：我们在一个多人项目开发中，通常会抽象出很多公用的模块和方法等，那么最常见的一个工具类，一般定义为：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token keyword">var</span> utils <span class="token operator">=</span> <span class="token punctuation">{</span>\n\tformatDate<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\tajax<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\tcurry<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\t<span class="token comment" spellcheck="true">// ....</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>那么我们在其他地方要使用某个方法的时候直接<code>utils.curry(..)</code>即可，但是有一点我们必须明确下来，就是整个项目中<code>utils</code>对象有且只能有一个，如果有两个开发同学，分别写了一个<code>utils</code>，那我们其他的人就会迷惑，甚至用错。</p>\n<h3 id="js面向对象单例模式"><a href="#js%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JS面向对象单例模式</h3>\n<h4 id="饿汉模式"><a href="#%E9%A5%BF%E6%B1%89%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>饿汉模式</h4>\n<p>上面的代码我们是直接创建了一个对象字面量来确保只有一个<code>utils</code>的实例，那么如何实现面向对象式的单例模式呢，例如我们每个公司只能有一个CEO,那么这段代码可以这样写：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token keyword">var</span> getCEO <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">var</span> instance<span class="token punctuation">;</span>\n\t<span class="token keyword">var</span> createCEO <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token keyword">return</span> instance <span class="token operator">=</span> <span class="token punctuation">{</span>\n\t\t\tname<span class="token punctuation">:</span> <span class="token string">\'霸道总裁\'</span><span class="token punctuation">,</span>\n\t\t\tage<span class="token punctuation">:</span> <span class="token string">\'35\'</span><span class="token punctuation">,</span>\n\t\t\tsex<span class="token punctuation">:</span> <span class="token string">\'male\'</span>\n\t\t<span class="token punctuation">}</span>\n\t<span class="token punctuation">}</span>\n<span class="gatsby-highlight-code-line">\tinstance <span class="token operator">=</span> <span class="token function">createCEO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</span>\t<span class="token keyword">return</span> <span class="token punctuation">{</span>\n\t\tgetInstance<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="gatsby-highlight-code-line">\t\t\t<span class="token keyword">return</span> instance<span class="token punctuation">;</span>\n</span>\t\t<span class="token punctuation">}</span>\n\t<span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>上面的方法我们通过方法自执行，直接创建好了一个<code>instance</code>,然后外面如果要用的情况下则直接把这个已经创建好的<code>CEO</code>的实例<code>return</code>出去就可以了。</p>\n<p>但是这个思路有个缺点就是不管我们会不会用到这个<code>instance</code>,都会事先创建<code>instance</code>对象，消耗一定的内存，那么可不可以在当我们需要的时候在创建这个<code>instance</code>呢</p>\n<h4 id="懒汉模式"><a href="#%E6%87%92%E6%B1%89%E6%A8%A1%E5%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>懒汉模式</h4>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token keyword">var</span> getCEO <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t<span class="token keyword">var</span> instance<span class="token punctuation">;</span>\n\t<span class="token keyword">var</span> createCEO <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n\t\t<span class="token keyword">return</span> instance <span class="token operator">=</span> <span class="token punctuation">{</span>\n\t\t\tname<span class="token punctuation">:</span> <span class="token string">\'霸道总裁\'</span><span class="token punctuation">,</span>\n\t\t\tage<span class="token punctuation">:</span> <span class="token string">\'35\'</span><span class="token punctuation">,</span>\n\t\t\tsex<span class="token punctuation">:</span> <span class="token string">\'male\'</span>\n\t\t<span class="token punctuation">}</span>\n\t<span class="token punctuation">}</span>\n\t<span class="token keyword">return</span> <span class="token punctuation">{</span>\n\t\tgetInstance<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n<span class="gatsby-highlight-code-line">\t\t\t<span class="token keyword">return</span> instance <span class="token operator">||</span> <span class="token punctuation">(</span>instance <span class="token operator">=</span> <span class="token function">createCEO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n</span>\t\t<span class="token punctuation">}</span>\n\t<span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n<span class="token keyword">var</span> ceo1 <span class="token operator">=</span> getCEO<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> ceo2 <span class="token operator">=</span> getCEO<span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ceo1<span class="token punctuation">,</span> ceo2<span class="token punctuation">,</span> ceo1 <span class="token operator">===</span> ceo2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// true</span>\n</code></pre>\n      </div>\n<p>懒汉模式的优点在于只有使用时次啊会将类实例化，这在一定程度上节约了资源。\n缺点在于第一次需要<code>instance</code>的时候，会速度稍慢。</p>\n<h3 id="单例模式的优点"><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E4%BC%98%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单例模式的优点</h3>\n<ul>\n<li>利用对象字面量可以声明一个命名空间，例如：<code>utils</code>中包含了很多常用的方法，但是我们之暴露出去一个全局的<code>utils</code>对象，来替代暴露出去<code>formatDate</code>,<code>ajax</code>等等一众的方法，这样可以方便我们很好的解决命名冲突的问题，一级更好的维护代码，更好的控制代码。</li>\n<li>在需要同一个对象的时候，我们通过<code>懒汉模式</code>和<code>饿汉模式</code>来仅仅创建一个实例，比每次都重新<code>new</code>一个新的减少了大量的创建过程和内存消耗，有利于提升性能。</li>\n</ul>\n<h3 id="单例模式的缺点"><a href="#%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BC%BA%E7%82%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单例模式的缺点</h3>\n<ul>\n<li>扩展性不好，对一个单例对象里的某个变量或者方法进行重写，会全部影响其他的正在使用该方法的代码，例如：我们<code>utils.formatDate = otherFunction</code>,那么这个时候可能整个系统其他的地方会出现很多错误。</li>\n<li>灵活性不足，当我们需要扩展<code>utils.formatDate</code>的时候，但是其他地方却不想变动，这个时候单例模式就不好处理了。</li>\n</ul>',frontmatter:{title:"单例模式",img:"./img/2018-02-01.jpeg",author:["sylvenas"],excerpt:"单例模式又被称为单体模式，在面向对象思想中，单例就是保证一个类只有一个实例，实现的方法一般是在类的内部提供一个`getInstance`方法用来创建实例...",catalogue:null},fields:{date:"January 31, 2018",path:"blog/design-pattern/2018-02-01-singleton.md",slug:"/blog/2018/02/01/singleton.html"}},allMarkdownRemark:{edges:[{node:{frontmatter:{title:"FP18：Semigroup"},fields:{slug:"/blog/2018/12/13/FP18-Semigroup.html"}}},{node:{frontmatter:{title:"FP17：Transform Naturally"},fields:{slug:"/blog/2018/12/11/FP17-Transform-Naturally.html"}}},{node:{frontmatter:{title:"FP16：Applicative Functor"},fields:{slug:"/blog/2018/11/07/FB16-Applicative-Functor.html"}}},{node:{frontmatter:{title:"FP15：Monad-2"},fields:{slug:"/blog/2018/09/11/FB15-Monad-2.html"}}},{node:{frontmatter:{title:"FP14：Monad-1"},fields:{slug:"/blog/2018/09/02/FP14-Monad-1.html"}}},{node:{frontmatter:{title:"代理模式"},fields:{slug:"/blog/2018/08/24/代理-pattern.html"}}},{node:{frontmatter:{title:"'类'模式"},fields:{slug:"/blog/2018/08/24/class-pattern.html"}}},{node:{frontmatter:{title:"FP13：IO - keep code pure"},fields:{slug:"/blog/2018/08/08/FP13-IO.html"}}},{node:{frontmatter:{title:"FP12：Either:Left or Right"},fields:{slug:"/blog/2018/08/03/FP12-Either.html"}}},{node:{frontmatter:{title:"FP11：Schrödinger's Maybe"},fields:{slug:"/blog/2018/08/02/FP11-Maybe.html"}}}]}},pathContext:{slug:"/blog/2018/02/01/singleton.html"}}}});