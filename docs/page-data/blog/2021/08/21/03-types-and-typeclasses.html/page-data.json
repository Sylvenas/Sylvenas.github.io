{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/2021/08/21/03-types-and-typeclasses.html","result":{"data":{"markdownRemark":{"html":"<h1>types-and-type-classes</h1>\n<h2>相信类型</h2>\n<p>[^img/cow.png]</p>\n<p>在前面我们谈到Haskell是静态类型的，在编译时每个表达式的类型都已明确，这就提高了代码的安全性。若代码中让布尔值与数字相除，就不会通过编译。这样的好处就是与其让程序在运行时崩溃，不如在编译时捕获可能的错误。Haskell中万物皆有类型，因此在执行编译之时编译器可以大有所为。</p>\n<p>与Java和Pascal不同，haskell支持类型推导。写下一个数字，你就没必要另告诉haskell说“它是个数字”，它自己能推导出来。这样我们就不必在每个函数或表达式上都标明其类型了。在前面我们只简单涉及一下haskell的类型方面的知识，但是理解这一类型系统对于haskell的学习是至关重要的。</p>\n<p>类型是每个表达式都有的某种标签，它标明了这一表达式所属的范畴。例如，表达式True是boolean型，\"hello\"是个字符串，等等。</p>\n<p>可以使用ghci来检测表达式的类型。使用:t命令后跟任何可用的表达式，即可得到该表达式的类型，先试一下：</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span><span class=\"token hvariable\">t</span> <span class=\"token char string\">'a'</span>  \n<span class=\"token char string\">'a'</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Char</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span><span class=\"token hvariable\">t</span> <span class=\"token constant\">True</span>  \n<span class=\"token constant\">True</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Bool</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span><span class=\"token hvariable\">t</span> <span class=\"token string\">\"HELLO!\"</span>  \n<span class=\"token string\">\"HELLO!\"</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Char</span><span class=\"token punctuation\">]</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span><span class=\"token hvariable\">t</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span>  \n<span class=\"token punctuation\">(</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span> <span class=\"token char string\">'a'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Bool</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Char</span><span class=\"token punctuation\">)</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span><span class=\"token hvariable\">t</span> <span class=\"token number\">4</span> <span class=\"token operator\">==</span> <span class=\"token number\">5</span>  \n<span class=\"token number\">4</span> <span class=\"token operator\">==</span> <span class=\"token number\">5</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Bool</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>[$img/bomb.png]</p>\n<p>可以看出，<code class=\"language-text\">:t</code>命令处理一个表达式的输出结果为表达式后跟<code class=\"language-text\">::</code>及其类型，<code class=\"language-text\">::</code>读作“它的类型为”。凡是明确的类型，其首字母必为大写。<code class=\"language-text\">'a'</code>,如它的样子，是<code class=\"language-text\">Char</code>类型，易知是个字符（character）。<code class=\"language-text\">True</code>是<code class=\"language-text\">Bool</code>类型，也靠谱。不过这又是啥，检测<code class=\"language-text\">\"HELLO!\"</code>得一个 <code class=\"language-text\">[Char]</code>？这方括号表示一个List，所以我们可以将其读作“一组字符的List”。而与List不同，每个Tuple都是独立的类型，于是<code class=\"language-text\">(True,'a')</code>的类型是<code class=\"language-text\">(Bool,Char)</code>，而<code class=\"language-text\">('a','b','c')</code>的类型为<code class=\"language-text\">(Char,Char,Char)</code>。<code class=\"language-text\">4==5</code>一定返回 False，所以它的类型为Bool。</p>\n<p>同样，函数也有类型。编写函数时，给它一个明确的类型声明是个好习惯，比较短的函数就不用多此一举了。还记得前面那个过滤大写字母的List Comprehension吗？给它加上类型声明便是这个样子：</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">removeNonUppercase</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Char</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">Char</span><span class=\"token punctuation\">]</span>  \n<span class=\"token hvariable\">removeNonUppercase</span> <span class=\"token hvariable\">st</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">[</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">|</span> <span class=\"token hvariable\">c</span> <span class=\"token operator\">&lt;-</span> <span class=\"token hvariable\">st</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">c</span> `<span class=\"token builtin\">elem</span>` <span class=\"token punctuation\">[</span><span class=\"token char string\">'A'</span><span class=\"token operator\">..</span><span class=\"token char string\">'Z'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">]</span>   \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">removeNonUppercase</code>的类型为<code class=\"language-text\">[Char]->[Char]</code>，从它的参数和返回值的类型上可以看出，它将一个字符串映射为另一个字符串。<code class=\"language-text\">[Char]</code>与<code class=\"language-text\">String</code>是等价的，但使用String会更清晰：<code class=\"language-text\">removeNonUppercase :: String -> String</code>。编译器会自动检测出它的类型，我们还是标明了它的类型声明。要是多个参数的函数该怎样？如下便是一个将三个整数相加的简单函数。</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">addThree</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Int</span>  \n<span class=\"token hvariable\">addThree</span> <span class=\"token hvariable\">x</span> <span class=\"token hvariable\">y</span> <span class=\"token hvariable\">z</span> <span class=\"token operator\">=</span> <span class=\"token hvariable\">x</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">y</span> <span class=\"token operator\">+</span> <span class=\"token hvariable\">z</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>参数之间由->分隔，而与返回值之间并无特殊差异。返回值是最后一项，参数就是前三项。稍后，我们将讲解为何只用->而不是<code class=\"language-text\">Int,Int,Int->Int</code>之类“更好看”的方式来分隔参数。</p>\n<p>如果你打算给你编写的函数加上个类型声明却拿不准它的类型是啥，只要先不写类型声明，把函数体写出来，再使用:t命令测一下即可。函数也是表达式，所以:t对函数也是同样可用的。</p>\n<p>如下是几个常见的类型：</p>\n<p><strong>Int</strong>表示整数。7可以是Int，但7.2不可以。Int是有界的，也就是说它由上限和下限。对32位的机器而言，上限一般是214748364，下限是-214748364。</p>\n<p><strong>Integer</strong>表示...厄...也是整数，但它是无界的。这就意味着可以用它存放非常非常大的数，我是说非常大。它的效率不如Int高。</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">factorial</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Integer</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Integer</span>  \n<span class=\"token hvariable\">factorial</span> <span class=\"token hvariable\">n</span> <span class=\"token operator\">=</span> <span class=\"token builtin\">product</span> <span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token operator\">..</span><span class=\"token hvariable\">n</span><span class=\"token punctuation\">]</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token hvariable\">factorial</span> <span class=\"token number\">50</span>  \n<span class=\"token number\">30414093201713378043612608166064768844377641568960512000000000000</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Float</strong>表示单精度的浮点数。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\ncircumference <span class=\"token operator\">:</span><span class=\"token operator\">:</span> Float <span class=\"token operator\">-</span><span class=\"token operator\">></span> Float  \ncircumference r <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> pi <span class=\"token operator\">*</span> r  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\nghci<span class=\"token operator\">></span> circumference <span class=\"token number\">4.0</span>  \n<span class=\"token number\">25.132742</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Double</strong>表示双精度的浮点数。</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">circumference</span>' <span class=\"token operator\">::</span> <span class=\"token constant\">Double</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Double</span>  \n<span class=\"token hvariable\">circumference</span>' <span class=\"token hvariable\">r</span> <span class=\"token operator\">=</span> <span class=\"token number\">2</span> <span class=\"token operator\">*</span> <span class=\"token builtin\">pi</span> <span class=\"token operator\">*</span> <span class=\"token hvariable\">r</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token hvariable\">circumference</span>' <span class=\"token number\">4.0</span>  \n<span class=\"token number\">25.132741228718345</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Bool</strong>表示布尔值，它只有两种值：True和False。</p>\n<p><strong>Char</strong>表示一个字符。一个字符由单引号括起，一组字符的List即为字符串。</p>\n<p>Tuple的类型取决于它的长度及其中项的类型。注意，空Tuple同样也是个类型，它只有一种值：<code class=\"language-text\">()</code>。</p>\n<h2>类型变量</h2>\n<p>你觉得head函数的类型是啥？它可以取任意类型的List的首项，是怎么做到的呢？我们查一下！</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span><span class=\"token hvariable\">t</span> <span class=\"token builtin\">head</span>  \n<span class=\"token builtin\">head</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">[</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>[^img/box.png]</p>\n<p>嗯! a是啥？类型吗？想想我们在前面说过，凡是类型其首字母必大写，所以它不会是个类型。它是个类型变量，意味着a可以是任意的类型。这一点与其他语言中的泛型(generic)很相似，但在haskell中要更为强大。它可以让我们轻而易举地写出类型无关的函数。使用到类型变量的函数被称作“多态函数 ”，head函数的类型声明里标明了它可以取任意类型的List并返回其中的第一个元素。</p>\n<p>在命名上，类型变量使用多个字符是合法的，不过约定俗成，通常都是使用单个字符，如a,b,c,d...</p>\n<p>还记得fst？我们查一下它的类型：</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span><span class=\"token hvariable\">t</span> <span class=\"token builtin\">fst</span>  \n<span class=\"token builtin\">fst</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token hvariable\">a</span><span class=\"token punctuation\">,</span> <span class=\"token hvariable\">b</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>可以看到fst取一个包含两个类型的Tuple作参数，并以第一个项的类型作为返回值。这便是fst可以处理一个含有两种类型项的pair的原因。注意，a和b是不同的类型变量，但它们不一定非得是不同的类型，它只是标明了首项的类型与返回值的类型相同。</p>\n<h2>类型类101</h2>\n<p>[$img/classes.png]</p>\n<p>类型定义行为的接口，如果一个类型属于某类型类，那它必实现了该类型类所描述的行为。很多从OOP走过来的人们往往会把类型类当成面向对象语言中的类而感到疑惑，厄，它们不是一回事。易于理解起见，你可以把它看做是java中接口（interface）的类似物。</p>\n<p><code class=\"language-text\">==</code>函数的类型声明是怎样的？</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span><span class=\"token hvariable\">t</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">==</span><span class=\"token punctuation\">)</span>  \n<span class=\"token punctuation\">(</span><span class=\"token operator\">==</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Eq</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<blockquote>\n<p>判断相等的==运算符是函数，<code class=\"language-text\">+-*/</code>之类的运算符也是同样。在默认条件下，它们多为中缀函数。若要检查它的类型，就必须得用括号括起使之作为另一个函数，或者说以前缀函数的形式调用它。</p>\n</blockquote>\n<p>有意思。在这里我们见到个新东西：=>符号。它左边的部分叫做类型约束。我们可以这样阅读这段类型声明：“相等函数取两个相同类型的值作为参数并返回一个布尔值，而这两个参数的类型同在Eq类之中（即类型约束）”</p>\n<p><strong>Eq</strong>这一类型类提供了判断相等性的接口，凡是可比较相等性的类型必属于Eq类。</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token number\">5</span> <span class=\"token operator\">==</span> <span class=\"token number\">5</span>   \n<span class=\"token constant\">True</span>   \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token number\">5</span> <span class=\"token operator\">/=</span> <span class=\"token number\">5</span>   \n<span class=\"token constant\">False</span>   \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token char string\">'a'</span> <span class=\"token operator\">==</span> <span class=\"token char string\">'a'</span>   \n<span class=\"token constant\">True</span>   \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token string\">\"Ho Ho\"</span> <span class=\"token operator\">==</span> <span class=\"token string\">\"Ho Ho\"</span>   \n<span class=\"token constant\">True</span>   \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token number\">3.432</span> <span class=\"token operator\">==</span> <span class=\"token number\">3.432</span>   \n<span class=\"token constant\">True</span> \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>elem函数的类型为: <code class=\"language-text\">(Eq a)=>a->[a]->Bool</code>。这是它在检测值是否存在于一个list时使用到了==的缘故。</p>\n<p>几个基本的类型类：</p>\n<p><strong>Eq</strong>包含可判断相等性的类型。提供实现的函数是==和/=。所以，只要一个函数有Eq类的类型限制，那么它就必定在定义中用到了==和/=。刚才说了，除函数以外的所有类型都属于Eq，所以它们都可以判断相等性。</p>\n<p><strong>Ord</strong>包含可比较大小的类型。除了函数以外，我们目前所谈到的所有类型都属于Ord类。Ord包中包含了<code class=\"language-text\">&lt;,>,&lt;=,>=</code>之类用于比较大小的函数。compare函数取两个Ord类中的相同类型的值作参数，返回比较的结果。这个结果是如下三种类型之一：GT,LT,EQ。</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span><span class=\"token hvariable\">t</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span>  \n<span class=\"token punctuation\">(</span><span class=\"token operator\">></span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Ord</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token constant\">Bool</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>类型若要成为Ord的成员，必先加入Eq家族。</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token string\">\"Abrakadabra\"</span> <span class=\"token operator\">&lt;</span> <span class=\"token string\">\"Zebra\"</span>  \n<span class=\"token constant\">True</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token string\">\"Abrakadabra\"</span> `<span class=\"token builtin\">compare</span>` <span class=\"token string\">\"Zebra\"</span>  \n<span class=\"token constant\">LT</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token number\">5</span> <span class=\"token operator\">>=</span> <span class=\"token number\">2</span>  \n<span class=\"token constant\">True</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token number\">5</span> `<span class=\"token builtin\">compare</span>` <span class=\"token number\">3</span>  \n<span class=\"token constant\">GT</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Show</strong>的成员为可用字符串表示的类型。目前为止，除函数以外的所有类型都是Show的成员。操作Show类型类，最常用的函数表示show。它可以取任一Show的成员类型并将其转为字符串。</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">show</span> <span class=\"token number\">3</span>  \n<span class=\"token string\">\"3\"</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">show</span> <span class=\"token number\">5.334</span>  \n<span class=\"token string\">\"5.334\"</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">show</span> <span class=\"token constant\">True</span>  \n<span class=\"token string\">\"True\"</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Read</strong>是与Show相反的类型类。read函数可以将一个字符串转为Read的某成员类型。</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">read</span> <span class=\"token string\">\"True\"</span> <span class=\"token operator\">||</span> <span class=\"token constant\">False</span>  \n<span class=\"token constant\">True</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">read</span> <span class=\"token string\">\"8.2\"</span> <span class=\"token operator\">+</span> <span class=\"token number\">3.8</span>  \n<span class=\"token number\">12.0</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">read</span> <span class=\"token string\">\"5\"</span> <span class=\"token operator\">-</span> <span class=\"token number\">2</span>  \n<span class=\"token number\">3</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">read</span> <span class=\"token string\">\"[1,2,3,4]\"</span> <span class=\"token operator\">++</span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>  \n<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span><span class=\"token number\">2</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">3</span><span class=\"token punctuation\">]</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>一切良好，如上的所有类型都属于这一类型类。尝试read \"4\"又会怎样？</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">read</span> <span class=\"token string\">\"4\"</span>  \n<span class=\"token operator\">&lt;</span> <span class=\"token hvariable\">interactive</span> <span class=\"token operator\">>:</span><span class=\"token number\">1</span><span class=\"token operator\">:</span><span class=\"token number\">0</span><span class=\"token operator\">:</span>  \n    <span class=\"token constant\">Ambiguous</span> <span class=\"token keyword\">type</span> <span class=\"token hvariable\">variable</span> `<span class=\"token hvariable\">a</span>' <span class=\"token keyword\">in</span> <span class=\"token hvariable\">the</span> <span class=\"token hvariable\">constraint</span><span class=\"token operator\">:</span>  \n      `<span class=\"token constant\">Read</span> <span class=\"token hvariable\">a</span>' <span class=\"token hvariable\">arising</span> <span class=\"token hvariable\">from</span> <span class=\"token hvariable\">a</span> <span class=\"token hvariable\">use</span> <span class=\"token keyword\">of</span> `<span class=\"token builtin\">read</span>' <span class=\"token hvariable\">at</span> <span class=\"token operator\">&lt;</span><span class=\"token hvariable\">interactive</span><span class=\"token operator\">>:</span><span class=\"token number\">1</span><span class=\"token operator\">:</span><span class=\"token number\">0</span><span class=\"token operator\">-</span><span class=\"token number\">7</span>  \n    <span class=\"token constant\">Probable</span> <span class=\"token hvariable\">fix</span><span class=\"token operator\">:</span> <span class=\"token hvariable\">add</span> <span class=\"token hvariable\">a</span> <span class=\"token keyword\">type</span> <span class=\"token hvariable\">signature</span> <span class=\"token hvariable\">that</span> <span class=\"token hvariable\">fixes</span> <span class=\"token hvariable\">these</span> <span class=\"token keyword\">type</span> <span class=\"token hvariable\">variable</span><span class=\"token punctuation\">(</span><span class=\"token hvariable\">s</span><span class=\"token punctuation\">)</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>ghci跟我们说它搞不清楚我们想要的是什么样的返回值。注意调用read后跟的那部分，ghci通过它来辨认其类型。若要一个boolean值，他就知道必须得返回一个Bool类型的值。但在这里它只知道我们要的类型属于Read类型类，而不能明确到底是哪个。看一下read函数的类型声明吧：</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span><span class=\"token hvariable\">t</span> <span class=\"token builtin\">read</span>  \n<span class=\"token builtin\">read</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Read</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token constant\">String</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>看？它的返回值属于Read类型类，但我们若用不到这个值，它就永远都不会得知该表达式的类型。所以我们需要在一个表达式后跟<code class=\"language-text\">::</code>的<em>类型注释</em>，以明确其类型。如下：</p>\n<p>{{\nghci> read \"5\" :: Int<br>\n5<br>\nghci> read \"5\" :: Float<br>\n5.0<br>\nghci> (read \"5\" :: Float) * 4<br>\n20.0<br>\nghci> read \"[1,2,3,4]\" :: [Int]<br>\n[1,2,3,4]<br>\nghci> read \"(3, 'a')\" :: (Int, Char)<br>\n(3, 'a')<br>\n}}</p>\n<p>编译器可以辨认出大部分表达式的类型，但遇到<code class=\"language-text\">read \"5\"</code>的时候它就搞不清楚究竟该是Int还是Float了。只有经过运算，haskell才会明确其类型；同时由于haskell是静态的，它还必须得在 编译前搞清楚所有值的类型。所以我们就最好提前给它打声招呼：“嘿，这个表达式应该是这个类型，省的你认不出来！”</p>\n<p><strong>Enum</strong>的成员都是连续的类型--也就是可枚举。Enum类存在的主要好处就在于我们可以在Range中用到它的成员类型：每个值都有后继子(successer)和前置子(predecesor)，分别可以通过succ函数和pred函数得到。该类型类包含的类型有：<code class=\"language-text\">()</code>, <code class=\"language-text\">Bool</code>, <code class=\"language-text\">Char</code>, <code class=\"language-text\">Ordering</code>, <code class=\"language-text\">Int</code>, <code class=\"language-text\">Integer</code>, <code class=\"language-text\">Float</code> 和 <code class=\"language-text\">Double</code>。</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token char string\">'a'</span><span class=\"token operator\">..</span><span class=\"token char string\">'e'</span><span class=\"token punctuation\">]</span>  \n<span class=\"token string\">\"abcde\"</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token constant\">LT</span> <span class=\"token operator\">..</span> <span class=\"token constant\">GT</span><span class=\"token punctuation\">]</span>  \n<span class=\"token punctuation\">[</span><span class=\"token constant\">LT</span><span class=\"token punctuation\">,</span><span class=\"token constant\">EQ</span><span class=\"token punctuation\">,</span><span class=\"token constant\">GT</span><span class=\"token punctuation\">]</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token punctuation\">[</span><span class=\"token number\">3</span> <span class=\"token operator\">..</span> <span class=\"token number\">5</span><span class=\"token punctuation\">]</span>  \n<span class=\"token punctuation\">[</span><span class=\"token number\">3</span><span class=\"token punctuation\">,</span><span class=\"token number\">4</span><span class=\"token punctuation\">,</span><span class=\"token number\">5</span><span class=\"token punctuation\">]</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">succ</span> <span class=\"token char string\">'B'</span>  \n<span class=\"token char string\">'C'</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Bounded</strong>的成员都有一个上限和下限。</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">minBound</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Int</span>  \n<span class=\"token operator\">-</span><span class=\"token number\">2147483648</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">maxBound</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Char</span>  \n<span class=\"token char string\">'\\1114111'</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">maxBound</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Bool</span>  \n<span class=\"token constant\">True</span>  \n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">minBound</span> <span class=\"token operator\">::</span> <span class=\"token constant\">Bool</span>  \n<span class=\"token constant\">False</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p><code class=\"language-text\">minBound</code>和<code class=\"language-text\">maxBound</code>函数很有趣，它们的类型都是<code class=\"language-text\">(Bounded a) => a</code>。可以说，它们都是多态常量。</p>\n<p>如果其中的项都属于<code class=\"language-text\">Bounded</code>类型类，那么该Tuple也属于<code class=\"language-text\">Bounded</code></p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token builtin\">maxBound</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Bool</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Int</span><span class=\"token punctuation\">,</span> <span class=\"token constant\">Char</span><span class=\"token punctuation\">)</span>  \n<span class=\"token punctuation\">(</span><span class=\"token constant\">True</span><span class=\"token punctuation\">,</span><span class=\"token number\">2147483647</span><span class=\"token punctuation\">,</span><span class=\"token char string\">'\\1114111'</span><span class=\"token punctuation\">)</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p><strong>Num</strong>是表示数字的类型类，它的成员类型都具有数字的特征。检查一个数字的类型：</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span><span class=\"token hvariable\">t</span> <span class=\"token number\">20</span>  \n<span class=\"token number\">20</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Num</span> <span class=\"token hvariable\">t</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token hvariable\">t</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>看样子所有的数字都是多态常量，它可以作为所有<code class=\"language-text\">Num</code>类型类中的成员类型。以上便是<code class=\"language-text\">Num</code>类型类中包含的所有类型，检测<code class=\"language-text\">*</code>运算符的类型，可以发现它可以处理一切的数字：</p>\n<div class=\"gatsby-highlight\" data-language=\"hs\"><pre class=\"language-hs\"><code class=\"language-hs\"><span class=\"token punctuation\">{</span><span class=\"token punctuation\">{</span>\n<span class=\"token hvariable\">ghci</span><span class=\"token operator\">></span> <span class=\"token operator\">:</span><span class=\"token hvariable\">t</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span>  \n<span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">::</span> <span class=\"token punctuation\">(</span><span class=\"token constant\">Num</span> <span class=\"token hvariable\">a</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span> <span class=\"token operator\">-></span> <span class=\"token hvariable\">a</span>  \n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">}</span></code></pre></div>\n<p>它只取两个相同类型的参数。所以<code class=\"language-text\">(5 :: Int) * (6 :: Integer)</code>会引发一个类型错误，而<code class=\"language-text\">5 * (6 :: Integer)</code>就不会有问题。</p>\n<p>类型只有亲近<code class=\"language-text\">Show</code>和<code class=\"language-text\">Eq</code>，才可以加入<code class=\"language-text\">Num</code>。</p>\n<p><strong>Integral</strong>同样是表示数字的类型类。Num包含所有的数字：实数和整数。而Integral仅包含整数，其中的成员类型有Int和Integer。</p>\n<p><strong>Floating</strong>仅包含浮点类型：Float和Double。</p>\n<p>有个函数在处理数字时会非常有用，它便是<code class=\"language-text\">fromIntegral</code>。其类型声明为：<code class=\"language-text\">fromIntegral :: (Num b, Integral a) => a -> b</code>。从中可以看出，它取一个整数做参数并返回一个更加通用的数字，这在同时处理整数和浮点时会尤为有用。举例来说，<code class=\"language-text\">length</code>函数的类型声明为：<code class=\"language-text\">length :: [a] -> Int</code>，而非更通用的形式，如<code class=\"language-text\">(Num b) => length :: [a] -> b</code>。这应该时历史原因吧，反正我觉得挺蠢。如果取了一个List长度的值再给它加3.2就会报错，因为这是将浮点数和整数相加。面对这种情况，我们就用<code class=\"language-text\">fromIntegral (length [1,2,3,4]) + 3.2</code>来解决。</p>\n<p>注意到，<code class=\"language-text\">fromIntegral</code>的类型声明中用到了多个类型约束。如你所见，只要将多个类型约束放到括号里用逗号隔开即可。</p>","excerpt":"types-and-type-classes 相信类型 [^img/cow.png] 在前面我们谈到Haskell是静态类型的，在编译时每个表达式的类型都已明确，这就提高了代码的安全性。若代码中让布尔值与数字相除，就不会通过编译。这样的好处就是与其让程序在运行时崩溃，不如在编译时捕获可能的错误。Haskell中万物皆有类型，因此在执行编译之时编译器可以大有所为。 与Java和Pascal不同，haskell支持类型推导。写下一个数字，你就没必要另告诉haskell…","fields":{"slug":"/blog/2021/08/21/03-types-and-typeclasses.html","date":"August 20, 2021"},"frontmatter":{"title":"03-types and type classes","img":"./img/2013-06-12.jpeg","author":["Sylvenas"],"categories":"Haskell"}}},"pageContext":{"slug":"/blog/2021/08/21/03-types-and-typeclasses.html"}},"staticQueryHashes":[]}