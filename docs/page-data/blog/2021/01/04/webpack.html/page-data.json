{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/2021/01/04/webpack.html","result":{"data":{"markdownRemark":{"html":"<h3>webpack的打包原理</h3>\n<ul>\n<li>识别入口文件</li>\n<li>通过逐层识别模块依赖(Commonjs、amd或者es6的import，webpack都会对其进行分析，来获取代码的依赖)</li>\n<li>webpack做的就是分析代码，转换代码，编译代码，输出代码</li>\n<li>最终形成打包后的代码</li>\n</ul>\n<h3>webpack 中 loader 和 plugin 的区别是什么</h3>\n<ul>\n<li>\n<p>loader，它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。</p>\n<ul>\n<li>处理一个文件可以使用多个loader，loader的执行顺序和配置中的顺序是相反的，即最后一个loader最先执行，第一个loader最后执行</li>\n<li>第一个执行的loader接收源文件内容作为参数，其它loader接收前一个执行的loader的返回值作为参数，最后执行的loader会返回此模块的JavaScript源码</li>\n</ul>\n</li>\n<li>\n<p>plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务</p>\n</li>\n</ul>\n<blockquote>\n<p>loader 处理单个文件，比如无法同时处理a.css 和b.css,然后去重;但是plugin可以</p>\n</blockquote>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/10162014557/69f2/dff9/4cbc/78eceaf8ed6e4bc42ba1841b4f7afb32.png\" alt=\"loader &#x26; plugin\"></p>\n<h3>HRM hot module replacement</h3>\n<p>首先我们先明确几个开发阶段的问题，并作出简答，后续会逐步实现/解决这几个问题</p>\n<ul>\n<li>\n<p>1.浏览器请求的代码 (<code class=\"language-text\">http://localhost:3000/static/js/main.js</code>) 是从哪里来的？<br>\n必定存在一个静态资源服务器可以为我们提供这些 js,css 等文件，我们称之为 server side</p>\n</li>\n<li>\n<p>2.可是我们在本地磁盘并没有见到这些打包过后的 js，css 啊，他们在哪里？\nwebpack 通过 <a href=\"https://www.npmjs.com/package/memfs\">memfs</a> 库把打包之后的文件，写入了内存中，然后我们的静态资源服务器，同样借助 memfs 从内存中读取文件，并返回给浏览器</p>\n</li>\n<li>\n<p>3.当我们修改了代码之后，怎么做到实时编译的呢？\nwebpack 提供了 watch 机制，使用 <a href=\"https://www.npmjs.com/package/chokidar\">chokidar</a> 库监听本地文件变化，然后重新打包</p>\n</li>\n<li>\n<p>4.browser 怎么知道代码已经被重新编译了呢？\n所以client 和 server side 之间必定存在一种通讯机制，轮询？no，no，no! websocket 走起！在 webpack rebuild done 之后发消息通知 browser 有新的代码了，然后 brower 主动拉取新的代码</p>\n</li>\n<li>\n<p>5.browser 也要建立 socket 通信，还要能拉取代码？可是我们自己写的代码里面怎么可能有这种逻辑？\n所以我们在启动 server 的时候，必定往打包的代码里面夹带了私货，也就是修改了 webapckConfig.entry，加入了建立 socket 链接，拉取新代码，并执行等相关逻辑的代码，我们称之为 client side</p>\n</li>\n<li>\n<p>6.browser 怎么知道拉取那个代码？怎么知道那些模块变更了，都拉取？那岂不是和直接刷新浏览器一样了，幸运的是<code class=\"language-text\">webpack.HotModuleReplacementPlugin</code>,会帮助我们计算好每次更新了那些模块(xxxxxxxx(hash).hot-update.json)，以及更新的代码(module.xxxxxxxx(hash).hot-update.js)，我们只要在 browser 主动拉取即可</p>\n</li>\n<li>\n<p>6.browser 拉取新的“已修改部分”代码之后，执行该部分代码，不久可以实现了HRM了么！</p>\n</li>\n</ul>","excerpt":"webpack的打包原理 识别入口文件 通过逐层识别模块依赖(Commonjs、amd或者es6的import，webpack都会对其进行分析，来获取代码的依赖) webpack做的就是分析代码，转换代码，编译代码，输出代码 最终形成打包后的代码 webpack 中 loader 和 plugin 的区别是什么 loader，它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。 处理一个文件可以使用多个loader，loader…","fields":{"slug":"/blog/2021/01/04/webpack.html","date":"January 03, 2021"},"frontmatter":{"title":"webpack","img":"./img/2015-05-11.jpeg","author":["Sylvenas"],"categories":"codes"}}},"pageContext":{"slug":"/blog/2021/01/04/webpack.html"}},"staticQueryHashes":[]}