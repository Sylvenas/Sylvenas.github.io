{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/2021/01/04/webpack.html","result":{"data":{"markdownRemark":{"html":"<h3>webpack的打包原理</h3>\n<ul>\n<li>识别入口文件</li>\n<li>通过逐层识别模块依赖(Commonjs、amd或者es6的import，webpack都会对其进行分析，来获取代码的依赖)</li>\n<li>webpack做的就是分析代码，转换代码，编译代码，输出代码</li>\n<li>最终形成打包后的代码</li>\n</ul>\n<h3>webpack 中 loader 和 plugin 的区别是什么</h3>\n<ul>\n<li>\n<p>loader，它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。</p>\n<ul>\n<li>处理一个文件可以使用多个loader，loader的执行顺序和配置中的顺序是相反的，即最后一个loader最先执行，第一个loader最后执行</li>\n<li>第一个执行的loader接收源文件内容作为参数，其它loader接收前一个执行的loader的返回值作为参数，最后执行的loader会返回此模块的JavaScript源码</li>\n</ul>\n</li>\n<li>\n<p>plugin是一个扩展器，它丰富了webpack本身，针对是loader结束后，webpack打包的整个过程，它并不直接操作文件，而是基于事件机制工作，会监听webpack打包过程中的某些节点，执行广泛的任务</p>\n</li>\n</ul>\n<blockquote>\n<p>loader 处理单个文件，比如无法同时处理a.css 和b.css,然后去重;但是plugin可以</p>\n</blockquote>\n<p><img src=\"https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/10162014557/69f2/dff9/4cbc/78eceaf8ed6e4bc42ba1841b4f7afb32.png\" alt=\"loader &#x26; plugin\"></p>","excerpt":"webpack的打包原理 识别入口文件 通过逐层识别模块依赖(Commonjs、amd或者es6的import，webpack都会对其进行分析，来获取代码的依赖) webpack做的就是分析代码，转换代码，编译代码，输出代码 最终形成打包后的代码 webpack 中 loader 和 plugin 的区别是什么 loader，它是一个转换器，将A文件进行编译成B文件，比如：将A.less转换为A.css，单纯的文件转换过程。 处理一个文件可以使用多个loader，loader…","fields":{"slug":"/blog/2021/01/04/webpack.html","date":"January 03, 2021"},"frontmatter":{"title":"webpack","img":"./img/2015-05-11.jpeg","author":["Sylvenas"],"categories":"codes"}}},"pageContext":{"slug":"/blog/2021/01/04/webpack.html"}},"staticQueryHashes":[]}