{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/2014/04/03/js-natives.html","result":{"data":{"markdownRemark":{"html":"<p>JavaScript有很多个内置对象，像是String,Number这类，我们深入了解一下内置对象，下面列出JS中常见的内置对象。</p>\n<ul>\n<li>String</li>\n<li>Boolean</li>\n<li>Number</li>\n<li>Object</li>\n<li>Function</li>\n<li>Array</li>\n<li>Date</li>\n<li>Error</li>\n<li>RegExp</li>\n<li>Symbol   // ES6</li>\n</ul>\n<p>如果在浏览器中,还有各类的HTMLDomElement,ES6中也有许多新的内置对象。</p>\n<p>这些内置对象怎么这么像函数呢？其实你可以把他们理解为构造函数。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">var</span> s <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">'I am a String'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n<span class=\"token keyword\">typeof</span> s<span class=\"token punctuation\">;</span>              <span class=\"token comment\">//=> 'object'</span>\r\ns <span class=\"token keyword\">instanceof</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//=> true</span></code></pre></div>\n<p>我们使用之前用过<code class=\"language-text\">typeof</code>检查一下，发现<code class=\"language-text\">s</code>是一个<code class=\"language-text\">object</code>,可以认为内置对象也是<code class=\"language-text\">Object</code>的子类型，<code class=\"language-text\">typeof</code>只能显示值的类型，因此只能显示<code class=\"language-text\">object</code>,<code class=\"language-text\">function</code>,<code class=\"language-text\">symbol</code>等。</p>\n<h3>[[Class]]属性</h3>\n<p>既然<code class=\"language-text\">typeof</code>无能为力，那如何确定其他内置对象的类型呢。这些内置对象都有一个内置的隐藏属性<code class=\"language-text\">[[Class]]</code>,需要用<code class=\"language-text\">Object.prototype.toString()</code>方法来判断。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">// \"[object Array]\"</span></code></pre></div>\n<p>返回值中的'Array'就是<code class=\"language-text\">[[Class]]</code>的属性了，但是这个方法一样有些奇怪的地方。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">undefined</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>         <span class=\"token comment\">//=> \"[object Undefined]\"</span>\r\n<span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>              <span class=\"token comment\">//=> \"[object Null ]\"</span>\r\n<span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                 <span class=\"token comment\">//=> \"[object Number]\"</span>\r\n<span class=\"token class-name\">Object</span><span class=\"token punctuation\">.</span>prototype<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">.</span><span class=\"token function\">call</span><span class=\"token punctuation\">(</span><span class=\"token string\">'build-in type'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//=> \"[object String]\"</span></code></pre></div>\n<p><code class=\"language-text\">WTF</code>...JavaScript这个语言中检测方法怎么都不按照基本法则啊！<code class=\"language-text\">1</code>和<code class=\"language-text\">'build-in type'</code>明明是内置类型，怎么也成<code class=\"language-text\">object</code>了？？那是因为内置类型会被装箱(Boxing Wrappers),那么什么是装箱呢？</p>\n<h3>Boxing Wrappers</h3>\n<p>前面我们看到在检查内置类型的时候，它们变成了对象，这种行为就叫装箱。那装箱有什么用呢？我猜你可能使用过这个功能但全然没注意过这个问题。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token string\">'abc'</span><span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">;</span>          <span class=\"token comment\">// 3</span>\r\n<span class=\"token string\">'lower'</span><span class=\"token punctuation\">.</span><span class=\"token function\">toUpperCase</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 'LOWER'</span></code></pre></div>\n<p>我们要知道JS中的所有内置方法都保存在某个<code class=\"language-text\">构造函数的prototype对象</code>中，但是像 <code class=\"language-text\">'abc'</code>,<code class=\"language-text\">1</code> 这种内置类型并不是对象，没有属性也没有方法，自然也没有<code class=\"language-text\">[[proto]](__proto__)</code>，不能依靠原型链向上调用方法，因此在执行某些方法时，JS会把内置类型装箱成对象，让其获取调用原型链上的方法的能力。</p>\n<p>看到这里你一定想到了一个好主意，就是如果你须要在一个<code class=\"language-text\">for</code>循环中 使用<code class=\"language-text\">'abc'.length</code>，那JS不是每次都要进行装箱，你可以预先构造一个<code class=\"language-text\">new String('abc')</code> 对象，这样是不是可以加速运行代码了？有趣的问题，你可千万不要这么做，因为这个问题早期的开发者早就想到了，因此他们已经做了优化，而如果你想来个预优化处理很可能适得其反。所以建议你不要使用构造函数创建一个内置类型对应的内置对象，而是让JS自己去装箱。</p>\n<h3>Unboxing</h3>\n<p>既然能装箱，必然也有拆箱的方法，那就是调用<code class=\"language-text\">valueOf()</code>这个函数，可以将一个内置对象的primitive值取出。</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">valueOf</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">'abc'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 'abc'</span></code></pre></div>\n<p>这是一种显式的拆箱方法。</p>","excerpt":"JavaScript有很多个内置对象，像是String,Number这类，我们深入了解一下内置对象，下面列出JS中常见的内置对象。 String Boolean Number Object Function Array Date Error RegExp Symbol   // ES6 如果在浏览器中,还有各类的HTMLDomElement,ES…","fields":{"slug":"/blog/2014/04/03/js-natives.html","date":"April 02, 2014"},"frontmatter":{"title":"JS内置对象理解","img":"./img/2014-04-03.jpg","author":["sylvenas"],"categories":"JavaScript"}}},"pageContext":{"slug":"/blog/2014/04/03/js-natives.html"}},"staticQueryHashes":[]}