{"componentChunkName":"component---src-pages-categories-index-js","path":"/categories/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"id":"649e6d4c-35a2-5fa9-b146-38f389987fb9","excerpt":"简介 赵祥涛 15381048021 2013/07，山东科技大学，地理信息系统专业 sylvenas@outlook.com GitHub Blog Keyword：Documented, TDD, Open-Source-Community, Speaker, Functional Programming, Async Programming, Function Compose, React/Redux, Node.js... 工作经历 2017.04-Now…","fields":{"slug":"/blog/2021/07/23/about-me.html","date":"2021-07-22T16:00:00.000Z"},"frontmatter":{"title":"个人简历","author":["Sylvenas"],"categories":"resume","secert":true}}},{"node":{"id":"1effa0d9-c6be-56ce-b595-4a25ba8b349e","excerpt":"Shell VS GUI 如今的计算机有着多种多样的交互接口让我们可以进行指令的的输入，从炫酷的图像用户界面（graphical user interface，GUI），语音输入甚至是 AR/VR 都已经无处不在。 这些交互接口可以覆盖 80% 的使用场景，但是它们也从根本上限制了您的操作方式——你不能点击一个不存在的按钮或者是用语音输入一个还没有被录入的指令。 为了充分利用计算机的能力，我们不得不回到最根本的方式，使用文字接口：Shell shell…","fields":{"slug":"/blog/2021/06/02/shell-intro.html","date":"2021-06-01T16:00:00.000Z"},"frontmatter":{"title":"shell intro","author":["Sylvenas"],"categories":"OS","secert":null}}},{"node":{"id":"a3cd46b4-fe39-52bf-9755-40840602f3a3","excerpt":"React Hooks 主要用来解决两个问题， 组件之间复用逻辑\n社区中普遍采用的 High-Order-Components和render props,然而这两种方案分别会带来 “wrapper hell” 和代码难以理解/维护的问题。 wrapper hell…","fields":{"slug":"/blog/2021/03/30/react-hooks.html","date":"2021-03-29T16:00:00.000Z"},"frontmatter":{"title":"React Hooks 原理及实现","author":["Sylvenas"],"categories":"React","secert":null}}},{"node":{"id":"34837a2f-2e5d-5148-8013-af258682f45b","excerpt":"前言 提起 npm，大家第一个想到的应该就是  了，但是  之后生成的  大家有观察过吗？ 文件的作用大家知道吗？除了  和 ，其他的依赖有什么作用呢？接下来，本文将针对 npm 中的你可能忽略的细节和大家分享一些经验 。 npm 安装机制  和  同时依赖 ， 这个包会被安装在哪里呢？ 的版本相同和版本不同时安装会有什么差异呢？ 中包的前后顺序对于安装时有什么影响吗？这些问题平时大家可能没有注意过，今天我们就来一起研究一下吧。 A 和 B 同时依赖 C…","fields":{"slug":"/blog/2021/03/03/npm-package.html","date":"2021-03-02T16:00:00.000Z"},"frontmatter":{"title":"npm package依赖管理","author":["Sylvenas"],"categories":"Node.js","secert":null}}},{"node":{"id":"1d8f2ee2-63c9-5674-b9f9-c9de6ebe768a","excerpt":"koa 是由 Express 原班人马打造的，致力于成为一个更小、更富有表现力、更健壮的 Web 框架。使用 koa 编写 web 应用，通过组合不同的 ，可以免除重复繁琐的回调函数嵌套，并极大地提升错误处理的效率。koa 不在内核方法中绑定任何中间件，它仅仅提供了一个轻量优雅的函数库，使得编写 Web 应用变得得心应手。 特点 轻量、无捆绑 中间件架构 通过不同的  以及  替代了回调 增强的错误处理 简单易用的 api 简单使用 Koa 对 node…","fields":{"slug":"/blog/2021/02/06/koa.html","date":"2021-02-05T16:00:00.000Z"},"frontmatter":{"title":"Koa实现原理分析","author":["Sylvenas"],"categories":"Node.js","secert":null}}},{"node":{"id":"f1ffec6e-4c4b-5548-8f26-54e47b61e8ff","excerpt":"…","fields":{"slug":"/blog/2020/05/14/被讨厌的勇气.html","date":"2020-05-13T16:00:00.000Z"},"frontmatter":{"title":"被讨厌的勇气","author":["sylvenas"],"categories":"Life","secert":null}}},{"node":{"id":"f467740e-b1f6-5db7-a96c-6c88bacd73ec","excerpt":"自然变换 所谓自然变换也也就是变化包裹值的容器盒子：,举个简单的例子，把Either转换为Task: 同构 前面我们介绍过Task 是一种Lazy Promise的概念，那么是否可以将Task转为promise呢？答案是肯定的！ 同样的，我们也可以把Promise转换为Task **Note：**我们没办法实现,因为我们不能把一个异步的逻辑转换为同步的过程，这个是不合理的，因为异步的结果，必须要等到异步call back的时候才能拿到。 定律 nth(fx).map(f) == nt(fx…","fields":{"slug":"/blog/2020/05/02/自然变换.html","date":"2020-05-01T16:00:00.000Z"},"frontmatter":{"title":"自然变换 - Natural Transformation","author":["sylvenas"],"categories":"Monad","secert":null}}},{"node":{"id":"22aa6d6e-5334-51b4-9ff5-6d9e75b503e2","excerpt":"Array insideOut 假如我们现在有一个数字的数组，我们要把这些数字转换为对应的26个英文字母，但是这个转换肯能会失败，因为并不是所有的数字都是可以转换的，所以这种情况下我们可以使用Either来处理转换成功和转换失败： 下面继续使用函数: 看上去问题不大！但是感觉怪怪的啊！或许我们理想的结果是? 类似的例子: 现在回头看一下，我们如何把转换为呢？实际上这是一个的过程，也就是把,从Array中解救出来，然后再集合放到Right中。 这个过程我们可以借助Array.reduce…","fields":{"slug":"/blog/2020/04/25/遍历与队列.html","date":"2020-04-24T16:00:00.000Z"},"frontmatter":{"title":"遍历与队列 - Traversable","author":["sylvenas"],"categories":"Monad","secert":null}}},{"node":{"id":"aa6786a9-ba92-52e3-9136-518bf39d52a9","excerpt":"积木游戏 说出来你可能不信，我只花了十分钟的时间就教会三岁的小孩什么是半群,ahhhhh.jpg…","fields":{"slug":"/blog/2020/03/02/加法是自然之道.html","date":"2020-03-01T16:00:00.000Z"},"frontmatter":{"title":"加法是自然之道 - Monoid","author":["Sylvenas"],"categories":"Monad","secert":null}}},{"node":{"id":"5a88c118-bdf4-58ca-8cfb-e6e6c77d79dc","excerpt":"前面两篇分别介绍了 Functor 和 Applicative 的概念和实际应用，并列举了几个具体的例子，说明了 Functor 和 Applicative 的实际用途，比如：使用  来处理无处不在的  和创建可组合的 ；使用 Applicative 来做高度灵活高度可拓展的表单校验；相信读者应该已经牢牢掌握了 Functor 的核心：map-应用一个函数到包裹的值，Applicative的核心：ap…","fields":{"slug":"/blog/2020/02/12/俄罗斯套娃娃.html","date":"2020-02-11T16:00:00.000Z"},"frontmatter":{"title":"俄罗斯套娃娃 - Monad","author":["Sylvenas"],"categories":"Monad","secert":null}}},{"node":{"id":"56321180-4036-5dbc-9db6-7757b8a20faf","excerpt":"…","fields":{"slug":"/blog/2020/02/07/记念刘和珍君.html","date":"2020-02-06T16:00:00.000Z"},"frontmatter":{"title":"纪念刘和珍君","author":["sylvenas"],"categories":"Life","secert":null}}},{"node":{"id":"2b06e02d-9faf-51df-b754-fea2c83c8347","excerpt":"上一章中介绍了  的概念，简单来说，就是把一个 “value” 填装进 “Box” 中，继而可以使用  方法映射变换 Box 中的值：。本章我们在继续在  的基础上继续扩展其他更强大的理念，从纯函数与副作用的概念及用途作为承上启下的开端，继续巩固  的概念以及接下来将要介绍的  的引子。 函数式编程中纯函数是一个及其重要的概念，甚至可以说是函数组合的基础。你可能已经听过类似的言论：“纯函数是引用透明( Referential Transparency )的”，“纯函数是无副作用( Side…","fields":{"slug":"/blog/2020/02/05/应用函子.html","date":"2020-02-04T16:00:00.000Z"},"frontmatter":{"title":"应用函子 - Applicative","author":["Sylvenas"],"categories":"Monad","secert":null}}},{"node":{"id":"557468d7-c562-571f-b534-abf39dbfc341","excerpt":"…","fields":{"slug":"/blog/2020/02/01/动物庄园.html","date":"2020-01-31T16:00:00.000Z"},"frontmatter":{"title":"动物庄园","author":["sylvenas"],"categories":"Life","secert":null}}},{"node":{"id":"3fb4bb59-e132-5cf4-b7fa-68ac8e6386bf","excerpt":"副作用 程序的可观察，而不是操作了一番然后睡觉去了 上篇文章中引入范畴学中的概念，核心内容就是把一个值放入到一个中，然后不停的通过函数来映射变换其中的值，而这就是一个最简单的,但是管他呢，我们还是叫它Box吧(多么简单形象)！ 然后还举了个Either的例子，来说明Box理念在代码中实际用途，接下来介绍另外两个常用的:, Schrödinger's Maybe 薛定谔的猫 I call it my billion-dollar mistake. It was the invention of…","fields":{"slug":"/blog/2020/01/30/薛定谔的Maybe.html","date":"2020-01-29T16:00:00.000Z"},"frontmatter":{"title":"薛定谔的 Maybe - IO","author":["Sylvenas"],"categories":"Monad","secert":null}}},{"node":{"id":"40c52eea-cda8-518a-b8a7-3237662b2d7b","excerpt":"应用场景 现在前端主流的技术方案都是服务端渲染，那就面临着一个问题，Node.js需要承担接口转发的任务，所以原来的客户端渲染的请求的路线(brower -> server),需要调整为(Node.js -> server);看上去没有什么本质的区别，无非是原来是又浏览器发起请求，现在改为Node.js发起请求。 但是高并发呢？举个例子，假如有1000000个请求，原来从browser请求到server,server端如果没有做限流处理，那么部分请求就会一直处于状态；但是100000…","fields":{"slug":"/blog/2020/01/18/abort-controller.html","date":"2020-01-17T16:00:00.000Z"},"frontmatter":{"title":"Abort-Controller","author":["Sylvenas"],"categories":"http","secert":null}}},{"node":{"id":"35092166-feff-5944-be06-d6cc0bc50586","excerpt":"catch-react-error English | 简体中文 Why we create catch-react-error Introduction This project make it easy to protect your react source code。 We combine decorators and React Error Boundaries together. The React Error Boundaries don't support the Server…","fields":{"slug":"/blog/2020/01/02/catch-react-error.html","date":"2020-01-01T16:00:00.000Z"},"frontmatter":{"title":"Catch React Error","author":["Sylvenas"],"categories":"React","secert":null}}},{"node":{"id":"1cde8795-a13a-53f4-b50b-21a41e8fa92b","excerpt":"基本用法 Node.js默认单进程运行，对于32位系统最高可使用内存，对于64位最高可以使用1GB内存。对于多核CPU的计算机来说，这样做效率很低，因为只有一个核在运行，其他核都在闲置。模块就是为了解决这个问题而提出的。 模块允许设立一个主进程和若干个worker进程，由主进程监控和协调worker进程的运行。worker之间采用进程间通讯交换消息，模块内置一个负载均衡器，采用算法协调各个worker进程之间的负载。运行时，所有新建立的链接都由主进程完成，然后主进程再把TCP…","fields":{"slug":"/blog/2019/11/12/node-cluster.html","date":"2019-11-11T16:00:00.000Z"},"frontmatter":{"title":"Node.js 集群","author":["Sylvenas"],"categories":"Node.js","secert":null}}},{"node":{"id":"7baf0340-5416-5644-9143-146a61215dc9","excerpt":"babel 简介 一句话阐述什么是 babel:\nbabel 是一个主要用于将 ES2015+版本的代码编译成向下兼容(比如 ES5/ES3)js 版本的编译器。 babel 编译的核心流程是： 先把代码解析为 AST 语法树， 遍历 AST 语法树并执行操作， 最后根据规则生成代码。 流程不复杂，复杂的是如何操作 AST 语法树，以及如何编写 babel 的插件。网上有很多帖子在讲如何编写 babel 插件，但是讲的都比较浅显，看过之后并不能真正意义上去编写 babel…","fields":{"slug":"/blog/2019/09/13/babel-plugin.html","date":"2019-09-12T16:00:00.000Z"},"frontmatter":{"title":"babel plugin","author":["Sylvenas"],"categories":"bundlers","secert":null}}},{"node":{"id":"54b52d31-7b5d-5f37-b6fd-15e224197e09","excerpt":"函数式编程（Functional Programming）这一理念不论是在前端领域还是后端领域，都逐渐热门起来，现在不大量使用函数式编程技术的大型应用程序已经很罕见了，比如前端流行的 React（核心思路数据即视图），Vue3.0 的 Composition API ，Redux ，Lodash 等等前端框架和库，无不充斥着函数式的思维，实际上函数式编程绝不是最近几年才被创造的编程范式，而是在计算机科学的开始，Alonzo Church 在 20 世纪 3…","fields":{"slug":"/blog/2019/09/10/黑珍珠号的诅咒.html","date":"2019-09-09T16:00:00.000Z"},"frontmatter":{"title":"黑珍珠号的诅咒 - Functor","author":["Sylvenas"],"categories":"Monad","secert":null}}},{"node":{"id":"eec1ec84-72ed-51d1-8484-9f49ecdecaf7","excerpt":"Nginx 是一个遵循主从架构的 Web 服务器，可以用作反向代理、负载均衡器、邮件代理和 HTTP 缓存。\n哇！复杂的术语和混乱的定义，里面充斥着大量令人困惑的词语，对吧？不用担心，这篇文章可以帮大家先了解 Nginx 的基本架构和术语，然后我们将安装并创建 Nginx 配置。 Nginx 是一个神奇的 Web 服务器。 简单来说，Web 服务器就像个中间人。比如你想访问 dev.to，输入地址 ，你的浏览器就会找出 的 Web…","fields":{"slug":"/blog/2019/06/23/nginx.html","date":"2019-06-22T16:00:00.000Z"},"frontmatter":{"title":"NGINX 基础知识","author":["sylvenas"],"categories":"http","secert":null}}},{"node":{"id":"6a4c346a-5f11-54f3-a109-cc9165397dbe","excerpt":"套接字和流 套接字指的是一个通讯终端，而网络套接字指的是在不同的计算机上运行的两个应用程序之间进行通讯所使用的终端。在套接字之间流通的数据就是我们所熟知的流。流中的数据可以以二进制的形式在Buffer中传输，也可以作为Unicode字符串来传递。两种数据类型都被称为来传输。有一种特殊的数据封包，即(FIN…","fields":{"slug":"/blog/2019/06/11/node-http.html","date":"2019-06-10T16:00:00.000Z"},"frontmatter":{"title":"Node.js与网络","author":["Sylvenas"],"categories":"Node.js","secert":null}}},{"node":{"id":"ef38da64-b4e9-5e3c-929c-b5de9d56197d","excerpt":"rem布局 lib-flexible 假设设计MM给我们的设计稿尺寸为，那么我们前端拿到设计稿之后要如何动手开始开发呢？经过上面的介绍了移动端开发的基本概念之后，应该有了一些基本的思路，我们可以使用js动态计算rem的方案来实现。 rem是根据html节点的font-size来做计算的 举个例子：假如html元素的font-size为 ,一个元素的宽度设定为;则该元素的实际宽度为：； 换句话说px与rem的一定是成正比关系的。 那么既然设计MM…","fields":{"slug":"/blog/2019/05/27/mobile-css.html","date":"2019-05-26T16:00:00.000Z"},"frontmatter":{"title":"移动端适配方案rem & vh、vw","author":["sylvenas"],"categories":"Moblie","secert":null}}},{"node":{"id":"7fefab2b-ea2a-588e-94cf-7a6ee705b11f","excerpt":"单位 英寸 一般用英寸描述屏幕的物理大小，如电脑显示器的、,手机显示器的,等使用的单位都是英寸。 需要注意的是英寸都是指屏幕对角线的长度 英寸(inch,缩写为in)在荷兰语中本意是指大拇指，一英寸就是普通人拇指指甲底部的宽度。 英寸和厘米的换算规则为： 屏幕比例 只确定了对角线的长度(屏幕英寸)，…","fields":{"slug":"/blog/2019/05/24/mobile.html","date":"2019-05-23T16:00:00.000Z"},"frontmatter":{"title":"移动端开发基础知识","author":["sylvenas"],"categories":"Moblie","secert":null}}},{"node":{"id":"12dfa177-4847-55e9-8ac3-aab82f4bbb17","excerpt":"原文链接 From React Elements to Fiber nodes 从一个最简单 React 组件树开始，一个按钮，一个展示点击按钮数字 + 1 React中的每个组件都有一个UI表示，这个UI可以通过调用一个view或一个从render方法返回。这是ClickCounter组件的模板： React Elements 一旦模板通过JSX编译器编译，就会得到一堆React元素。这是从React组件的render方法返回的，而不是HTML。由于我们不需要使用JSX…","fields":{"slug":"/blog/2019/03/07/react-reconciliation.html","date":"2019-03-06T16:00:00.000Z"},"frontmatter":{"title":"[译+改] React Fiber reconciliation algorithm ","author":["Sylvenas"],"categories":"React","secert":null}}},{"node":{"id":"f777fa06-6cbe-53b8-8fa0-3c8c33a7e461","excerpt":"原文链接 前置知识 Fiber 架构有两个主要的渲染阶段: reconciliation/render commit 在源码中 reconciliation 阶段也被视为 \"render\" 阶段. 在该阶段, React 会遍历整个组件树, 并且进行如下操作: 更新 state 和 props 调用生命周期方法 检索当前组件的子组件 比对新老子组件 计算出需要在 commit 阶段被执行的 DOM 更新 上述所有操作被称为 Fiber 内部工作(work inside Fiber…","fields":{"slug":"/blog/2019/03/04/react-fiber.html","date":"2019-03-03T16:00:00.000Z"},"frontmatter":{"title":"[译+改] React Fiber 中为何以及如何使用链表遍历组件树","author":["Sylvenas"],"categories":"React","secert":null}}},{"node":{"id":"721b2edc-83fc-5e79-8aa1-ac8f29ddc3cb","excerpt":"JavaScript 是如何工作的：内存管理 + 处理常见的 4 种内存泄漏 我们将讨论另外一个越来越被开发人员忽视的主题，原因是应用于日常基础内存管理的程序语言越来越成熟和复杂。我们也将会在 SessionStack 提供一些关于如何处理 JavaScript 内存泄漏的建议，我们需要确认 SessionStack 不会导致内存泄漏，或者不会增加我们集成的 web 应用程序的消耗。 概览 例如，像 C…","fields":{"slug":"/blog/2019/02/05/menory-management.html","date":"2019-02-04T16:00:00.000Z"},"frontmatter":{"title":"How JavaScript Work: 内存管理/垃圾收集/内存泄漏","author":["Sylvenas"],"categories":"JavaScript","secert":null}}},{"node":{"id":"cf0667b5-02a1-597b-adc2-81b03fde2483","excerpt":"浏览器里并不是每一个资源加载都很重要。 为了达到重要的资源先加载，浏览器有试探法，尝试对资源进行权重分配，例如CSS会在脚本和图片之前先加载。 因为浏览器在试探权重分配，所以并不总是分配的很正确，通常因为没有足够的信息，浏览器可能做出错误的决定。 下面介绍如何在现代浏览器中以代码的形式来调整资源加载的优先级。 默认优先级 如前所述，浏览器根据它们的重要程度为不同类型的资源分配不同的相对优先级。 像页面的中的标记将以\"高优先级(High priority)\"(CSS是\"最高优先级(Highest…","fields":{"slug":"/blog/2019/01/12/load-priority.html","date":"2019-01-11T16:00:00.000Z"},"frontmatter":{"title":"前端资源加载优先级","author":["Sylvenas"],"categories":"性能优化","secert":null}}},{"node":{"id":"230021a5-e2ce-5b0d-9ac0-50df7274e1e6","excerpt":"相信大家都知道TCP是一个可靠传输的协议，那它是如何保证可靠的呢？ 为了实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。如不能解决这些问题，也就无从谈起可靠传输。 那么，TCP是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的。 今天，将重点介绍TCP的重传机制、滑动窗口、流量控制、拥塞控制。 重传机制 TCP实现可靠传输的方式之一，是通过序列号与确认应答。 在TCP…","fields":{"slug":"/blog/2018/12/22/tcp.html","date":"2018-12-21T16:00:00.000Z"},"frontmatter":{"title":"TCP 重传、滑动窗口、流量控制、拥塞控制","author":["sylvenas"],"categories":"http","secert":null}}},{"node":{"id":"866e198b-61cc-55bd-b76c-7b58c71dc3de","excerpt":"所谓(半群)，其实就是含有concat方法的数据类型，典型的如字符串和数组，看代码： 实际上，我们还可以发现一个规律是可以随意的合并操作的，什么意思呢？ 无论前后的顺序如何，或者无论怎么组合，得到的结果是一致的。\n完全类似于数据的加法运算： 但是我们却不能直接使用这样的代码，因为number并没有实现方法，但是我们可以自己简单实现一个Sum的。 现在就可以直接这样使用Sum了： Sum的使用场景不是很多，仅仅是为了学习而建立的，下面看几个使用场景比较多的 All: First: Max…","fields":{"slug":"/blog/2018/12/13/FP18-Semigroup.html","date":"2018-12-12T16:00:00.000Z"},"frontmatter":{"title":"FP18：Semigroup","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"da6e1b06-a899-5199-a23d-3869db1c538f","excerpt":"…","fields":{"slug":"/blog/2018/12/11/FP17-Transform-Naturally.html","date":"2018-12-10T16:00:00.000Z"},"frontmatter":{"title":"FP17：Transform Naturally","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"bc5dcd39-9271-58d2-8545-a19a340b4289","excerpt":"JavaScript 如何工作系列: 引擎、运行时、调用栈概述 JavaScript 如何工作：在 V8 引擎里 5 个优化代码的技巧 JavaScript 工作原理：内存管理 + 处理常见的4种内存泄漏 JavaScript 如何工作的: 事件循环和异步编程的崛起 + 5 个关于如何使用 async/await 编写更好的技巧 Event Loop Event Loop in Node JavaScript 是如何工作的：深入剖析 WebSockets 和拥有 SSE 技术 的 HTTP/…","fields":{"slug":"/blog/2018/11/12/overview-of-the-engine-the-runtime-the-call-stack.html","date":"2018-11-11T16:00:00.000Z"},"frontmatter":{"title":"How JavaScript Work: 引擎、运行时、调用栈概述","author":["Sylvenas"],"categories":"JavaScript","secert":null}}},{"node":{"id":"a6fe612c-abc3-508c-94e7-5ad05cbdd056","excerpt":"Applicative Functor 应用 applicative functor 考虑到其函数式的出身，applicative functor 这个名称堪称简单明了。函数式程序员最为人诟病的一点就是，总喜欢搞一些稀奇古怪的命名，比如  或者 。诚然，此类名称出现在数学实验室是再自然不过的，但是放在其他任何语境下，这些概念就都像是扮作达斯维达去汽车餐馆搞怪的人。 无论如何，applicative…","fields":{"slug":"/blog/2018/11/07/FB16-Applicative-Functor.html","date":"2018-11-06T16:00:00.000Z"},"frontmatter":{"title":"FP16：Applicative Functor","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"bd7e62fa-fd62-5cd8-8a0b-8fc58694d2aa","excerpt":"Node.js是基于Chrome浏览器的V8引擎构建的，也就说明它的模型与浏览器是类似的。我们的JavaScript会运行在单个进程的单个线程上。这样有一个好处： 状态单一 没有锁 不需要线程间同步 减少系统上下文的切换 有效提高单核CPU的使用率 但是的单进程单线程并不是完美的结构，现如今CPU基本上都是多核的。真正的服务器往往有好几个CPU（像我们的线上物理机有12个核），所以，这就将抛出Node.js实际应用中的第一个问题：“如何充分利用多核CPU服务器？” 另外，由于Node.js…","fields":{"slug":"/blog/2018/10/22/node-process-stability.html","date":"2018-10-21T16:00:00.000Z"},"frontmatter":{"title":"Node.js 与多核CPU","author":["Sylvenas"],"categories":"Node.js","secert":null}}},{"node":{"id":"84b7ec1e-372d-5bd8-9fbb-fb80ecae937d","excerpt":"在传统的大型css代码库中存在一下几个问题： 全局命名空间 - css中的所有的选择器都是全局的。无论怎样使用命名空间或者BEM命名法组织css代码，最终都会污染全局命名空间，从长远来看，代码的可维护性会越来越差 依赖 - 现在往往使用css预处理器将css代码分割成子模块，但最终为浏览器生成的还是一个很大的全局css文件，很难清晰的声明某个特定组件依赖某段特定的css…","fields":{"slug":"/blog/2018/10/08/css-in-react.html","date":"2018-10-07T16:00:00.000Z"},"frontmatter":{"title":"css in react","author":["Sylvenas"],"categories":"React","secert":null}}},{"node":{"id":"596fad82-a617-5e46-8c97-9654656e59ae","excerpt":"React社区对的模式达成了共识，这个模式的主要概念是，不按组件的形式传递子组件，而是定义一个可以从父组件接收参数的函数。 这种模式本质上来说和的目的是一样的，都是为了抽取公共逻辑，不过实现的方式却大不相同，几乎所有的用高阶组件实现的效果，使用的模式也能实现。 这个模式初次看上去比较怪异，甚至有点违背react的思路，不过确是非常的强大 Function as Children 下面通过和高阶组件类似的查询用户的github gists…","fields":{"slug":"/blog/2018/09/20/using-function-as-children.html","date":"2018-09-19T16:00:00.000Z"},"frontmatter":{"title":"react component using function as children","author":["sylvenas"],"categories":"React","secert":null}}},{"node":{"id":"20a02766-fde0-50a7-b0f0-a4dc6b53d6f0","excerpt":"当你在查看React的例子时候，可能已经见过JSX了。但React代码也可以用纯JS代码来编写： 有些人不喜欢将整个标记代码编写为函数调用。这可能是为什么Facebook上的人想出了JSX - 一个。 这就是为什么我们可以重构上面的例子： 这也就是render不能return两个元素(或组件)的原因，因为一个函数绝不可能有两个返回值 在构建过程中Babel会将标记转换为纯JS代码。 React.createElement源码分析 源代码GitHub…","fields":{"slug":"/blog/2018/09/11/react-jsx.html","date":"2018-09-10T16:00:00.000Z"},"frontmatter":{"title":"react jsx","author":["Sylvenas"],"categories":"React","secert":null}}},{"node":{"id":"a5cbff76-becf-54d7-80a3-acee0c306e27","excerpt":"“A monad is just a monoid in the category of endofunctors. What’s the problem?” Monad是非常简单的，但是它的概念却有点让人云里雾里，尤其是网上查询资料博客的时候，一般会从范畴论开始讲解，这是正确的道路，不过可惜的是大部分的JavaScript…","fields":{"slug":"/blog/2018/09/11/FB15-Monad-2.html","date":"2018-09-10T16:00:00.000Z"},"frontmatter":{"title":"FP15：Monad-2","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"5a666869-9731-5a84-ad89-5e2c4028a710","excerpt":"pointed functor 在继续后面的内容之前，我得向你坦白一件事：关于我们先前创建的容器类型上的 of 方法，我并没有说出它的全部实情。真实情况是，of 方法不是用来避免使用 new 关键字的，而是用来把值放到默认最小化上下文（default minimal context）中的。是的，of 没有真正地取代构造器——它是一个我们称之为 pointed 的重要接口的一部分。 pointed functor 是实现了 of 方法的 functor…","fields":{"slug":"/blog/2018/09/02/FP14-Monad-1.html","date":"2018-09-01T16:00:00.000Z"},"frontmatter":{"title":"FP14：Monad-1","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"724f01d7-9be3-5986-abdc-900c552c5861","excerpt":"模仿类 多年以来，JavaScript…","fields":{"slug":"/blog/2018/08/24/代理-pattern.html","date":"2018-08-23T16:00:00.000Z"},"frontmatter":{"title":"代理模式","author":["Sylvenas"],"categories":"design pattern","secert":null}}},{"node":{"id":"763f9b65-2edf-5c1f-b929-ff6e1b95dcb0","excerpt":"oop…","fields":{"slug":"/blog/2018/08/24/class-pattern.html","date":"2018-08-23T16:00:00.000Z"},"frontmatter":{"title":"'类'模式","author":["Sylvenas"],"categories":"design pattern","secert":null}}},{"node":{"id":"45816275-389c-5cee-bcdb-1046656f1d2a","excerpt":"Old McDonald Had Effects... 在关于纯函数的的那一章（即第 3 章）里，有一个很奇怪的例子。这个例子中的函数会产生副作用，但是我们通过把它包裹在另一个函数里的方式把它变得看起来像一个纯函数。这里还有一个类似的例子： 要是我们没把包在另一个函数里，它的输出值就是不定的，会随外部环境变化而变化。有了这个结实的包裹函数（wrapper…","fields":{"slug":"/blog/2018/08/08/FP13-IO.html","date":"2018-08-07T16:00:00.000Z"},"frontmatter":{"title":"FP13：IO - keep code pure","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"8e6e5e59-0ef3-50ca-84dc-f5ce5965630f","excerpt":"Left or Right ? Left or Right 说出来可能会让你震惊， 并不十分“纯”。当一个错误抛出的时候，我们没有收到返回值，反而是得到了一个警告！抛错的函数吐出一大堆的 0 和 1 作为盾和矛来攻击我们，简直就像是在反击输入值的入侵而进行的一场电子大作战。有了这个新朋友，我们就能以一种比向输入值宣战好得多的方式来处理错误，那就是返回一条非常礼貌的消息作为回应。我们来看一下： 和略有不同，代表的是两个逻辑分离的Left和Right,他们永远不会同时出现： Left(a…","fields":{"slug":"/blog/2018/08/03/FP12-Either.html","date":"2018-08-02T16:00:00.000Z"},"frontmatter":{"title":"FP12：Either:Left or Right","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"0cf95fe1-93ee-514f-aa43-98fb9a33b063","excerpt":"Schrödinger's Maybe Schrödinger's Maybe 说实话上一章讲解的 functor挺无聊的，通常我们称它为，与函数的作用相同（这里也是有数学上的联系的，我们会在适当时候加以说明）。除此之外，还有另外一种 functor，那就是实现了 map 函数的类似容器的数据类型，这种 functor 在调用 map 的时候能够提供非常有用的行为。现在让我们来定义一个这样的 functor。 Maybe Monad侧重于有效整合null-判断逻辑。Maybe…","fields":{"slug":"/blog/2018/08/02/FP11-Maybe.html","date":"2018-08-01T16:00:00.000Z"},"frontmatter":{"title":"FP11：Schrödinger's Maybe","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"1b7c6612-6e62-5c18-b741-d679bd698534","excerpt":"The Mighty Box functor->box 我们已经知道如何书写函数式的程序了，即通过管道把数据在一系列纯函数间传递的程序。我们也知道了，这些程序就是声明式的行为规范。但是，控制流（control flow）、异常处理（error handling）、异步操作（asynchronous actions）和状态（state）呢？还有更棘手的作用（effects）呢？本章将对上述这些抽象概念赖以建立的基础作一番探究。 首先我们将创建一个容器（Box…","fields":{"slug":"/blog/2018/07/26/FP10-Functor.html","date":"2018-07-25T16:00:00.000Z"},"frontmatter":{"title":"FP10：Functor","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"851addc4-bd7a-5e8a-ac65-3eed6f2b5a0d","excerpt":"本篇文章为摘抄，原作者：王子亭，原文地址：Node.js 错误处理实践 今天我想介绍的是 Node.js…","fields":{"slug":"/blog/2018/07/19/node-error-catch.html","date":"2018-07-18T16:00:00.000Z"},"frontmatter":{"title":"Node.js错误捕获与处理","author":["Sylvenas"],"categories":"Node.js","secert":null}}},{"node":{"id":"3ee9c7f7-b65a-58e9-8acc-7349f9bfda2f","excerpt":"svg-placeholder-loader 配合前面写的,接下来接收到webp-loader传递过来的数据，继续把文件处理成一个svg格式的placeholder。 项目实战 一张原图片在经过，的处理之后，最终导出的图片数据为： 配合实际的React项目(绝不仅限于React项目，同样适用于Vue,Jquery的项目)来用就是：\nwebpack.config.js 配置： Summary 经过上面的学习，webpack loader…","fields":{"slug":"/blog/2018/07/14/svg-placeholder.html","date":"2018-07-13T16:00:00.000Z"},"frontmatter":{"title":"webpack svg placeholder loader","author":["Sylvenas"],"categories":"bundlers","secert":null}}},{"node":{"id":"e449b8ef-bfd2-5cc0-a767-7910a95e4e04","excerpt":"上一节介绍了webpack loader的基本概念以及处理流程，并且简单的实现了使用来动态的加载文件，正好前面总结了在项目中使用webp优化网站的方案，之前的思路是用一段JavaScript代码生成webp格式的图片，现在换个思路，可以在的时候，动态的生成webp的图片，而这个过程正好可以使用webpack loader来实现。 webp-loader的实现 注意事项 目前缩写的还不能独立的使用，因为并没有导出合法的JavaScript模块，后面继续讲解处理方案。","fields":{"slug":"/blog/2018/07/12/webp-loader.html","date":"2018-07-11T16:00:00.000Z"},"frontmatter":{"title":"webpack webp loader","author":["Sylvenas"],"categories":"bundlers","secert":null}}},{"node":{"id":"017bc4f7-3e64-59b5-b52f-c26c67e33897","excerpt":"JavaScript里有个太常见的关键字，不过却有很多的开发人员弄不懂关键字在不同的环境中的指向，也弄不清楚应该怎样使用这个关键字。 当你彻底理解了和的时候，你也就弄明白了JavaScript的核心精髓了。 在理解this…","fields":{"slug":"/blog/2018/06/24/this.html","date":"2018-06-23T16:00:00.000Z"},"frontmatter":{"title":"What is 'this' in JavaScript","author":["Sylvenas"],"categories":"JavaScript","secert":null}}},{"node":{"id":"c1ffb5d5-39d2-5761-a5df-442d84e2acd7","excerpt":"在react中最常见的一个操作就是把一个数组的数据map成一个react组件的数组，然后其中的每一个组件都要绑定事件，看一下下面的这个例子： 上面代码的关键在于方法的使用，我们是使用了一个闭包来保存的数据，然后在后面用户点击按钮的时候，能获取到用户点击的是哪一个; So What’s the Problem…","fields":{"slug":"/blog/2018/06/15/arrow-in-react.html","date":"2018-06-14T16:00:00.000Z"},"frontmatter":{"title":"react 性能优化：arrow function in react","author":["sylvenas"],"categories":"React","secert":null}}},{"node":{"id":"405f1cf9-c24e-55a9-9178-8074edea21b8","excerpt":"初识类型 刚接触函数式编程的人很容易深陷类型签名(type signatures)的泥淖。类型(type)是让所有不同背景的人都能高效沟通的元语言。很大程度上，类型签名是以 “Hindley-Milner” 系统写就的，本章我们将一起探究下这个系统。 类型签名在写纯函数时所起的作用非常大，大到英语都不能望其项背。这些签名轻轻诉说着函数最不可告人的秘密。短短一行，就能暴露函数的行为和目的。类型签名还衍生出了 “自由定理(free theorems…","fields":{"slug":"/blog/2018/06/06/FP9-Hindley-Milner.html","date":"2018-06-05T16:00:00.000Z"},"frontmatter":{"title":"FP9：Hindley-Milner","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"e8b53ab9-28c3-5ebb-a31d-c429ba1f3594","excerpt":"在react中通常我们需要根据各种不同的条件来渲染数据，例如最为常见的根据loading状态渲染loading动画组件还是渲染数据； 在项目中遇到的太多次上面的场景，故总结如下： 三元运算符 在JSX中，你可以使用去处理条件渲染: 可能存在的问题：如果有多个嵌套的条件怎么处理？ 辅助方法 这是一个有用的方法，但是当组件更大时，你需要在辅助方法和方法之间上下跳跃,并且能把判断逻辑封装到相应的辅助方法中 getter方法 如果你不喜欢在render方法中调用函数，可以使用对象的getter…","fields":{"slug":"/blog/2018/05/26/react-if.html","date":"2018-05-25T16:00:00.000Z"},"frontmatter":{"title":"react 条件渲染","author":["sylvenas"],"categories":"React","secert":null}}},{"node":{"id":"81442a52-2106-5ffa-94af-fb7baf6a18e5","excerpt":"在函数式编程中，有一个概念叫做高阶函数,高阶函数通常意义上来说会对传入的函数进行增强，返回一个添加了额外功能的新函数。 当高阶函数的概念应用到React…","fields":{"slug":"/blog/2018/05/21/hight-order-component.html","date":"2018-05-20T16:00:00.000Z"},"frontmatter":{"title":"higher-order component(HOC)","author":["Sylvenas"],"categories":"React","secert":null}}},{"node":{"id":"e556c292-5deb-50e4-be82-386cb95be647","excerpt":"Webpack原理 本质上来说webpack是运行在node.js之上的一个JavaScript程序,通过配置文件指令程序应当从哪里入手、遇到各种文件应当怎么处理、遇到导入的文件，怎么根据路径加载，以及在处理各种文件的过程中，做各种优化和处理; 一切文件：JavaScript、CSS、SCSS、图片、模板，在 Webpack 眼中都是一个个模块，这样的好处是能清晰的描述出各个模块之间的依赖关系，以方便 Webpack对模块进行组合和打包。 经过Webpack…","fields":{"slug":"/blog/2018/04/24/webpack-loader.html","date":"2018-04-23T16:00:00.000Z"},"frontmatter":{"title":"webpack loader","author":["Sylvenas"],"categories":"bundlers","secert":null}}},{"node":{"id":"e60e7564-4a94-5abd-a198-aff0238da4f7","excerpt":"ES6中值得称赞的特性之一就是提供函数表达式缩写定义的箭头函数语法。你很难发现关于ES6（或者甚至甚少与其相关的）的一篇文章、会议演讲或者书都没有首要介绍是新的。 其中有一点是最让人困惑的，就是箭头函数内的到底指向哪里？举个例子来说： 这里的箭头函数似乎绑定了它的到父函数的this上,不过也仅仅是看上去如此罢了，那么到底是怎么回事呢？，我们把上面的代码稍微修改一下： 变量名self是一个绝对可怕的，有误导的名字。它意味着this是函数本身的引用。但它从来没有。var that = this…","fields":{"slug":"/blog/2018/03/16/arrow-function-this.html","date":"2018-03-15T16:00:00.000Z"},"frontmatter":{"title":"arrow function this","author":["sylvenas"],"categories":"JavaScript","secert":null}}},{"node":{"id":"ce8cbeda-14c5-52ab-8881-7133ef42189f","excerpt":"…","fields":{"slug":"/blog/2018/03/12/白夜行.html","date":"2018-03-11T16:00:00.000Z"},"frontmatter":{"title":"白夜行","author":["sylvenas"],"categories":"Life","secert":null}}},{"node":{"id":"8db6ce2c-0dfa-5744-bf3c-6b7eb599c8bc","excerpt":"所谓响应式的图片，就是让我们在不同的平台，不同的设备上使用的图片都不一样，设计师切图给我们的时候，一般都会把给我 1x,2x,3x,4x 的图片，有的时候，那么这几张图片我们该怎么使用呢？ 这个时候就会有 HTML5 的 img,srcset属性出场的时候到了，srcset 可以让我们支持在一个 img 元素中预设多张图片，方便浏览器在不同的设备中选择最合适的那一张图片。 简单介绍一个 srcset…","fields":{"slug":"/blog/2018/03/10/responsive-img.html","date":"2018-03-09T16:00:00.000Z"},"frontmatter":{"title":"web image 加载优化方案--responsive-image","author":["Sylvenas"],"categories":"性能优化","secert":null}}},{"node":{"id":"f9472c26-d4fe-5567-98ce-9eebf975940a","excerpt":"大概的placeholder的技术方案基本思路都是先加载一个很小的模糊但是能基本展示图片的轮廓和色调的图片作为占位符，然后再加载真正要展示的图像，大的图像加载完成之后，使用一个渐变的效果隐藏小的图片，展示真正的图片。 placeholder…","fields":{"slug":"/blog/2018/03/09/placeholder.html","date":"2018-03-08T16:00:00.000Z"},"frontmatter":{"title":"web image 加载优化方案--placeholder","author":["Sylvenas"],"categories":"性能优化","secert":null}}},{"node":{"id":"56bb7a8e-493f-5cc9-8ca5-c274a20e992e","excerpt":"Lazy loading 几乎所有的懒加载都是通过JavaScript来实现的 Scroll Listeners and relayout 我们一般会通过监听元素的事件，来检查图像的占位符是否位于当前可是区域内，如果是，则开始加载，这是目前我们大多数人采用的思路，但是事件可能会对页面性能产生负面影响，在滚动期间，浏览器会多次触发事件，并加载我们即将要被加载的图像，这会导致浏览器的重新布局，这是一个很影响性能的操作，可以尽量给scroll…","fields":{"slug":"/blog/2018/03/08/lazy-loading.html","date":"2018-03-07T16:00:00.000Z"},"frontmatter":{"title":"web image 加载优化方案--lazy-load","author":["Sylvenas"],"categories":"性能优化","secert":null}}},{"node":{"id":"09580e87-359b-5cb3-b50b-b7a358f394af","excerpt":"what is webp webp 是由 Google 收购 On2 Technologies 后发展出来的格式，以BSD授权条款发布。目前已经在不同厂商之间进行了尝试，如Google、Facebook、ebay、百度、腾讯、淘宝等。 webp支持有损压缩和无损压缩，可以使用于大多数的图片、半透明、透明都可以；并且有损压缩的程度是可以调节的，用户可以在文件大小和图像质量之间作出权衡，根据研究，webp通常可以比jpg和jpeg图像在不损失图像质量的情况下，体积缩小30%。 目前只有Chrome…","fields":{"slug":"/blog/2018/03/07/webp.html","date":"2018-03-06T16:00:00.000Z"},"frontmatter":{"title":"web image 加载优化方案--webp","author":["Sylvenas"],"categories":"性能优化","secert":null}}},{"node":{"id":"c2c4cf82-16ac-5c92-a9ed-c8cd1c72e5df","excerpt":"优化方案 根据统计，用户打开网站，最满意的时间是1-2秒，如果超出了1-2秒，用户就会感觉卡顿，如果超过10秒以上，98%的用户会选择直接关闭这个网站，任何大于两秒的下载时间都将会使你的用户失去耐心，而现在网站中大部分的需要下载的资源都是，那么优化的加载速度就是重点部分， 错误格式的图片，或者是没有压缩的图片，还有就是图片太大的时候这些情况会极大地影响你的页面的初始化速度。 面对大小、格式、压缩等级等多样选择，到底应该从何处下手，PNG,JPG,SVG,内联的base64编码的字符串，webp…","fields":{"slug":"/blog/2018/03/06/web-image-优化.html","date":"2018-03-05T16:00:00.000Z"},"frontmatter":{"title":"web image 加载优化方案","author":["Sylvenas"],"categories":"性能优化","secert":null}}},{"node":{"id":"b10afde1-23cb-5de8-9b4f-3c9743be9a83","excerpt":"前端代码规范 代码格式化 Prettier Prettier 支持多种语言，它的一大特点就是能够支持命令行、API 等多种形式调用，可以让团队保持代码风格一致。包括 React 在内的很多项目已经开始使用了。 Prettier支持列表如下： JavaScript,TypeScript,EcmaScript JSX CSS,SASS,LESS JSON GraphQL 查看完整的格式化文档示例 Prettier使用方法： 1.编辑器中安装插件\n现在主流的编辑器都有相应的插件了 2.在git…","fields":{"slug":"/blog/2018/02/24/js-style.html","date":"2018-02-23T16:00:00.000Z"},"frontmatter":{"title":"前端代码规范","author":["Sylvenas"],"categories":"JavaScript","secert":null}}},{"node":{"id":"5d0a0afa-ee00-5ce7-9a4c-0e1492654734","excerpt":"单例模式 单例模式又被称为单体模式，在面向对象思想中，单例就是保证一个类只有一个实例，实现的方法一般是在类的内部提供一个方法用来创建实例(在类的外部不允许使用关键字创建实例)，先判断类的实例是否存在，如果存在直接返回，如果不存在就创建了再返回，这样就可以确保一个类只有一个实例对象； 从上面的描述，我们可以看出单例模式的核心在于系统中某些变量有且只有一个，暴露出来供外部使用。 由于在js…","fields":{"slug":"/blog/2018/02/01/singleton.html","date":"2018-01-31T16:00:00.000Z"},"frontmatter":{"title":"单例模式","author":["sylvenas"],"categories":"design pattern","secert":null}}},{"node":{"id":"5295b4ed-cdbf-5cf2-9979-57463cc8f081","excerpt":"Parcel是web应用打包工具，主要特点是无须任何配置()和速度极快，对于受够了那些机器复杂的配置项的同学来说是一种解放！在也不想去看的那一堆一堆的和了。 对于的简单入门就不再做过多的描述，太简单了，到官网一看便知，下面主要说几种我们在开发中经常遇到的场景，以及配合的解决方案。 接口代理 在前端开发中，现在在开发阶段会自己mock后端接口的数据，当我们开发完成需要和后端连调的时候，就需要做一个接口代理，把我们的请求从mock…","fields":{"slug":"/blog/2018/01/29/parcel.html","date":"2018-01-28T16:00:00.000Z"},"frontmatter":{"title":"Parcel简介","author":["Sylvenas"],"categories":"bundlers","secert":null}}},{"node":{"id":"a141cf67-6ff0-5298-89c3-5d744ee38288","excerpt":"Simple Factory Pattern Intro 简单工厂模式的定义为定义一个工厂类，它可以根据参数的不同返回不同类的实例；简单工厂模式不属于GOF 23个经典设计模式之一，它的设计思想很简单，其基本流程如下： 将需要创建的各种不同类型的对象的相关代码封装到不同的类中，这些类称为具体产品类。 提供一个工厂方法用来创建产品，该方法可以根据所传入的参数不同创建不同的具体产品对象。 客户端调用工厂方法并传入相应的参数。 Simple Factory Pattern Example…","fields":{"slug":"/blog/2018/01/20/factory-pattern.html","date":"2018-01-19T16:00:00.000Z"},"frontmatter":{"title":"工厂模式","author":["Sylvenas"],"categories":"design pattern","secert":null}}},{"node":{"id":"af65a19a-ee54-5ead-b775-78db3c2f42ff","excerpt":"什么是原型链 发现很多文章都是先讲,这里我们换个思路来介绍，我们先讲。JS中每个对象(除了null和undefined)都有一个私有的只读属性。 当我们调用一个对象(obj)的某个方法或者属性(fn…","fields":{"slug":"/blog/2018/01/16/prototype-pattern.html","date":"2018-01-15T16:00:00.000Z"},"frontmatter":{"title":"原型模式","author":["Sylvenas"],"categories":"design pattern","secert":null}}},{"node":{"id":"67b7fc44-00fe-57ed-90e2-d7bc8fb509bf","excerpt":"构造函数 在JavaScript中，构造函数通常是用开创建实例的，JavaScript中没有类的概念，但是有特殊的构造函数，可以通过关键字来调用构造函数，约定成俗的构造函数的首字母大写。 example…","fields":{"slug":"/blog/2018/01/12/constructor-pattern.html","date":"2018-01-11T16:00:00.000Z"},"frontmatter":{"title":"构造函数模式","author":["Sylvenas"],"categories":"design pattern","secert":null}}},{"node":{"id":"3e4f52d8-1b5a-530e-a8a5-793d56823abb","excerpt":"发布订阅模式的概念 发布订阅模式Pub/Sub,它的主要概念为，在JavaScript和Jquery非常容易看到该模式的使用，例如Jquery里的,下面的代码就可以想象成，为订阅者，订阅了click,如果click…","fields":{"slug":"/blog/2018/01/06/pub-sub-pattern.html","date":"2018-01-05T16:00:00.000Z"},"frontmatter":{"title":"发布订阅模式","author":["Sylvenas"],"categories":"design pattern","secert":null}}},{"node":{"id":"d1c1f322-7163-50db-bef2-ef773fb9a03d","excerpt":"概述 浏览器的缓存机制也就是我们说的HTTP缓存机制，其机制是根据HTTP报文的缓存标识进行的，所以在分析浏览器缓存机制之前，我们先使用图文简单介绍一下HTTP报文，HTTP报文分为两种： 请求(request)报文：请求行 – HTTP头(通用信息头，请求头，实体头) – 请求报文主体(只有POST才有报文主体) 响应(response)报文：报文格式为：状态行 – HTTP…","fields":{"slug":"/blog/2018/01/03/http-cache.html","date":"2018-01-02T16:00:00.000Z"},"frontmatter":{"title":"http cache","author":["Sylvenas"],"categories":"http","secert":null}}},{"node":{"id":"27576455-818c-5ae8-915d-7039b6efbc33","excerpt":"简介 编写可维护的代码的一个最重要的方面就是能够总结出代码中反复出现的问题，以及总结问题，找到这一类问题的解决方案。 设计模式并不仅仅出现在计算机领域，生活中的方方面面都可以总结出设计模式，设计模式的明确提出，最早可以追溯到一位名为的建筑设计师。他经常会写一些关于解决设计问题方面的总结文章。有一天，亚历山大想到，一次又一次的使用某些设计结构可以达到他的理想效果。 亚历山大后来和Sara Ishikawa、Murray Silverstein合作创作了一门设计语言，并在1977年发表了一篇名为《A…","fields":{"slug":"/blog/2018/01/03/desgin-pattern-in-js.html","date":"2018-01-02T16:00:00.000Z"},"frontmatter":{"title":"JavaScript设计模式简介","author":["Sylvenas"],"categories":"design pattern","secert":null}}},{"node":{"id":"77c7bcbe-907b-58e4-921b-a3ecc62c9d1e","excerpt":"…","fields":{"slug":"/blog/2018/01/02/FP8-Recursion.html","date":"2018-01-01T16:00:00.000Z"},"frontmatter":{"title":"FP8：Recursion","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"e554fde0-f668-57f6-bfb2-0c91091819cc","excerpt":"函数组合 就是组合两到多个函数来生成一个新函数的过程。将函数组合在一起，就像将一连串管道扣合在一起，让数据流过一样。 简而言之，函数和的组合可以被定义为,从内到外(从又向左)求值。也就是说，求值顺序是：    下面我们在代码中近距离观察一下这个概念。想象一个场景，你想把一个人的全名转换为URL Slug，给每个用户一个个人信息页面。为了实现此需求，你需要经历一连串的操作： 将姓名用空格分隔()到一个数组中 将姓名映射()为小写 用破折号连接() 编码URI…","fields":{"slug":"/blog/2017/11/27/FP7-function-composition.html","date":"2017-11-26T16:00:00.000Z"},"frontmatter":{"title":"FP7：What is Function Composition?","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"d0ebf049-6939-51ed-901d-0c4320aa1a2e","excerpt":"在了解什么是偏应用函数和柯里化之前，我们先复习一下中学数学中的高斯消元法的简单应用： 设函数；在的时候，函数可以修改为； 上面的基本思路就是把变成，同理我们可以把三元函数为二元，甚至把多元函数为一元函数。 那么我们可以在一定程度上认为函数求值的过程，也可以认为就是函数消元的过程，当所有的元都被消完之后，那么就可以求的函数值。 在函数式编程中，我们也可以采用类似的思路去解决我们的问题，下面我们看几个关于函数参数的例子： All for One…","fields":{"slug":"/blog/2017/11/23/FP6-Curry-and-PartialApplication.html","date":"2017-11-22T16:00:00.000Z"},"frontmatter":{"title":"FP6：Partial Application And Curry","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"c9679c40-8259-5183-8aa4-9d0057ae832f","excerpt":"要讲,就必须先理解JavaScript中的词法环境的概念；词法环境简单来说就是包括环境记录()和对外部词法环境的引用。 环境记录初始化 一段JS代码执行之前，会对环境记录进行初始化（声明提前），即将函数的形参、函数声明和变量先放入函数的环境记录中，特别需要注意的是： 形参会在初始化的时候定义值，但是函数内部定义的变量只声明不不赋值； 以下面这段代码为例，解析环境记录初始化和代码执行的过程： 初始化全局环境 执行  执行var bar = foo(20)语句之前，将foo…","fields":{"slug":"/blog/2017/11/20/FP5-closure.html","date":"2017-11-19T16:00:00.000Z"},"frontmatter":{"title":"FP5：What is a Closure?","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"39a19510-db99-5db3-adf3-7fe9d5c3c05e","excerpt":"在我们认识纯函数之前，我们来仔细审视一下函数的概念，或许从另外一种角度来观察函数，可以让我么更加容易的理解函数式编程的理念。 What is a Function? 函数是一组执行任务和计算值的过程，一个函数由称为函数体的一系列语句组成，函数包括函数的的输入参数(),计算得出的输出结果();函数可以有以下用途： Mapping:根据输入参数生成一些输出数据。一个函数将输入值映射到输出值。 Procedures…","fields":{"slug":"/blog/2017/11/15/FP4-Pure-function.html","date":"2017-11-14T16:00:00.000Z"},"frontmatter":{"title":"FP4：Pure function","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"cdf49729-4884-54f9-91af-b4cd82aad270","excerpt":"What is Functional Programming? 函数式编程已经成为JavaScript领域里的一个非常热门的话题。几年以前，很少有JavaScript…","fields":{"slug":"/blog/2017/11/14/FP3-Functional-Programming.html","date":"2017-11-13T16:00:00.000Z"},"frontmatter":{"title":"FP3：Functional Programming","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"c2b152a1-5ba7-5d13-b595-fd643dd59b20","excerpt":"Observer what is Observer? Observer(观察者)是Observable(可观察对象)推送的数据的消费者。在Rxjs中，Observer是由回调组成的对象，对象的键名分别为：、和，以此接受Observable推送的不同类型的通知，下面的代码是Observer的一个简单示例： Observer的使用，只需要在Observable时，把observer作为参数传递给方法即可。 Observers are just objects with three callbacks…","fields":{"slug":"/blog/2017/11/8/Rxjs-Observer.html","date":"2017-11-07T16:00:00.000Z"},"frontmatter":{"title":"Rxjs Observer","author":["Sylvenas"],"categories":"Rxjs","secert":null}}},{"node":{"id":"66afd76c-3354-5e1e-a944-dcb3116e8311","excerpt":"…","fields":{"slug":"/blog/2017/11/7/山月记.html","date":"2017-11-06T16:00:00.000Z"},"frontmatter":{"title":"山月记","author":["sylvenas"],"categories":"Life","secert":null}}},{"node":{"id":"b4d476bd-5e25-5f9d-8d38-43e2355dd168","excerpt":"pull versus push 拉取 和 推送 是数据生产者和数据消费者之间进行通信的两种不同的机制。 **What is pull…","fields":{"slug":"/blog/2017/10/26/Rxjs-Observable.html","date":"2017-10-25T16:00:00.000Z"},"frontmatter":{"title":"Rxjs Observable","author":["Sylvenas"],"categories":"Rxjs","secert":null}}},{"node":{"id":"e20fe14b-c7a6-5c41-be3b-b48dcef91d4b","excerpt":"在介绍Rxjs之前，先通过一个简单的输入框示例的演化来了解一下Rxjs的核心思想。\nexample 这是input输入框的示例非常简单，就是在input输入的时候，实时更新下面的文字，程序的逻辑看起来是这样的：\nexample 从上面的实例中我们可以梳理处三个基本的概念： Provider/数据的提供者 在这个示例中数据的提供者就是input的输入内容，每当输入一个字符的时候都会生成新的数据value。 data/数据 这个实例中的数据就是输入框输入的内容 Consumer…","fields":{"slug":"/blog/2017/10/24/Rxjs-intro.html","date":"2017-10-23T16:00:00.000Z"},"frontmatter":{"title":"Rxjs intro","author":["Sylvenas"],"categories":"Rxjs","secert":null}}},{"node":{"id":"4e8fc826-fba9-52b8-81e2-7c1f8b27af6f","excerpt":"之前一直知道React中是一个异步的操作，如果我们再一个函数内有两个,那么他们会合并，只执行最后一个,例如： 两个都是异步的，第一个不会修改,然后我们得到的结果是.Right? 但是有一种情况，当在React生命周期之外被调用的时候，例如：JavaScript原声的DOM listener(通过addEventListener添加)、setTimeout、setInterval、requestAnimationFrame以及ajax callbacks.这是因为React…","fields":{"slug":"/blog/2017/10/23/set-state.html","date":"2017-10-22T16:00:00.000Z"},"frontmatter":{"title":"setState Might Be Synchronous","author":["Sylvenas"],"categories":"React","secert":null}}},{"node":{"id":"1bb6434f-d57d-5cd2-8f9e-680b6833a1e7","excerpt":"发布订阅模式Pub/Sub,它的主要概念为，在JavaScript和Jquery非常容易看到该模式的使用，例如Jquery里的,下面的代码就可以想象成，为订阅者，订阅了click,如果click事件发生了。发布者就会执行方法。 该模式的优点在于，发布者与订阅者不需要知道对方的存在。 在使用的时候，当一个对象改变时，需要同时改变其他对象，但却不知道实际有多少个对象时，就可以考虑使用。 Pub/Sub 简单示例 然后就可以使用了，首先订阅一个,并且当Task…","fields":{"slug":"/blog/2017/10/16/pub-sub.html","date":"2017-10-15T16:00:00.000Z"},"frontmatter":{"title":"pub & sub","author":["Sylvenas"],"categories":"Rxjs","secert":null}}},{"node":{"id":"37b8fbc4-4d14-5789-9267-09ad229a8b41","excerpt":"尽管通常认为JavaScript是一门“动态”或者“解释执行”的语言，但是事实上JavaScript…","fields":{"slug":"/blog/2017/10/03/lexical-environments.html","date":"2017-10-02T16:00:00.000Z"},"frontmatter":{"title":"lexical environment","author":["sylvenas"],"categories":"JavaScript","secert":null}}},{"node":{"id":"5a6c29ec-93b0-5230-8200-50b86c944bf8","excerpt":"在应用react开发中，大家经常遇到各种this的问题，其中最常见的情况，也是很多新手容易些的代码(在线地址)是： 上面的代码会报错提示： 新手可能在疑惑为何会报错？ 原因在于，这里只是把 this.increase、this.decrease 传给 onClick, 真正调用的时候（click event）并没有指定context，从而导致在方法内部的this为null。 React团队在使用ES6开发react…","fields":{"slug":"/blog/2017/08/30/react-bind.html","date":"2017-08-29T16:00:00.000Z"},"frontmatter":{"title":"React Bind","author":["sylvenas"],"categories":"React","secert":null}}},{"node":{"id":"012e02dd-ca3c-5efd-bc94-efad9599b221","excerpt":"基础概念 单页面应用的核心是在不刷新当前页面的情况下，来实现页面URL和页面内容的变化，那么我们需要关注的要点也就在于怎么修改URL和页面的内容 浏览器history HTML5引入了和方法，它们分别可以添加和修改历史记录条目。这些方法通常与配合使用。 相同之处是两个 API 都会操作浏览器的历史记录，而不会引起页面的刷新。 这两个 API 都接收三个参数，分别是 状态对象(state object) — 一个JavaScript…","fields":{"slug":"/blog/2017/08/21/SPA.html","date":"2017-08-20T16:00:00.000Z"},"frontmatter":{"title":"SPA 实现原理","author":["sylvenas"],"categories":"React","secert":null}}},{"node":{"id":"7479fb31-ae6d-502b-b6fa-e05c76a1b4b4","excerpt":"请忘掉你认为你知道的有关JavaScript的任何东西，以初学者的心态来接触这份资料。为帮助你这样做，我们打算从头开始复习JavaScript的基础知识，就像你以前从来没有看到过JavaScript一样。如果你是已经熟悉JavaScript或者纯函数式语言的老手，也许你会认为用JavaScript来探究函数式编程就是个笑话。请把你的这些想法放一边，尝试用新的心态来接触这份博客。你可能会发现这是另一种思路的JavaScript…","fields":{"slug":"/blog/2017/07/25/FP2-learn-FP-in-javascript.html","date":"2017-07-24T16:00:00.000Z"},"frontmatter":{"title":"FP2：Why Learn FP in JavaScript?","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"335a33b6-3a9a-58d8-bb7c-5f3bed479a1e","excerpt":"…","fields":{"slug":"/blog/2017/07/20/FP1-composing-software-intro.html","date":"2017-07-19T16:00:00.000Z"},"frontmatter":{"title":"FP1：Composing software introduction","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"c3e18992-86ec-5fda-bfa1-ba4436aa5db3","excerpt":"我16岁的时候，花了很多时间与最好的哥们一起玩电脑游戏。他家里有一个满是电脑的房间。它们对于我来说是无法抵御的、神奇的。我花了很多时间探索所有游戏。有一天我问我哥们，“我们做一个游戏怎么样？”。 他也不知道怎么做，所以我们就问他老爸。他老爸爬上一个高架子，拿出一本用 Basic 编写的游戏书。于是我们就开始了编程之旅。等到公立学校开始教代数时，我已经对代数掌握的不错了，因为编程基本上都是代数。大致就是这样的。 The Rise of Composable Software…","fields":{"slug":"/blog/2017/07/16/FP0-functional-programming.html","date":"2017-07-15T16:00:00.000Z"},"frontmatter":{"title":"FP0：Rise and fall of functional programming","author":["Sylvenas"],"categories":"functional","secert":null}}},{"node":{"id":"44cbc770-af17-5fe3-80b2-4bfc4c676b29","excerpt":"在react中经常会遇到onClick,onChange 等事件的传参问题，现在简单把react event中传递参数的方法，进行简单总结,举例如下： 1.bind 2.closure showName和showName2 是等价的，前者是ES6写法(更简洁)，后者是ES5写法(传统闭包)。 3.create new method 在onClick中动态创建新函数 4.make the param be a prop…","fields":{"slug":"/blog/2017/06/23/react-pass-params.html","date":"2017-06-22T16:00:00.000Z"},"frontmatter":{"title":"React Pass Params","author":["Sylvens"],"categories":"React","secert":null}}},{"node":{"id":"b0228499-30e7-5bc3-9309-1d399650908f","excerpt":"本篇文章为摘抄，原作者：接水怪，原文地址：https://mp.weixin.qq.com/s/uUGy94fp3x8khCTR0gZeJA 本篇文章将带你深入 HTTPS 加解密原理，希望看完能够有这些收获： 明白 HTTPS 到底解决了什么问题 理解对称加密与非对称加密的原理和使用场景 明白 CA 机构和根证书到底起了什么作用 近几年来，各大公司都在大力推进 HTTPS 的建设。Google Chrome将非 HTTPS 的网站标注为「不安全」，苹果要求 APP 中需要使用HTTPS…","fields":{"slug":"/blog/2017/06/13/https.html","date":"2017-06-12T16:00:00.000Z"},"frontmatter":{"title":"HTTPS与网络安全","author":["Sylvenas"],"categories":"http","secert":null}}},{"node":{"id":"cd67fb4f-66be-50f9-99dc-d99c39bda356","excerpt":"工作了这么长的时间，每天都在写大量的业务代码，对有些基础知识有所忘却，尤其是http协议部分，读书的时候就学了理论知识，却没有自己去验证过，到现在连理论部分都有所忘却了，现在重新捡起书本和拿起工作已经掌握的技能从新认识一下http协议。 网络基础 TCP/IP分层 TCP/IP体系一般分为五层，从上到下分别为应用层、传输层、网络层、数据链路层、物理层，不过按照协议来划分的话，物理层没有必要划分出来，因为物理层不存在任何协议，所以有的书也认为TCP/IP…","fields":{"slug":"/blog/2017/05/17/http.html","date":"2017-05-16T16:00:00.000Z"},"frontmatter":{"title":"http协议简介","author":["Sylvenas"],"categories":"http","secert":null}}},{"node":{"id":"a60cdc66-50db-55eb-a5b3-eccce55fff70","excerpt":"关于异步的实现，上面的一节中的需求：有接口1，接口2，接口3，要求按照顺序输出接口1，接口2，接口3的返回值\n如果用async函数来实现，可以这样写： 就像是Generator中的，就相当于Generator中的，同样的await只能在使用了async的函数内使用。 Generator + Promise 看一个简单的基于Promise实现的ajax的例子： 那么如果我们想用Generator包装一下这个ajax请求呢，我们可以使用yield把foo函数返回的promise…","fields":{"slug":"/blog/2017/05/11/async-await.html","date":"2017-05-10T16:00:00.000Z"},"frontmatter":{"title":"async & await","author":["Sylvenas"],"categories":"Async","secert":null}}},{"node":{"id":"221e36c0-043c-5520-8cee-3853454a149d","excerpt":"线程与进程可以说是老生常谈的话题了 只要是懂事计算机相关的小伙伴，提起这个大都思如泉涌，多线程，多进程，高并发等等各种零碎的概念和认知或许难以汇成一个成体系的知识结构，我们先来罗列一下这两个概念简介的官方解释。 进程(process): 处于执行期的代码，正在运行的程序，它不仅包括代码，还有数据、资源、状态和虚拟的计算机 线程(thread): 一个程序里的一个执行路线就叫做线程。更准确的定义是：线程是一个进程内部的控制程序 上面的概念依然让人一头雾水，还是看图说明吧 process…","fields":{"slug":"/blog/2017/04/12/os-process.html","date":"2017-04-11T16:00:00.000Z"},"frontmatter":{"title":"操作系统与进程/线程","author":["Sylvenas"],"categories":"OS","secert":null}}},{"node":{"id":"2fc81a97-2788-5be6-9776-4491d8083268","excerpt":"说起javascript异步，我想你一定会想起ES7的，甚至要排在Promise之前，从今天起我们来聊一聊async 要说async，就不得不提Generator生成器（好多知识都是一环扣一环，很是无奈），async就是Generator的语法糖 Generator Generator写法很像一个函数，但是区别于普通函数，一个例子： it是一个迭代器，我们没有像打印普通函数那样打印出我们想要的结果 普通的函数一旦执行，就不会停下来，直到执行完毕（不考虑debugger，alert，throw…","fields":{"slug":"/blog/2017/03/11/generator.html","date":"2017-03-10T16:00:00.000Z"},"frontmatter":{"title":"Generator","author":["Sylvenas"],"categories":"Async","secert":null}}},{"node":{"id":"cc270f4d-4842-5e24-ae70-a7c130292bf5","excerpt":"react-magic npm version\r\n\r\n\r\n A collection of magic animations for react components. Although React provides a way to implement arbitrary animations,\r\nit is not an easy task to do it, even for simple animations. That's where react-magic package comes…","fields":{"slug":"/blog/2017/02/26/react-magic.html","date":"2017-02-25T16:00:00.000Z"},"frontmatter":{"title":"React Magic","author":["Sylvenas"],"categories":"React","secert":null}}},{"node":{"id":"649b47ed-c39c-5224-a3eb-cc47c3aa53dd","excerpt":"可以这么说，resolve和reject撑起了Promise的半边天，我们平时用的最多的就是这两个API resolve和reject 我们知道Promise是一个构造函数，用来实例化一个Promise实例，\n这个Promise构造函数，用一个函数来作为参数,这个作为参数的函数又有两个参数,当然这两个参数都不是必填项: 第一个参数是 第二个参数是 Promise有三个状态：，，\n异步是一个耗时的过程，当在执行异步的时候，就是Promise…","fields":{"slug":"/blog/2017/02/18/promise-API.html","date":"2017-02-17T16:00:00.000Z"},"frontmatter":{"title":"Promise API","author":["Sylvenas"],"categories":"Async","secert":null}}},{"node":{"id":"abdfc190-f465-5ffd-9830-e78a1f1931ca","excerpt":"callback的缺点 我们说处理javascript…","fields":{"slug":"/blog/2017/02/14/promise.html","date":"2017-02-13T16:00:00.000Z"},"frontmatter":{"title":"Promise","author":["Sylvenas"],"categories":"Async","secert":null}}},{"node":{"id":"11e32812-3259-5f56-8a7d-795a51af90d2","excerpt":"Component state is a way of holding, processing and using information that is internal to a given Component and allows you to implement its logic. State is usually a POJO (Plain Old Java[Script] Object), and changing it is one of the few ways to make…","fields":{"slug":"/blog/2016/12/01/react-setState.html","date":"2016-11-30T16:00:00.000Z"},"frontmatter":{"title":"React setState","author":["Sylvenas"],"categories":"React","secert":null}}},{"node":{"id":"d4bde5c3-c173-50ed-a0aa-15f845b5de18","excerpt":"Event Loop 单线程 我们常说“JavaScript是单线程的”。 所谓单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个。不妨叫它主线程。 但是实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们工作线程。 同步与异步 假设存在一个函数A： 同步：如果在函数A…","fields":{"slug":"/blog/2016/11/15/event-loop.html","date":"2016-11-14T16:00:00.000Z"},"frontmatter":{"title":"How JavaScript Work: Event Loop","author":["Sylvenas"],"categories":"Async","secert":null}}},{"node":{"id":"0b368616-4c32-5d91-9d79-8a99f9c7993c","excerpt":"针对Web的攻击技术 简单的HTTP协议本身并不存在安全性问题，因此协议本身几乎不会成为攻击对象。而应用HTTP协议的服务器和客户端，以及运行在服务器上的Web应用等才是攻击的目标。 HTTP本身不具备必要的安全功能 从整体上看HTTP就是一个通用的单纯协议机制，它并不具备会话(session)安全，加密处理等安全性方面的功能，开发者需要自行设计并开发认证及会话管理来腕足web应用的安全，自行设计就意味着可能会出现各种各样的Bug。 针对Web…","fields":{"slug":"/blog/2016/09/23/web攻击与防范.html","date":"2016-09-22T16:00:00.000Z"},"frontmatter":{"title":"web攻击与防范","author":["Sylvenas"],"categories":"http","secert":null}}},{"node":{"id":"b3a2956d-5721-531f-a5a3-6858bc9ef093","excerpt":"在解释 BFC 是什么之前，需要先介绍 Box、Formatting Context的概念。 Box: CSS布局的基本单位 Box是CSS布局的对象和基本单位，直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个Box的类型。 不同类型的Box，会参与不同的Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子： block-level box:display…","fields":{"slug":"/blog/2016/08/21/bfc.html","date":"2016-08-20T16:00:00.000Z"},"frontmatter":{"title":"BFC 块级格式化上下文","author":["sylvenas"],"categories":"CSS","secert":null}}},{"node":{"id":"1a312dd7-b623-595d-87b5-910042f2c8fc","excerpt":"Node.js架构 相信只要你是一名前端，或多或少都能说出一些你对 Node.js 的理解与看法。 我们先来看看浏览器与Node的一个对比，毕竟很多前端初学者可能还没有接触过Node，只是在浏览器里面跑项目。 Node.js VS Chrome 左图是浏览器的一个简单架构，我们平时写的前端项目无非就是3个部分: HTML跟CSS交给引擎去处理，经过一系列的转换处理，最终呈现到我们的屏幕上，之前有看过Chrome团队SteveKobes…","fields":{"slug":"/blog/2016/07/17/node-core.html","date":"2016-07-16T16:00:00.000Z"},"frontmatter":{"title":"Node.js核心概念讲解","author":["Sylvenas"],"categories":"Node.js","secert":null}}},{"node":{"id":"40c9006c-0933-535b-91ab-1a3a7cbf4a97","excerpt":"偶然间看到facebook的网页版和手机版在网速比较慢的时候，都会有一个的过程，但是这个loading,完全不同于一般的一个小圈圈在页面上转，而是如下的一个+： 经过在一番搜索和实践之后，找到了两种常见的实现方法： 空余background方法 先看一下效果，可以完美的实现和facebook…","fields":{"slug":"/blog/2016/04/23/facebook-placeholder.html","date":"2016-04-22T16:00:00.000Z"},"frontmatter":{"title":"facebook placeholder","author":["sylvenas"],"categories":"CSS","secert":null}}},{"node":{"id":"316fad8e-643a-58ea-9052-c08ca0aecb16","excerpt":"关于浏览器的工作原理，一直存有好奇却又无从下手的状态，最近看到了一篇绝对棒的文章（原文链接），具体讲解了主流浏览器的工作原理，部分摘抄如下： 简介 网络浏览器很可能是使用最广的软件。在这篇入门文章中，我将会介绍它们的幕后工作原理。我们会了解到，从您在地址栏输入直到您在浏览器屏幕上看到Google…","fields":{"slug":"/blog/2016/04/18/how-browser-work.html","date":"2016-04-17T16:00:00.000Z"},"frontmatter":{"title":"how browser work","author":["Sylvenas"],"categories":"browser","secert":null}}},{"node":{"id":"2e6cd8c3-619a-5d2b-b460-fd658c022e9f","excerpt":"作为一个软件开发者，你一定会对网络应用如何工作有一个完整的层次化的认知，同样这里也包括这些应用所用到的技术：像浏览器，HTTP，HTML，网络服务器，需求处理等等。 本文将更深入的研究当你输入一个网址的时候，后台到底发生了一件件什么样的事～ 1. 首先嘛，你得在浏览器里输入要网址 例如: 2. 浏览器查找域名的IP地址 导航的第一步是通过访问的域名找出其IP地址。DNS查找过程如下： 浏览器缓存 – 浏览器会缓存DNS记录一段时间。 有趣的是，操作系统没有告诉浏览器储存DNS…","fields":{"slug":"/blog/2016/03/23/what-really-happens-when-you-nav-to-a-url.html","date":"2016-03-22T16:00:00.000Z"},"frontmatter":{"title":"What really happens when you navigate to a url?","author":["Sylvenas"],"categories":"browser","secert":null}}},{"node":{"id":"c5e7a0f3-2e3e-59a4-bb82-9f01bf669c2a","excerpt":"Argument vs Parameter 在试用函数的时候常常遇到这两个名词，翻译上有很多种，常见的有和却让挺多的人容易混淆，为了以后的清晰明了，做个总结😄。 引用stack overflow上的回答， An argument is an expression used when calling the method. A parameter is the variable which is part of the method's signature (method declaration…","fields":{"slug":"/blog/2015/09/23/argument-vs-parameter.html","date":"2015-09-22T16:00:00.000Z"},"frontmatter":{"title":"Argument vs Parameter","author":["Sylvenas"],"categories":"JavaScript","secert":null}}},{"node":{"id":"c0f32a34-f919-51c4-a7dc-19ac1abe7aba","excerpt":"作为前端开发人员，我们都在使用margin,不过在使用负margin的时候，有时候会变得非常的头疼，有些人认为负margin是常规武器，有些人确认为负margin是魔鬼的代名词。 常见的negative margin如下： 关于negative margin必须有一下几个要点需要澄清： **negative margin是一个完全合法的CSS。**W3C里有说明\"Negative values for margin properties are allowed…\",查看W3C…","fields":{"slug":"/blog/2015/07/05/negative-margin.html","date":"2015-07-04T16:00:00.000Z"},"frontmatter":{"title":"negative margin","author":["Sylvenas"],"categories":"CSS","secert":null}}},{"node":{"id":"08d8c398-4de0-5402-bbff-e6aba3bc6fe9","excerpt":"如何将固定在底部是一个非常经典的问题，这个问题 乍看起来非常简单，但是实际上相当棘手，在所有的\"隐蔽大坑\"的难题中，简直就是教科书一般的存在。 而我们想要达成的效果是： 1、当页面内容尚未充满的时候，页脚固定在底部。 2、页面填充满后，页脚随页面内容的增加而填充在主体内容的下方。 几乎所有的经典的解决方案都是给页脚设置固定的高度，然后按照某些特定的结构来写，可以先来看一下这些经典的解决方案，假定有如下的HTML结构 这个时候可以使用如下几种方法的的CSS代码使footer…","fields":{"slug":"/blog/2015/06/07/keep-footer-bottom.html","date":"2015-06-06T16:00:00.000Z"},"frontmatter":{"title":"How To Keep Your Footer At The Bottom Of The Page With CSS","author":["sylvenas"],"categories":"CSS","secert":null}}},{"node":{"id":"c85aedfb-6234-5414-8e14-c8de4d7a6aac","excerpt":"web front download file by url 最常见的场景为前端点击下载按钮，请求后端接口，后端返回一个uri,然后前端负责下载，方法如下 获取元素相对于浏览器的left&top的位置 判断元素是否在可是区域内 前端异步打开新的网页 经常遇到需要用户点击按钮，然后请求数据，然后打开新标签页的情况，例如：文件预览，由于浏览器的安全限制，不能在异步(ajax…","fields":{"slug":"/blog/2015/04/21/utils.html","date":"2015-04-20T16:00:00.000Z"},"frontmatter":{"title":"常用小工具代码集合","author":["sylvenas"],"categories":"Design","secert":null}}},{"node":{"id":"a99c158c-9156-557b-8f09-6584bed61c01","excerpt":"…","fields":{"slug":"/blog/2015/04/06/傲慢与偏见.html","date":"2015-04-05T16:00:00.000Z"},"frontmatter":{"title":"傲慢与偏见","author":["sylvenas"],"categories":"Life","secert":null}}},{"node":{"id":"95a739dc-eb22-5728-9a0e-d20ec5486c71","excerpt":"1.问题重新 通过ajax请求后端数据的时候，如果后端返回的状态吗是302，则约定为登陆过期，需要跳转到登录页，重新登录，前端代码如下： 这个逻辑看上去没有问题，但是在IE浏览器下会出现BUG,现象是跳转到登录页，登陆之后，会再次调转到登录页，问题的原因就在于，IE浏览器缓存了上次的get请求的返回值，那么就会进入是否过期的判断，然后就会再次跳转到登录页。 2.解决方案 1.axios 给每一个get请求增加一个时间戳,在axios请求之前进行添加 2.jQuery","fields":{"slug":"/blog/2015/03/25/session-timeout.html","date":"2015-03-24T16:00:00.000Z"},"frontmatter":{"title":"Ajax call when session time out","author":["Sylvenas"],"categories":"http","secert":null}}},{"node":{"id":"e25abbe7-6b4d-5473-964a-eef90c605dc6","excerpt":"圣杯布局算是一个\"古老\"的话题了，关于其来源网上资料众多，在此不多做表述。\n下面看一下实现的过程，先看HTML结构： 下面来一步一步的实现圣杯布局的样式： 首先实现,,的上中下三大块的布局 我们将main的内边距设置为左右两边各自的宽度。它看起来就像这样： 圣杯布局第一步 有了基本的大结构，现在可以把中间部分的三列加进去，并将它们设置为 由于占据了100%的宽度，所以left和right只能放在下一排了，同时footer…","fields":{"slug":"/blog/2015/02/10/圣杯布局.html","date":"2015-02-09T16:00:00.000Z"},"frontmatter":{"title":"CSS 圣杯布局","author":["sylvenas"],"categories":"CSS","secert":null}}},{"node":{"id":"fc8e672f-3596-51ae-8664-63dd51efb149","excerpt":"在JavaScript代码中，回调是编写和处理JavaScript程序异步逻辑的最常用的方式，甚至可以说回调是JavaScript中最基础的异步模式，回调函数作为异步的主力军，并且他们不辱使命的完成了自己的任务。 但是回调函数也不是没有缺点。 嵌套回调 考虑代码： 我们很经常见到这样的代码，这里我们三个函数嵌套在一起构成链，其中每个函数代表异步序列(任务)中的一个步骤。 这种代码常常被称为回调地狱(callback hell),有时候也被称为毁灭金字塔(pyramid of doom…","fields":{"slug":"/blog/2015/02/03/call-back.html","date":"2015-02-02T16:00:00.000Z"},"frontmatter":{"title":"Call Back","author":["Sylvenas"],"categories":"Async","secert":null}}},{"node":{"id":"22ebea68-3265-5bcd-8b9a-8c2cd26167c0","excerpt":"事实上，程序中的部门和的部分之间的关系就是异步编程的核心，毫无疑问，从一开始，Javascript就是涉及到异步编程，但是多数JavaScript…","fields":{"slug":"/blog/2015/01/12/js-async.html","date":"2015-01-11T16:00:00.000Z"},"frontmatter":{"title":"JS单线程异步","author":["Sylvenas"],"categories":"Async","secert":null}}},{"node":{"id":"f00d8974-bf24-548c-a684-ee13f2a75b91","excerpt":"水平居中 子元素是行内元素(inline)或者inline-block, inline-table, inline-flex 父元素直接设置 子元素是块级元素 子元素直接设置 父元素设置,子元素设置 注意这个时候需要子元素需要设置一个宽度(如果子元素不设置宽度的话，块级元素的宽度将是100%，也就不需要所谓的水平居中了) 多个块级子元素 如果有多个块级子元素需要居中对齐，最好的方法就是把多个子元素全部设置为,然后父元素设置 垂直居中 子元素是行内元素(inline)或者inline-block…","fields":{"slug":"/blog/2014/12/17/CSS-center.html","date":"2014-12-16T16:00:00.000Z"},"frontmatter":{"title":"CSS实现元素水平垂直居中","author":["sylvenas"],"categories":"CSS","secert":null}}},{"node":{"id":"fb88989f-54e2-531c-9bf4-69f921f86c1b","excerpt":"CSS中是一个比较让人疑惑的属性，在平常的印象中，float大多数时候用来实现多列布局，还有float会莫名其妙的影响到他的邻居元素，以及作用于自身的。 float的本意 CSS是相当灵活的语言，要想实现某个效果，可能有好多种方法，那么究竟应该使用哪一种呢，目前统一的判断标准，例如：重绘，回流，极简主义等等，在现在的代码中，存在大量的CSS使用违反了该CSS属性被创造时的本意，例如属性用来规定元素中的文本的水平对齐方式，可是这个属性也被大量的应用在,'inline-block…","fields":{"slug":"/blog/2014/09/15/css-float.html","date":"2014-09-14T16:00:00.000Z"},"frontmatter":{"title":"CSS float 详解","author":["Sylvenas"],"categories":"CSS","secert":null}}},{"node":{"id":"3996d4e7-ee96-5b0a-ac89-2a40e9c18090","excerpt":"我成为今天的我，是在197…","fields":{"slug":"/blog/2014/05/23/追风筝的人.html","date":"2014-05-22T16:00:00.000Z"},"frontmatter":{"title":"追风筝的人","author":["sylvenas"],"categories":"Life","secert":null}}},{"node":{"id":"9883b2db-4bfd-53c5-b7bb-7b20e8a3a8aa","excerpt":"开始支持正则表达式，其语法和其他语言的正则表达式语法很类似，一个完整的正则表达式结构如下： 其中，模式(pattern)部分可以是任何简单或复杂的正则表达式，可以包含字符型、限定符、分组、向前查找以及反向查找。 每个正则表达式都可带有亦或多个标志(flags),用以标明正则表达式的行为，正则表达式支持下列3个标志： g - 表示全局(global)模式，即模式将被应用到所有的字符串，而非在发现第一个匹配项时立即停止。 i — 表示不区分大小写(case-insensitive…","fields":{"slug":"/blog/2014/05/06/RegExp.html","date":"2014-05-05T16:00:00.000Z"},"frontmatter":{"title":"JavaScript Regular Expression","author":["sylvenas"],"categories":"JavaScript","secert":null}}},{"node":{"id":"1b482d49-9a9a-52df-a552-9c6830459d13","excerpt":"JavaScript有很多个内置对象，像是String,Number这类，我们深入了解一下内置对象，下面列出JS中常见的内置对象。 String Boolean Number Object Function Array Date Error RegExp Symbol   // ES6 如果在浏览器中,还有各类的HTMLDomElement,ES…","fields":{"slug":"/blog/2014/04/03/js-natives.html","date":"2014-04-02T16:00:00.000Z"},"frontmatter":{"title":"JS内置对象理解","author":["sylvenas"],"categories":"JavaScript","secert":null}}},{"node":{"id":"e46a45df-76d9-5e3d-b187-0870faafbc6f","excerpt":"内凹圆角 常用的视觉难题内凹圆角： File Upload Button","fields":{"slug":"/blog/2014/02/10/photos.html","date":"2014-02-09T16:00:00.000Z"},"frontmatter":{"title":"Photos Wall","author":["sylvenas"],"categories":"Design","secert":null}}},{"node":{"id":"ca36d250-5d90-534d-893c-34b69f5f20ea","excerpt":"…","fields":{"slug":"/blog/2013/06/17/挪威的森林.html","date":"2013-06-16T16:00:00.000Z"},"frontmatter":{"title":"挪威的森林","author":["sylvenas"],"categories":"Life","secert":null}}},{"node":{"id":"08744ffe-36f5-5467-b4fd-5d96c9eb73ef","excerpt":"CSS使用方法 link 标记 link必须放在head元素中，绝不能放在其他元素内部,因为link标记用来链接外部的样式，所以也被成为外部样式表 style 元素 可以使用style元素包含样式表，它在文档中单独出现，因为这个样式表嵌套在文档中，所以也被成为文档样式表或者嵌套样式表 @import 与link类似， 用于指示Web浏览器加在一个外部样式表，并在表现HTML文档时使用其样式，唯一的区别在于命令的具体语法和位置。 可以看到，出现在style…","fields":{"slug":"/blog/2013/06/12/CSS.html","date":"2013-06-11T16:00:00.000Z"},"frontmatter":{"title":"CSS基础知识","author":["sylvenas"],"categories":"CSS","secert":null}}}]}},"pageContext":{}},"staticQueryHashes":[]}