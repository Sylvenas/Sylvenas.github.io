webpackJsonp([0xea50c5a5855],{692:function(s,n){s.exports={data:{markdownRemark:{html:'<p>JavaScript里有个太常见的<code class="gatsby-code-text">this</code>关键字，不过却有很多的开发人员弄不懂<code class="gatsby-code-text">this</code>关键字在不同的环境中的指向，也弄不清楚应该怎样使用这个关键字。</p>\n<p>当你彻底理解了<code class="gatsby-code-text">闭包</code>和<code class="gatsby-code-text">this</code>的时候，你也就弄明白了JavaScript的核心精髓了。</p>\n<p>在理解this的绑定之前，首先要理解调用位置：调用位置就是函数在代码中的调用位置(此处绝不是说函数的声明位置)，这个过程中最重要是分析函数的调用栈(就是为了到达当前调用位置所调用的所有的函数)。</p>\n<p>我们首先来看看关于<code class="gatsby-code-text">this</code>两种常见的<strong>误解</strong>:</p>\n<h4 id="指向自身"><a href="#%E6%8C%87%E5%90%91%E8%87%AA%E8%BA%AB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>指向自身</h4>\n<p>很多人认为<code class="gatsby-code-text">this</code>是指向的函数自身！为什么要从函数的内部引用函数自身呢？最常见的用处是递归。看看下面的代码：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'foo: \'</span><span class="token operator">+</span> num<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token operator">++</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\nfoo<span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>\n\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo： 1</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo： 2</span>\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo： 3</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>foo<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token comment">// 0 .. why?</span></code></pre>\n      </div>\n<p>上面的代码显然<code class="gatsby-code-text">foo</code>函数执行了三次，但是<code class="gatsby-code-text">foo.count</code>的结果还是<code class="gatsby-code-text">0</code>，那么说明函数内的<code class="gatsby-code-text">this</code>指向函数本身这种观点显然是错误的。</p>\n<p>那么我们代码内的<code class="gatsby-code-text">count</code>,到底是谁的<code class="gatsby-code-text">count</code>呢？实际上我们是隐式的创建了一个全局变量<code class="gatsby-code-text">count</code>，初始化的值是<code class="gatsby-code-text">undefined</code>,执行<code class="gatsby-code-text">++</code>操作的时候就会变成<code class="gatsby-code-text">NaN</code>;</p>\n<h4 id="它的作用域"><a href="#%E5%AE%83%E7%9A%84%E4%BD%9C%E7%94%A8%E5%9F%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>它的作用域</h4>\n<p>第二种常见的误解是，this指向函数的作用域，这个问题有点复杂，因为在有些情况下它是正确的，而在有些情况下它是错误的。</p>\n<p>在JavaScript内部，作用域确实和对象类似，可见的标识符都是它的属性。但是作用域“对象”无法通过JavaScript代码访问，它仅仅存在于JavaScript内部。</p>\n<p>思考一下下面的代码，它试图(但是没有成功)跨越边界，使用this来隐式引用函数的词法作用域。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//referenceError:a is not defined</span></code></pre>\n      </div>\n<p>这段代码的错误不止一个，虽然这段代码看起来好像是我们故意写出来的例子，这段代码非常完美的展示了<code class="gatsby-code-text">this</code>多么容易误导人。</p>\n<p>首先这段代码试图通过<code class="gatsby-code-text">this.bar</code>来引用<code class="gatsby-code-text">bar()</code>函数。这样调用能成功纯属意外,我们之后会解释原因。调用bar函数最自然的方式是声落前面的this,直接使用词法引用标识符。</p>\n<p>此外，这段代码还试图使用this,来联通foo和bar的作用域，从而让bar可以访问到foo作用域中的变量a,这是不可能实现的，使用this,不可能在词法作用域中查到什么</p>\n<h4 id="this到底是什么"><a href="#this%E5%88%B0%E5%BA%95%E6%98%AF%E4%BB%80%E4%B9%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>this到底是什么</h4>\n<p>this是在运行时进行绑定的，并不是在编写时绑定，它的上下文取决于函数调用时的各种条件。this的绑定和函数声明的位置毫无关系，只取决于函数的调用方式。</p>\n<p><strong>当一个函数被调用的时候，会创建一个<code class="gatsby-code-text">活动记录</code>(也叫<code class="gatsby-code-text">执行上下文</code>)，这个记录会包含函数在哪里被调用(调用栈)，函数的调用方式，传入的参数等信息。<code class="gatsby-code-text">this</code>就是这个记录的一个属性，它会在函数执行的过程中用到</strong></p>\n<p><code class="gatsby-code-text">this</code>的运行机制不是那么的容易让人理解，下面，我会尽量解释清楚不同环境下的<code class="gatsby-code-text">this</code>，首先我们从<code class="gatsby-code-text">global</code> environment开始(确保你已经安装了<code class="gatsby-code-text">node</code>,然后打开node command)。</p>\n<h4 id="this-in-global-environment-默认绑定"><a href="#this-in-global-environment-%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>‘this’ in Global Environment (默认绑定)</h4>\n<p>在全局环境下，<code class="gatsby-code-text">this</code>就完全等于一个叫<code class="gatsby-code-text">global</code>的全局对象</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token operator">></span> <span class="token keyword">this</span> <span class="token operator">===</span> global\n<span class="token comment">//true</span></code></pre>\n      </div>\n<p>但是上面的代码，只有在node command中成立。如果我们尝试在一个JS文件中运行上面的代码，则会返回false,为了测试这个代码，创建一个<code class="gatsby-code-text">index.js</code>文件，然后里面的代码写:</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> global<span class="token punctuation">)</span></code></pre>\n      </div>\n<p>然后使用node command运行这个文件</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-cmd"><code class="gatsby-code-cmd">$ node index.js\nfalse</code></pre>\n      </div>\n<p>因为在一个js文件中，<code class="gatsby-code-text">this</code>是完全等于<code class="gatsby-code-text">module.exports</code>的，而不是<code class="gatsby-code-text">global</code></p>\n<h4 id="this-inside-functions-默认绑定"><a href="#this-inside-functions-%E9%BB%98%E8%AE%A4%E7%BB%91%E5%AE%9A" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>‘this’ inside Functions (默认绑定)</h4>\n<p>函数内部的<code class="gatsby-code-text">this</code>一般是由函数的调用者来决定的，所以在函数每次执行的时候，其内部的<code class="gatsby-code-text">this</code>可能都不一样。</p>\n<p>在<code class="gatsby-code-text">index.js</code>文件中写一个简单的函数，来检查一下函数内部的<code class="gatsby-code-text">this</code>是不是等于<code class="gatsby-code-text">global</code>：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> global<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>如果我们用node执行上面的代码，我们将会看到打印出来<code class="gatsby-code-text">true</code>,但是如果我们在index.js的头部添加<code class="gatsby-code-text">use strict</code>,然后再次运行index.js，这个时候，会打印出来<code class="gatsby-code-text">false</code>,因为这个时候，函数内部的<code class="gatsby-code-text">this</code>是<code class="gatsby-code-text">undefined</code>。</p>\n<p>那么为什么<code class="gatsby-code-text">test</code>在非严格模式下调用的时候，内部的this,是<code class="gatsby-code-text">global</code>呢？因为这其中发生了<strong>默认绑定</strong>，什么情况下会发生默认绑定呢？就是<code class="gatsby-code-text">test()</code>是直接使用<strong>不带任何修饰符的函数引用进行调用的</strong>，因此只能使用默认绑定到全局<code class="gatsby-code-text">global</code>对象上。</p>\n<p>为了更加仔细的了解这一点，我们看另外一个例子,我们有一个函数用来创建超级英雄的真名和绰号</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">Hero</span><span class="token punctuation">(</span>heroName<span class="token punctuation">,</span>realName<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>realName <span class="token operator">=</span> realName<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>heroName <span class="token operator">=</span> heroName<span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> superman <span class="token operator">=</span> <span class="token function">Hero</span><span class="token punctuation">(</span><span class="token string">\'Superman\'</span><span class="token punctuation">,</span><span class="token string">\'Clart\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>superman<span class="token punctuation">)</span></code></pre>\n      </div>\n<p>上面的代码不是在严格模式(<code class="gatsby-code-text">use strict</code>)下运行的,在node下运行这段代码，将会打印出来<code class="gatsby-code-text">undefined</code>，而不是我们期望的<code class="gatsby-code-text">Superman</code>和<code class="gatsby-code-text">Clart</code>。</p>\n<p>其中的原因就是我们这段代码不是在严格模式下运行的，函数内的<code class="gatsby-code-text">this</code>就是<code class="gatsby-code-text">global</code>对象</p>\n<p>但是如果我们在严格模式下运行这段代码，我们将会得到一个错误，因为JavaScript不允许给<code class="gatsby-code-text">undefined</code>添加属性(这可以帮助我们，避免创建全局变量)。</p>\n<p>最后，函数的首字母大些，意味着这个函数是一个构造函数，我们应该用一个<code class="gatsby-code-text">new</code>操作符来调用函数。替换最后两行代码如下：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> superman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token string">\'Superman\'</span><span class="token punctuation">,</span><span class="token string">\'Clart\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>superman<span class="token punctuation">)</span></code></pre>\n      </div>\n<p>这个时候再次运行index.js,就可以得到我们预期的结果</p>\n<h4 id="this-inside-constructors-new-绑定"><a href="#this-inside-constructors-new-%E7%BB%91%E5%AE%9A" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>‘this’ inside constructors (new 绑定)</h4>\n<p>JavaScript本身根本没有特殊的<code class="gatsby-code-text">constructor</code>函数,我们所做不过是使用<code class="gatsby-code-text">new</code>操作符来替换函数调用。</p>\n<p>当我们使用<code class="gatsby-code-text">new</code>操作符，调用一个构造函数的时候，实际上就是创建一个新的对象，并把函数内部的<code class="gatsby-code-text">this</code>赋值为这个对象，然后这个对象会被函数隐式的返回(除非有另外一个对象或者函数被显式的返回)。</p>\n<p>在<code class="gatsby-code-text">Hero</code>函数的最后添加代码：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">return</span> <span class="token punctuation">{</span>\n    heroName<span class="token punctuation">:</span><span class="token string">\'Batman\'</span><span class="token punctuation">,</span>\n    realname<span class="token punctuation">:</span><span class="token string">\'Bruce Wayne\'</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>我们再次使用node command 运行index.js，我们会发现得到的结果<code class="gatsby-code-text">superman</code>被替换成了<code class="gatsby-code-text">{heroName:&#39;Batman&#39;,realname:&#39;Bruce Wayne&#39;}</code>。但是如果我们显式的return任何非对象类型和非函数类型的数据，则最后的结果不会被显式的替换掉。</p>\n<h4 id="this-in-method-隐式绑定"><a href="#this-in-method-%E9%9A%90%E5%BC%8F%E7%BB%91%E5%AE%9A" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>‘this’ in Method (隐式绑定)</h4>\n<p>当一个函数作为对象的属性方法来调用的时候，函数内部的<code class="gatsby-code-text">this</code>就指向对象本身。</p>\n<p>看个例子，在对象<code class="gatsby-code-text">hero</code>中有一个方法<code class="gatsby-code-text">dialogue</code>,<code class="gatsby-code-text">dialogue</code>的<code class="gatsby-code-text">this</code>就是指向<code class="gatsby-code-text">hero</code>自身，<code class="gatsby-code-text">hero</code>对象会被认为是方法<code class="gatsby-code-text">dialogue</code>的调用者。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> hero <span class="token operator">=</span> <span class="token punctuation">{</span>\n    heroName<span class="token punctuation">:</span><span class="token string">"Batman"</span><span class="token punctuation">,</span>\n    <span class="token function">dialogue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`I am </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>heroName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\nhero<span class="token punctuation">.</span><span class="token function">dialogue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>这是一个简单的例子，但是在真实的世界中，有时候我们很难确定方法的调用者，看看如下的代码：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> saying <span class="token operator">=</span> hero<span class="token punctuation">.</span>dialogue<span class="token punctuation">;</span>\n<span class="token function">saying</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>在这段代码中，把<code class="gatsby-code-text">hero.dialogue</code>方法赋值给另一个变量<code class="gatsby-code-text">saying</code>,然后把这个变量当作一个方法来调用，在node中运行这段代码，就会发现这个时候<code class="gatsby-code-text">this.heroName</code>会变成<code class="gatsby-code-text">undefined</code>,这是因为这个时候方法丢失了它的调用者，这种情况下的<code class="gatsby-code-text">this</code>会指向<code class="gatsby-code-text">global</code>,而不是<code class="gatsby-code-text">hero</code>。</p>\n<p>方法的调用者丢失的情况经常发生在，我们把一个方法作为callback传递给定外一个的时候，这个时候我们可以利用闭包，或者通过<code class="gatsby-code-text">bind</code>到我们想要的对象。</p>\n<h4 id="call-and-apply-强制绑定"><a href="#call-and-apply-%E5%BC%BA%E5%88%B6%E7%BB%91%E5%AE%9A" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>call and apply (强制绑定)</h4>\n<p>通常情况下函数的<code class="gatsby-code-text">this</code>都是隐式的被设定的，但是我们也可以显式的使用<code class="gatsby-code-text">call</code>和<code class="gatsby-code-text">apply</code>方法来设置方法内部的<code class="gatsby-code-text">this</code>。\n看看下面的代码：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">dialogue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`I am </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>heroName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> hero <span class="token operator">=</span> <span class="token punctuation">{</span> heroName<span class="token punctuation">:</span><span class="token string">\'Batman\'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>如果我想把<code class="gatsby-code-text">hero</code>对象作为<code class="gatsby-code-text">dialogue</code>函数的调用者，我们可以这么做：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">dialogue<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>hero<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// or</span>\ndialogue<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>hero<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>如果你在严格模式之外使用<code class="gatsby-code-text">call</code>和<code class="gatsby-code-text">apply</code>,并且传入的参数是<code class="gatsby-code-text">null</code>或者<code class="gatsby-code-text">undefined</code>,这个时候，<code class="gatsby-code-text">null</code>和<code class="gatsby-code-text">undefined</code>会被JavaScript engine 忽落掉。所以建议大家在严格模式下写代码。</p>\n<h4 id="bind-强制绑定"><a href="#bind-%E5%BC%BA%E5%88%B6%E7%BB%91%E5%AE%9A" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>bind (强制绑定)</h4>\n<p>当我们把一个方法作为一个callback,传递给另一个函数的时候，经常会发生丢失this,或者this指向不对的情况。</p>\n<p>这个时候<code class="gatsby-code-text">bind</code>函数就会登场了，<code class="gatsby-code-text">bind</code>函数会创建一个新的函数，并且新的函数内部的<code class="gatsby-code-text">this</code>指向bind的参数。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> hero <span class="token operator">=</span> <span class="token punctuation">{</span>\n    heroName<span class="token punctuation">:</span><span class="token string">"Batman"</span><span class="token punctuation">,</span>\n    <span class="token function">dialogue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`I am </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>heroName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">setTimeOut</span><span class="token punctuation">(</span>hero<span class="token punctuation">.</span>dialogue<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>hero<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>但是有一点需要注意，通过bind生成的新的函数，内部的<code class="gatsby-code-text">this</code>是固定的，无法通过<code class="gatsby-code-text">call</code>或者<code class="gatsby-code-text">apply</code>进行修改。</p>\n<h4 id="catching-this-inside-an-arrow-function-lexical-scope"><a href="#catching-this-inside-an-arrow-function-lexical-scope" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Catching ‘this’ inside an Arrow Function (lexical scope)</h4>\n<p>箭头函数中<code class="gatsby-code-text">this</code>和其他JavaScript中函数大不相同，箭头函数本身没有属于自己的<code class="gatsby-code-text">this</code>,而是获取定义的时候的上下文作为自己的<code class="gatsby-code-text">this</code>。</p>\n<p>箭头函数在定义的时候，已经确定了<code class="gatsby-code-text">this</code>的指向，使用call和apply，也无法改变箭头函数内部的<code class="gatsby-code-text">this</code>。</p>\n<p>为了演示箭头函数内的<code class="gatsby-code-text">this</code>工作原理，我们看一下下面的例子：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> batman <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> <span class="token function-variable function">burce</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> batman<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token function">burce</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>我们先把<code class="gatsby-code-text">this</code>赋值给一个变量<code class="gatsby-code-text">batman</code>,然后在箭头函数内部比较函数内的<code class="gatsby-code-text">this</code>和<code class="gatsby-code-text">batman</code>，我们发现两者完全相同 。</p>\n<p>箭头函数内部的<code class="gatsby-code-text">this</code>无法被显式的设置，同样的箭头函数会忽略来自<code class="gatsby-code-text">call</code>、<code class="gatsby-code-text">apply</code>和<code class="gatsby-code-text">bind</code>传递的第一个参数,箭头函数内部的<code class="gatsby-code-text">this</code>始终指向创建时，所在的上下文环境。</p>\n<p>箭头函数无法作为构造函数来使用，也是因为我们无法重新分配函数内部的<code class="gatsby-code-text">this</code>。</p>\n<p>那么箭头函数内部的<code class="gatsby-code-text">this</code>到底有什么用处呢？</p>\n<p>箭头函数可以帮助我们在callback中访问到正确的<code class="gatsby-code-text">this</code>，看下面的这个例子：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> counter <span class="token operator">=</span> <span class="token punctuation">{</span>\n    count<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span>\n    <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">++</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">)</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\ncounter<span class="token punctuation">.</span><span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>通过<code class="gatsby-code-text">node index.js</code>来执行上面的代码，我们只会得到<code class="gatsby-code-text">NaN</code>,这是因为<code class="gatsby-code-text">this.count</code>并不是指向的<code class="gatsby-code-text">counter</code>对象内部的<code class="gatsby-code-text">count</code>属性，而是只想的<code class="gatsby-code-text">global.count</code>。那么结果不言而喻。</p>\n<p>现在使用箭头函数改写我们的代码：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> counter <span class="token operator">=</span> <span class="token punctuation">{</span>\n    count<span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">,</span>\n    <span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token operator">++</span><span class="token keyword">this</span><span class="token punctuation">.</span>count<span class="token punctuation">)</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\ncounter<span class="token punctuation">.</span><span class="token function">increase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>现在的情况是箭头函数在定义的时候，自动捕获了<code class="gatsby-code-text">increase</code>函数内的<code class="gatsby-code-text">this</code>,也就是<code class="gatsby-code-text">counter</code>对象，这个时候记事起就能正常工作了。</p>\n<h4 id="this-in-classes-new-绑定"><a href="#this-in-classes-new-%E7%BB%91%E5%AE%9A" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>‘this’ in Classes (new 绑定)</h4>\n<p><code class="gatsby-code-text">class</code>现在是JavaScript中非常重要的一员了，下面看看<code class="gatsby-code-text">class</code>中的this是怎么工作的。</p>\n<p>每一个<code class="gatsby-code-text">class</code>都包含一个<code class="gatsby-code-text">constructor</code>,在该构造函数内的<code class="gatsby-code-text">this</code>指向的是新创建的对象。</p>\n<p>和对象属性上的方法一样，<code class="gatsby-code-text">class</code>内方法的<code class="gatsby-code-text">this</code>也可以指定为其他的value,同样的，有时候也会丢失<code class="gatsby-code-text">this</code>。</p>\n<p>我们使用<code class="gatsby-code-text">class</code>来重新创建上面的<code class="gatsby-code-text">Hero</code>：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">class</span> <span class="token class-name">Hero</span> <span class="token punctuation">{</span>\n    <span class="token function">constructor</span><span class="token punctuation">(</span>heroName<span class="token punctuation">)</span><span class="token punctuation">{</span>\n        <span class="token keyword">this</span><span class="token punctuation">.</span>heroName <span class="token operator">=</span> heroName<span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token function">dialogue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`I am </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>heroName<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">const</span> batman <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Hero</span><span class="token punctuation">(</span><span class="token string">\'Batman\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nbatman<span class="token punctuation">.</span><span class="token function">dialogue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p><code class="gatsby-code-text">constructor</code>内的<code class="gatsby-code-text">this</code>就等于新创建的实例<code class="gatsby-code-text">batman</code>,当我们调用<code class="gatsby-code-text">batman.dialogue()</code>的时候，<code class="gatsby-code-text">batman</code>是作为<code class="gatsby-code-text">dialogue</code>方法的调用者。</p>\n<p>不过当我们把<code class="gatsby-code-text">batman.dialogue</code>赋值给另外一个变量的时候，然后把这个变量作为一个函数来调用，毫无疑问，我们将会再次丢失函数内部的<code class="gatsby-code-text">this</code>,这个时候方法内的this,实际上指向的是<code class="gatsby-code-text">undefined</code>。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> say <span class="token operator">=</span> batman<span class="token punctuation">.</span>dialogue<span class="token punctuation">;</span>\n<span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>为什么会这样呢？因为<code class="gatsby-code-text">class</code>内的代码是隐式的在严格模式下执行的。我们直接调用了<code class="gatsby-code-text">say()</code>,而没有绑定任何<code class="gatsby-code-text">this</code>,为了解决这个问题，可以采用<code class="gatsby-code-text">bind</code>方法，来绑定函数内部的this。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> say <span class="token operator">=</span> batman<span class="token punctuation">.</span>dialogue<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span>batman<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">say</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>也可以在<code class="gatsby-code-text">class</code>的<code class="gatsby-code-text">constructor</code>中进行预先绑定好：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token function">constructor</span><span class="token punctuation">(</span>heroName<span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>heroName <span class="token operator">=</span> heroName<span class="token punctuation">;</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>dialogue <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dialogue<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<h3 id="solution"><a href="#solution" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>solution</h3>\n<p>上面讲解了各种情况下的<code class="gatsby-code-text">this</code>的绑定机制，那么到底如何确定一个函数内部的<code class="gatsby-code-text">this</code>的指向呢？</p>\n<ul>\n<li>函数是否在<code class="gatsby-code-text">new</code>操作符中调用(new 绑定)，如果是：<code class="gatsby-code-text">this</code>绑定的就是新创建的对象；<code class="gatsby-code-text">var bar = new Foo()</code></li>\n<li>函数是否通过<code class="gatsby-code-text">call</code>,<code class="gatsby-code-text">apply</code>(显式绑定)调用？如果是：<code class="gatsby-code-text">this</code>绑定的是制定的对象; <code class="gatsby-code-text">var bar = foo.call(obj)</code></li>\n<li>函数是否在某个<code class="gatsby-code-text">上下文对象</code>中调用(隐式绑定)？如果是：<code class="gatsby-code-text">this</code>绑定的就是当前的上下文对象：<code class="gatsby-code-text">var bar = obj.foo()</code></li>\n<li>如果都不是的话，那么就会使用默认绑定，也就是全局对象<code class="gatsby-code-text">global</code>;如果是在严格模式下，就是绑定到<code class="gatsby-code-text">undefined</code>; <code class="gatsby-code-text">var bar = foo()</code></li>\n</ul>',
frontmatter:{title:"What is 'this' in JavaScript",img:"./img/2018-06-24.jpg",author:["Sylvenas"],excerpt:null,catalogue:null},fields:{date:"June 23, 2018",path:"blog/javascript/2018-06-24-this.md",slug:"/blog/2018/06/24/this.html"}},allMarkdownRemark:{edges:[{node:{frontmatter:{title:"React Hooks 原理及实现"},fields:{slug:"/blog/2021/03/30/react-hooks.html"}}},{node:{frontmatter:{title:"被讨厌的勇气"},fields:{slug:"/blog/2020/05/14/被讨厌的勇气.html"}}},{node:{frontmatter:{title:"自然变换 - Natural Transformation"},fields:{slug:"/blog/2020/05/02/自然变换.html"}}},{node:{frontmatter:{title:"遍历与队列 - Traversable"},fields:{slug:"/blog/2020/04/25/遍历与队列.html"}}},{node:{frontmatter:{title:"加法是自然之道 - Monoid"},fields:{slug:"/blog/2020/03/02/加法是自然之道.html"}}},{node:{frontmatter:{title:"俄罗斯套娃娃 - Monad"},fields:{slug:"/blog/2020/02/12/俄罗斯套娃娃.html"}}},{node:{frontmatter:{title:"纪念刘和珍君"},fields:{slug:"/blog/2020/02/07/记念刘和珍君.html"}}},{node:{frontmatter:{title:"应用函子 - Applicative"},fields:{slug:"/blog/2020/02/05/应用函子.html"}}},{node:{frontmatter:{title:"动物庄园"},fields:{slug:"/blog/2020/02/01/动物庄园.html"}}},{node:{frontmatter:{title:"薛定谔的 Maybe - IO"},fields:{slug:"/blog/2020/01/30/薛定谔的Maybe.html"}}}]}},pathContext:{slug:"/blog/2018/06/24/this.html"}}}});