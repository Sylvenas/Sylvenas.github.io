webpackJsonp([0x97701fdd31e5],{722:function(e,s){e.exports={data:{markdownRemark:{html:'<h3 id="rem布局"><a href="#rem%E5%B8%83%E5%B1%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>rem布局</h3>\n<h4 id="lib-flexible"><a href="#lib-flexible" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>lib-flexible</h4>\n<p>假设设计MM给我们的设计稿尺寸为<code class="gatsby-code-text">750 x 1340</code>，那么我们前端拿到设计稿之后要如何动手开始开发呢？经过上面的介绍了移动端开发的基本概念之后，应该有了一些基本的思路，我们可以使用js动态计算rem的方案来实现。</p>\n<p>rem是根据html节点的font-size来做计算的</p>\n<p>举个例子：假如html元素的font-size为 <code class="gatsby-code-text">Npx</code>,一个元素的宽度设定为<code class="gatsby-code-text">2rem</code>;则该元素的实际宽度为：<code class="gatsby-code-text">2 * N px</code>；</p>\n<p>换句话说px与rem的一定是成正比关系的。</p>\n<p>那么既然设计MM给我们的设计稿尺寸为<code class="gatsby-code-text">750 x 1340</code>，那么我们完全可以把屏幕的布局视口平均分为750份；设计稿中的某个元的宽度直接按照，占了750份中的多少份来计算就可以了。</p>\n<p>举例：\niPhone6的布局视口宽度为<code class="gatsby-code-text">document.documentElement.clientWidth = 375px</code>分为750份，则每份的宽度为<code class="gatsby-code-text">375px/750 = 0.5px</code>;并把<code class="gatsby-code-text">0.5px</code>设置为html元素的<code class="gatsby-code-text">font-size</code>;</p>\n<p>现在有一个元素的宽度为<code class="gatsby-code-text">20px</code>,则只需要把元素的宽度用CSS编写为<code class="gatsby-code-text">20rem</code>即可！</p>\n<p>因为<code class="gatsby-code-text">20px</code>，相对于平均分成<code class="gatsby-code-text">750</code>份之后,确实是只占了<code class="gatsby-code-text">20</code>份，每份是<code class="gatsby-code-text">0.5rem</code>。</p>\n<p><strong>但是我们这样做了之后就会发现有问题啊，为何结果没有达到我们的预期呢？至少从数学计算的角度来说，我们的逻辑没问题！</strong></p>\n<p>那么问题出在哪里呢？</p>\n<p><strong>是浏览器在作妖！chrome的浏览器所允许的最小<code class="gatsby-code-text">font-size</code>为<code class="gatsby-code-text">12px</code>,所以我们设置了html元素的<code class="gatsby-code-text">font-size=.5px</code>是被忽略的，并且被重置为了<code class="gatsby-code-text">12px</code></strong></p>\n<p>那么我们再次运用小学数学知识，只要把html元素的<code class="gatsby-code-text">font-size</code>等比例扩大100倍，然后元素的大小在缩小100倍不就可以解决这个问题啦！</p>\n<p>所以我们把html元素的<code class="gatsby-code-text">font-size = 50px</code>,然后元素的宽度设定为<code class="gatsby-code-text">.2rem</code>，这样在计算之后不就没问题啦！</p>\n<p>现在总结一下计算公式：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// html元素的font-size大小，单位：px</span>\n<span class="token keyword">const</span> htmlFontSize <span class="token operator">=</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientWidth <span class="token operator">/</span> <span class="token number">750</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">;</span>\n\n<span class="token comment">// 普通元素宽度，单位：rem</span>\n<span class="token keyword">const</span> eleWidth <span class="token operator">=</span> <span class="token punctuation">(</span>设计稿宽度<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>如果上面的换算觉得还是麻烦，可以借助<code class="gatsby-code-text">postCss</code>的插件<code class="gatsby-code-text">px2rem</code>来帮助我们完成换算，我们在代码中直接写px就可以了！</p>\n<p>其实这也是阿里巴巴<code class="gatsby-code-text">lib-flexible</code>的大概实现原理！</p>\n<h4 id="rem的缺陷"><a href="#rem%E7%9A%84%E7%BC%BA%E9%99%B7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>rem的缺陷</h4>\n<p>rem是弹性布局的一种实现方式，弹性布局可以算作响应式布局的一种，但响应式布局不是弹性布局，弹性布局强调等比缩放，100%还原；响应式布局强调不同屏幕要有不同的显示，比图媒体查询。</p>\n<p>一般内容型的网站，都不太使用使用rem,因为大屏用户可以自己选择要更大的字体，还是更多的内容，一旦使用了rem，就剥夺了用户的自由；一些偏向App类型的，图标类的，图片类的，比如：淘宝，活动页面，比较适合使用rem,因为调大字体时并不能调大图片的大小。同时rem存在一下问题：</p>\n<ul>\n<li><strong>字体问题</strong> - 字体大小并不能使用rem,字体的大小和字体宽度并不成正比关系，这个关系完全取决于字体的作者。所以字体大小不能使用rem。</li>\n<li><strong>PC浏览</strong> - 如果用户在PC段浏览页面怎么办？一般我们都会设置一个最大宽度，大于这个宽度的话，页面居中，两边留白，或者直接跳PC页面</li>\n</ul>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> clientWidth <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientWidth<span class="token punctuation">;</span>\nclientWidth <span class="token operator">=</span> clientWidth <span class="token operator">&lt;</span> <span class="token number">780</span> <span class="token operator">?</span> clientWidth <span class="token punctuation">:</span> <span class="token number">780</span><span class="token punctuation">;</span>\ndocument<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> clientWidth <span class="token operator">/</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token string">\'px\'</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>设置body的宽度为100rem，并水平居中:</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-css"><code class="gatsby-code-css"><span class="token selector">body</span> <span class="token punctuation">{</span>\n    <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>\n    <span class="token property">width</span><span class="token punctuation">:</span> 100rem\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<h3 id="vh、vw方案"><a href="#vh%E3%80%81vw%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>vh、vw方案</h3>\n<p>vh、vw方案即将视觉视口宽度<code class="gatsby-code-text">window.innerWidth</code>和视觉视口宽度<code class="gatsby-code-text">window.innerHeight</code>等分为100份。</p>\n<p>本质上来说，<code class="gatsby-code-text">flexible</code>方案就是模仿这种方案，随着浏览器兼容性的进步，<code class="gatsby-code-text">vh、vw</code>方案已经可以直接用了。</p>\n<p>\n  <a\n    class="gatsby-resp-image-link"\n    href="/static/vw-vh-5379a182408150a2dce7cf759fa14c00-1d83a.png"\n    style="display: block"\n    target="_blank"\n    rel="noopener"\n  >\n  \n  <span\n    class="gatsby-resp-image-wrapper"\n    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"\n  >\n    <span\n      class="gatsby-resp-image-background-image"\n      style="padding-bottom: 48.36309523809524%; position: relative; bottom: 0; left: 0; background-image: url(\'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABcklEQVQoz31Sf2uCUBT1+3+GbcQgIvqr0SA3ptCvRRCUTslW1mowjcraKrXUs/feTH0Fe3C5713PPffcexXCMITruszonZ4oijhP45cWBAHzFJMaIHQ6HeTzeRQKBTQaDQ6QJf3vZPECJdF1HaZpQpIk2ItFAjwrVtU31OsN5nu9Pvp9BbVaHYYxxOkUcMQCJTsfVVVhWRY8z8PxeEyq5nL3aDZbrM3NZoP9fo9K5RHSiwzHoe8Dy2EKNU1LEimhbdtYLlfY7fZJodubO2iazrVZrYrEnuAeXKxWa2y333+E3W6XBFZsKe12mym8bLlcfoAoPmM6/cBgYGBovDOFrdYrUbzlW5ZlGcViEaVSiSSJ2P3srgbt+z4mkynGI5ORjkZjzOefRIR3vZTZbAZFUVi7pjnhql1umc7K+rLJfE8pDjEufgvnQa9J277nZyrGZFGqICRG8dyvlflO7wIlOJDKztpBFMYA5lNwGkNiCTbi47+f4vfotZzyxAAAAABJRU5ErkJggg==\'); background-size: cover; display: block;"\n    >\n      <img\n        class="gatsby-resp-image-image"\n        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"\n        alt="vw-vh"\n        title=""\n        src="/static/vw-vh-5379a182408150a2dce7cf759fa14c00-acf85.png"\n        srcset="/static/vw-vh-5379a182408150a2dce7cf759fa14c00-c1418.png 210w,\n/static/vw-vh-5379a182408150a2dce7cf759fa14c00-5d5d8.png 420w,\n/static/vw-vh-5379a182408150a2dce7cf759fa14c00-acf85.png 840w,\n/static/vw-vh-5379a182408150a2dce7cf759fa14c00-de0cd.png 1260w,\n/static/vw-vh-5379a182408150a2dce7cf759fa14c00-1d83a.png 1344w"\n        sizes="(max-width: 840px) 100vw, 840px"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>举例来说：视觉视口为375px,那么<code class="gatsby-code-text">1vw = 3.75px</code>,这时UI给定一个元素的宽为<code class="gatsby-code-text">20px</code>(设备独立像素)，那么我们只要只需要把它设置为<code class="gatsby-code-text">20 / 3.75 = 5.3333vw</code>。</p>\n<p>这里的比例关系我们也不用自己换算，我们可以使用<code class="gatsby-code-text">PostCSS</code>的<code class="gatsby-code-text">postcss-px-viewport</code>插件帮助我们完成这个过程。写代码时，我们只需要根据UI给的设计图写px单位即可.</p>\n<p>没有任何一种方案是完美的，vw,vh也存在一下缺陷：</p>\n<ul>\n<li><code class="gatsby-code-text">px</code>转换成vw不一定能完全整除，因此有一定的像素差。</li>\n<li>当容器使用vw,margin使用px时，很容易造成整体宽度超过100vw,从而影响布局效果。当然我们也是可以避免的，比如使用<code class="gatsby-code-text">padding</code>代替<code class="gatsby-code-text">margin</code>，结合<code class="gatsby-code-text">calc</code>函数使用</li>\n<li>兼容性\n部分机型不支持vw,vh，可以采用csspolyfill来进行降级处理，推荐<a href="https://github.com/rodneyrehm/viewport-units-buggyfill">viewport-units-buggyfill</a></li>\n</ul>',frontmatter:{title:"移动端适配方案rem & vh、vw",img:"./img/2019-05-27.jpeg",author:["sylvenas"],excerpt:null,catalogue:["rem布局","lib-flexible","rem的缺陷","vh、vw方案"]},fields:{date:"May 26, 2019",path:"blog/mobile/2019-05-27-mobile-css.md",slug:"/blog/2019/05/27/mobile-css.html"}},allMarkdownRemark:{edges:[{node:{frontmatter:{title:"shell intro"},fields:{slug:"/blog/2021/06/02/shell-intro.html"}}},{node:{frontmatter:{title:"React Hooks 原理及实现"},fields:{slug:"/blog/2021/03/30/react-hooks.html"}}},{node:{frontmatter:{title:"npm package依赖管理"},fields:{slug:"/blog/2021/03/03/npm-package.html"}}},{node:{frontmatter:{title:"Koa实现原理分析"},fields:{slug:"/blog/2021/02/06/koa.html"}}},{node:{frontmatter:{title:"被讨厌的勇气"},fields:{slug:"/blog/2020/05/14/被讨厌的勇气.html"}}},{node:{frontmatter:{title:"自然变换 - Natural Transformation"},fields:{slug:"/blog/2020/05/02/自然变换.html"}}},{node:{frontmatter:{title:"遍历与队列 - Traversable"},fields:{slug:"/blog/2020/04/25/遍历与队列.html"}}},{node:{frontmatter:{title:"加法是自然之道 - Monoid"},fields:{slug:"/blog/2020/03/02/加法是自然之道.html"}}},{node:{frontmatter:{title:"俄罗斯套娃娃 - Monad"},fields:{slug:"/blog/2020/02/12/俄罗斯套娃娃.html"}}},{node:{frontmatter:{title:"纪念刘和珍君"},fields:{slug:"/blog/2020/02/07/记念刘和珍君.html"}}}]}},pathContext:{slug:"/blog/2019/05/27/mobile-css.html"}}}});