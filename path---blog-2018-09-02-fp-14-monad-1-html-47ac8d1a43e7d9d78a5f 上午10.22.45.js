webpackJsonp([27161055902862],{483:function(n,s){n.exports={data:{markdownRemark:{html:'<h3 id="pointed-functor"><a href="#pointed-functor" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>pointed functor</h3>\n<p>在继续后面的内容之前，我得向你坦白一件事：关于我们先前创建的容器类型上的 of 方法，我并没有说出它的全部实情。真实情况是，of 方法不是用来避免使用 new 关键字的，而是用来把值放到默认最小化上下文（default minimal context）中的。是的，of 没有真正地取代构造器——它是一个我们称之为 pointed 的重要接口的一部分。</p>\n<blockquote>\n<p>pointed functor 是实现了 of 方法的 functor</p>\n</blockquote>\n<p>这里的关键是把任意值丢到容器里然后开始到处使用 map 的能力。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code>IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"tetris"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">" master"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// IO("tetris master")</span>\n\nMaybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">1336</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// Maybe(1337)</span>\n\nEither<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"The past, present and future walk into a bar..."</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>\n  <span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"it was tense."</span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// Right("The past, present and future walk into a bar...it was tense.")</span>\n</code></pre>\n      </div>\n<p>如果你还记得，<code>IO</code>的构造器接受一个函数作为参数，而<code>Maybe</code>和<code>Either</code>的构造器可以接受任意值。实现这种接口的动机是，我们希望能有一种通用、一致的方式往<code>functor</code>里填值，而且中间不会涉及到复杂性，也不会涉及到对构造器的特定要求。“默认最小化上下文”这个术语可能不够精确，但是却很好地传达了这种理念：我们希望容器类型里的任意值都能发生<code>lift</code>，然后像所有的<code>functor</code>那样再<code>map</code>出去。</p>\n<p>有件很重要的事我必须得在这里纠正，那就是，<code>Left.of</code>没有任何道理可言，包括它的双关语也是。每个<code>functor</code>都要有一种把值放进去的方式，对<code>Either</code>来说，它的方式就是<code>new Right(x)</code>。我们为<code>Right</code>定义<code>of</code>的原因是，如果一个类型容器可以<code>map</code>，那它就应该<code>map</code>。看上面的例子，你应该会对<code>of</code>通常的工作模式有一个直观的印象，而<code>Left</code>破坏了这种模式。</p>\n<p>你可能已经听说过<code>pure</code>、<code>point</code>、<code>unit</code>和<code>return</code>之类的函数了，它们都是<code>of</code>这个史上最神秘函数的不同名称。<code>of</code>将在我们开始使用<code>monad</code>的时候显示其重要性，因为后面你会看到，手动把值放回容器是我们自己的责任。</p>\n<p>要避免<code>new</code>关键字，可以借助一些标准的<code>JavaScript</code>技巧或者类库达到目的。所以从这里开始，我们就利用这些技巧或类库，像一个负责任的成年人那样使用<code>of</code>。我推荐使用<code>folktale</code>、<code>ramda</code>或<code>fantasy-land</code>里的<code>functor</code>实例，因为它们同时提供了正确的<code>of</code>方法和不依赖<code>new</code>的构造器。</p>\n<h3 id="mixing-metaphors"><a href="#mixing-metaphors" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mixing Metaphors</h3>\n<p>\n你看，除了太空墨西哥卷，monad 还被喻为洋葱。让我以一个常见的场景来说明这点：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'fs\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// readFile :: String -> IO String</span>\n<span class="token keyword">const</span> readFile <span class="token operator">=</span> filename <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">\'utf-8\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// print :: String -> IO String</span>\n<span class="token keyword">const</span> print <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> x<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// cat :: String -> IO (IO String)</span>\n<span class="token keyword">const</span> cat <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span><span class="token punctuation">,</span> readFile<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">cat</span><span class="token punctuation">(</span><span class="token string">\'.git/config\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// IO(IO(\'[core]\\nrepositoryformatversion = 0\\n\'))</span>\n</code></pre>\n      </div>\n<p>这里我们得到的是一个<code>IO</code>，只不过它陷进了另一个<code>IO</code>。要想使用它，我们必须这样调用：<code>map(map(f))</code>；要想观察它的作用，必须这样：<code>unsafePerformIO().unsafePerformIO()</code>。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// cat :: String -> IO (IO String)</span>\n<span class="token keyword">const</span> cat <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span><span class="token punctuation">,</span> readFile<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// catFirstChar :: String -> IO (IO String)</span>\n<span class="token keyword">const</span> catFirstChar <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cat<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">catFirstChar</span><span class="token punctuation">(</span><span class="token string">\'.git/config\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// IO(IO(\'[\'))</span>\n</code></pre>\n      </div>\n<p>尽管在应用中把这两个作用打包在一起没什么不好的，但总感觉像是在穿着两套防护服工作，结果就形成一个稀奇古怪的<code>API</code>。再来看另一种情况：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// safeProp :: Key -> {Key: a} -> Maybe a</span>\n<span class="token keyword">const</span> safeProp <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> obj<span class="token punctuation">)</span> <span class="token operator">=></span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// safeHead :: [a] -> Maybe a</span>\n<span class="token keyword">const</span> safeHead <span class="token operator">=</span> <span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// firstAddressStreet :: User -> Maybe (Maybe (Maybe Street))</span>\n<span class="token keyword">const</span> firstAddressStreet <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>\n  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">\'street\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">map</span><span class="token punctuation">(</span>safeHead<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">\'addresses\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">firstAddressStreet</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  addresses<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> street<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'Mulburry\'</span><span class="token punctuation">,</span> number<span class="token punctuation">:</span> <span class="token number">8402</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> postcode<span class="token punctuation">:</span> <span class="token string">\'WC2N\'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// Maybe(Maybe(Maybe({name: \'Mulburry\', number: 8402})))</span>\n</code></pre>\n      </div>\n<p>这里的<code>functor</code>同样是嵌套的，函数中三个可能的失败都用了<code>Maybe</code>做预防也很干净整洁，但是要让最后的调用者调用三次<code>map</code>才能取到值未免也太无礼了点——我们和它才刚刚见面而已。这种嵌套<code>functor</code>的模式会时不时地出现，而且是<code>monad</code>的主要使用场景。</p>\n<p>我说过<code>monad</code>像洋葱，那是因为当我们用<code>map</code>剥开嵌套的<code>functor</code>以获取它里面的值的时候，就像剥洋葱一样让人忍不住想哭。不过，我们可以擦干眼泪，做个深呼吸，然后使用一个叫作<code>join</code>的方法。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> mmo <span class="token operator">=</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">\'nunchucks\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// Maybe(Maybe(\'nunchucks\'))</span>\n\nmmo<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// Maybe(\'nunchucks\')</span>\n\n<span class="token keyword">const</span> ioio <span class="token operator">=</span> IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">\'pizza\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// IO(IO(\'pizza\'))</span>\n\nioio<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// IO(\'pizza\')</span>\n\n<span class="token keyword">const</span> ttt <span class="token operator">=</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">\'sewers\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// Task(Task(Task(\'sewers\')));</span>\n\nttt<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// Task(Task(\'sewers\'))</span>\n</code></pre>\n      </div>\n<p>如果有两层相同类型的嵌套，那么就可以用 join 把它们压扁到一块去。这种结合的能力，functor 之间的联姻，就是 monad 之所以成为 monad 的原因。来看看它更精确的完整定义：</p>\n<p><strong>monad是可以扁平化（flatten）的 pointed functor。</strong></p>\n<p>一个 functor，只要它定义个了一个<code>join</code>方法和一个<code>of</code>方法，并遵守一些定律，那么它就是一个<code>monad</code>。<code>join</code>的实现并不太复杂，我们来为 <code>Maybe</code>定义一个：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code>Maybe<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>join <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$value<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>看，就像子宫里双胞胎中的一个吃掉另一个那么简单。如果有一个<code>Maybe(Maybe(x))</code>，那么 <code>.$value``将会移除多余的一层，然后我们就能安心地从那开始进行</code>map。要不然，我们就将会只有一个<code>Maybe</code>，因为从一开始就没有任何东西被<code>map</code>调用。</p>\n<p>既然已经有了<code>join</code>方法，我们把<code>monad</code>魔法作用到<code>firstAddressStreet</code>例子上，看看它的实际作用：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// join :: Monad m => m (m a) -> m a</span>\n<span class="token keyword">const</span> join <span class="token operator">=</span> mma <span class="token operator">=></span> mma<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// firstAddressStreet :: User -> Maybe Street</span>\n<span class="token keyword">const</span> firstAddressStreet <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>\n  join<span class="token punctuation">,</span>\n  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">\'street\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  join<span class="token punctuation">,</span>\n  <span class="token function">map</span><span class="token punctuation">(</span>safeHead<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">\'addresses\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">firstAddressStreet</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  addresses<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> street<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">\'Mulburry\'</span><span class="token punctuation">,</span> number<span class="token punctuation">:</span> <span class="token number">8402</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> postcode<span class="token punctuation">:</span> <span class="token string">\'WC2N\'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// Maybe({name: \'Mulburry\', number: 8402})</span>\n</code></pre>\n      </div>\n<p>只要遇到嵌套的 Maybe，就加一个 join，防止它们从手中溜走。我们对 IO 也这么做试试看，感受下这种感觉。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code>IO<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>join <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unsafePerformIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>同样是简单地移除了一层容器。注意，我们还没有提及纯粹性的问题，仅仅是移除过度紧缩的包裹中的一层而已。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// log :: a -> IO a</span>\n<span class="token keyword">const</span> log <span class="token operator">=</span> x <span class="token operator">=></span> IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> x<span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// setStyle :: Selector -> CSSProps -> IO DOM</span>\n<span class="token keyword">const</span> setStyle <span class="token operator">=</span>\n  <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sel<span class="token punctuation">,</span> props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">jQuery</span><span class="token punctuation">(</span>sel<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// getItem :: String -> IO String</span>\n<span class="token keyword">const</span> getItem <span class="token operator">=</span> key <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// applyPreferences :: String -> IO DOM</span>\n<span class="token keyword">const</span> applyPreferences <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>\n  join<span class="token punctuation">,</span>\n  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">setStyle</span><span class="token punctuation">(</span><span class="token string">\'#main\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  join<span class="token punctuation">,</span>\n  <span class="token function">map</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">map</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span>parse<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  getItem<span class="token punctuation">,</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token function">applyPreferences</span><span class="token punctuation">(</span><span class="token string">\'preferences\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unsafePerformIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// Object {backgroundColor: "green"}</span>\n<span class="token comment" spellcheck="true">// &lt;div style="background-color: \'green\'"/></span>\n</code></pre>\n      </div>\n<p>getItem 返回了一个 IO String，所以可以直接用 map 来解析它。log 和 setStyle 返回的都是 IO，所以必须要使用 join 来保证这里边的嵌套处于控制之中。</p>\n<h3 id="my-chain-hits-my-chest"><a href="#my-chain-hits-my-chest" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>My Chain Hits My Chest</h3>\n<p>\n你可能已经从上面的例子中注意到这种模式了：我们总是在紧跟着 map 的后面调用 join。让我们把这个行为抽象到一个叫做 chain 的函数里。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// chain :: Monad m => (a -> m b) -> m a -> m b</span>\n<span class="token keyword">const</span> chain <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">=></span> m<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// or</span>\n\n<span class="token comment" spellcheck="true">// chain :: Monad m => (a -> m b) -> m a -> m b</span>\n<span class="token keyword">const</span> chain <span class="token operator">=</span> f <span class="token operator">=></span> <span class="token function">compose</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>这里仅仅是把 map/join 套餐打包到一个单独的函数中。如果你之前了解过 monad，那你可能已经看出来 chain 叫做 >>=（读作 bind）或者 flatMap；都是同一个概念的不同名称罢了。我个人认为 flatMap 是最准确的名称，但本书还是坚持使用 chain，因为它是 JS 里接受程度最高的一个。我们用 chain 重构下上面两个例子：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// map/join</span>\n<span class="token keyword">const</span> firstAddressStreet <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>\n  join<span class="token punctuation">,</span>\n  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">\'street\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  join<span class="token punctuation">,</span>\n  <span class="token function">map</span><span class="token punctuation">(</span>safeHead<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">\'addresses\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// chain</span>\n<span class="token keyword">const</span> firstAddressStreet <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>\n  <span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">\'street\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">chain</span><span class="token punctuation">(</span>safeHead<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">\'addresses\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// map/join</span>\n<span class="token keyword">const</span> applyPreferences <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>\n  join<span class="token punctuation">,</span>\n  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">setStyle</span><span class="token punctuation">(</span><span class="token string">\'#main\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  join<span class="token punctuation">,</span>\n  <span class="token function">map</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">map</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span>parse<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  getItem<span class="token punctuation">,</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// chain</span>\n<span class="token keyword">const</span> applyPreferences <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>\n  <span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">setStyle</span><span class="token punctuation">(</span><span class="token string">\'#main\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">chain</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  <span class="token function">map</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span>parse<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  getItem<span class="token punctuation">,</span>\n<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>我把所有的 map/join 都替换为了 chain，这样代码就显得整洁了些。整洁固然是好事，但 chain 的能力却不止于此——它更多的是龙卷风而不是吸尘器。因为 chain 可以轻松地嵌套多个作用，因此我们就能以一种纯函数式的方式来表示 序列（sequence） 和 变量赋值（variable assignment）。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// getJSON :: Url -> Params -> Task JSON</span>\n<span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token string">\'/authenticate\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> username<span class="token punctuation">:</span> <span class="token string">\'stale\'</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">\'crackers\'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>user <span class="token operator">=></span> <span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token string">\'/friends\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> user_id<span class="token punctuation">:</span> user<span class="token punctuation">.</span>id <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// Task([{name: \'Seimith\', id: 14}, {name: \'Ric\', id: 39}]);</span>\n\n<span class="token comment" spellcheck="true">// querySelector :: Selector -> IO DOM</span>\n<span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">\'input.username\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> uname <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">\'input.email\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> email <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Welcome </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>uname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> prepare for spam at </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>email<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// IO(\'Welcome Olivia prepare for spam at olivia@tremorcontrol.net\');</span>\n\nMaybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>three <span class="token operator">=></span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>three<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// Maybe(5);</span>\n\nMaybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">\'address\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">\'street\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// Maybe(null);</span>\n</code></pre>\n      </div>\n<p>本来我们可以用 compose 写上面的例子，但这将需要几个帮助函数，而且这种风格怎么说都要通过闭包进行明确的变量赋值。相反，我们使用了插入式的 chain。顺便说一下，chain 可以自动从任意类型的 map 和 join 衍生出来，就像这样：t.prototype.chain = function(f) { return this.map(f).join(); }。如果手动定义 chain 能让你觉得性能会好点的话（实际上并不会），我们也可以手动定义它，尽管还必须要费力保证函数功能的正确性——也就是说，它必须与紧接着后面有 join 的 map 相等。如果 chain 是简单地通过结束调用 of 后把值放回容器这种方式定义的，那么就会造成一个有趣的后果，即可以从 chain 那里衍生出一个 map。同样地，我们还可以用 chain(id) 定义 join。听起来好像是在跟魔术师玩德州扑克，魔术师想要什么牌就有什么牌；但是就像大部分的数学理论一样，所有这些原则性的结构都是相互关联的。fantasyland 仓库中提到了许多上述衍生概念，这个仓库也是 JavaScript 官方的代数数据结构（algebraic data types）标准。</p>\n<p>好了，我们来看上面的例子。第一个例子中，可以看到两个 Task 通过 chain 连接形成了一个异步操作的序列——它先获取 user，然后用 user.id 查找 user 的 friends。chain 避免了 Task(Task([Friend])) 这种情况。</p>\n<p>第二个例子是用 querySelector 查找几个 input 然后创建一条欢迎信息。注意看我们是如何在最内层的函数里访问 uname 和 email 的——这是函数式变量赋值的绝佳表现。因为 IO 大方地把它的值借给了我们，我们也要负起以同样方式把值放回去的责任——不能辜负它的信任（还有整个程序的信任）。IO.of 非常适合做这件事，同时它也解释了为何 pointed 这一特性是 monad 接口得以存在的重要前提。不过，map 也能返回正确的类型：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">\'input.username\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> uname <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span>\n  <span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">\'input.email\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> email <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span>\n    <span class="token template-string"><span class="token string">`Welcome </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>uname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> prepare for spam at </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>email<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment" spellcheck="true">// IO(\'Welcome Olivia prepare for spam at olivia@tremorcontrol.net\');</span>\n</code></pre>\n      </div>\n<p>最后两个例子用了 Maybe。因为 chain 其实是在底层调用了 map，所以如果遇到 null，代码就会立刻停止运行。</p>\n<p>如果觉得这些例子不太容易理解，你也不必担心。多跑跑代码，多琢磨琢磨，把代码拆开来研究研究，再把它们拼起来看看。总之记住，返回的如果是“普通”值就用 map，如果是 functor 就用 chain。</p>\n<p>这里我得提醒一下，上述方式对两个不同类型的嵌套容器是不适用的。functor 组合，以及后面会讲到的 monad transformer 可以帮助我们应对这种情况。</p>\n<h3 id="power-trip"><a href="#power-trip" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Power Trip</h3>\n<p>这种容器编程风格有时也能造成困惑，我们不得不努力理解一个值到底嵌套了几层容器，或者需要用 map 还是 chain（很快我们就会认识更多的容器类型）。使用一些技巧，比如重写 inspect 方法之类，能够大幅提高 debug 的效率。后面我们也会学习如何创建一个“栈”，使之能够处理任何丢给它的作用（effects）。不过，有时候也需要权衡一下是否值得这样做。</p>\n<p>我很乐意挥起 monad 之剑，向你展示这种编程风格的力量。就以读一个文件，然后就把它直接上传为例吧：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// readFile :: Filename -> Either String (Future Error String)</span>\n<span class="token comment" spellcheck="true">// httpPost :: String -> Future Error JSON</span>\n\n<span class="token comment" spellcheck="true">//  upload :: String -> Either String (Future Error JSON)</span>\n<span class="token keyword">var</span> upload <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">httpPost</span><span class="token punctuation">(</span><span class="token string">\'/uploads\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> readFile<span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>这里，代码不止一次在不同的分支执行。从类型签名可以看出，我们预防了三个错误——readFile 使用 Either 来验证输入（或许还有确保文件名存在）；readFile 在读取文件的时候可能会出错，错误通过 readFile 的 Future 表示；文件上传可能会因为各种各样的原因出错，错误通过 httpPost 的 Future 表示。我们就这么随意地使用 chain 实现了两个嵌套的、有序的异步执行动作。</p>\n<p>所有这些操作都是在一个从左到右的线性流中完成的，是完完全全纯的、声明式的代码，是可以等式推导（equational reasoning）并拥有可靠特性（reliable properties）的代码。我们没有被迫使用不必要甚至令人困惑的变量名，我们的 upload 函数符合通用接口而不是特定的一次性接口。这些都是在一行代码中完成的啊！</p>\n<p>让我们来跟标准的命令式的实现对比一下：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">//  upload :: String -> (String -> a) -> Void</span>\n<span class="token keyword">var</span> upload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>filename<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">throw</span> <span class="token string">"You need a filename!"</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token function">readFile</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> contents<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span>\n      <span class="token function">httpPost</span><span class="token punctuation">(</span>contents<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> json<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span>\n        <span class="token function">callback</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n      </div>\n<p>看看，这简直就是魔鬼的算术，我们就像一颗弹珠一样在变幻莫测的迷宫中穿梭。无法想象如果这是一个典型的应用，而且一直在改变变量会怎样——我们肯定会像陷入沥青坑那样无所适从。</p>\n<h3 id="theory"><a href="#theory" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Theory</h3>\n<p>我们要看的第一条定律是结合律，但可能不是你熟悉的那个结合律。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code> <span class="token comment" spellcheck="true">// 结合律</span>\n  <span class="token function">compose</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>join<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">compose</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> join<span class="token punctuation">)</span>\n</code></pre>\n      </div>\n<p>这些定律表明了 monad 的嵌套本质，所以结合律关心的是如何让内层或外层的容器类型 join，然后取得同样的结果。用一张图来表示可能效果会更好：\n\n从左上角往下，先用 join 合并 M(M(M a)) 最外层的两个 M，然后往右，再调用一次 join，就得到了我们想要的 M a。或者，从左上角往右，先打开最外层的 M，用 map(join) 合并内层的两个 M，然后再向下调用一次 join，也能得到 M a。不管是先合并内层还是先合并外层的 M，最后都会得到相同的 M a，所以这就是结合律。值得注意的一点是 map(join) != join。两种方式的中间步骤可能会有不同的值，但最后一个 join 调用后最终结果是一样的。</p>\n<p>第二个定律与结合律类似：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// 同一律 (M a)</span>\n  <span class="token function">compose</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> <span class="token keyword">of</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">compose</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">of</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> id\n</code></pre>\n      </div>\n<p>这表明，对任意的 monad M，of 和 join 相当于 id。也可以使用 map(of) 由内而外实现相同效果。我们把这个定律叫做“三角同一律”（triangle identity），因为把它图形化之后就像一个三角形：\n\n如果从左上角开始往右，可以看到 of 的确把 M a 丢到另一个 M 容器里去了。然后再往下 join，就得到了 M a，跟一开始就调用 id 的结果一样。从右上角往左，可以看到如果我们通过 map 进到了 M 里面，然后对普通值 a 调用 of，最后得到的还是 M (M a)；再调用一次 join 将会把我们带回原点，即 M a。</p>\n<p>我要说明一点，尽管这里我写的是 of，实际上对任意的 monad 而言，都必须要使用明确的 M.of。</p>\n<p>我已经见过这些定律了，同一律和结合律，以前就在哪儿见过…等一下，让我想想…是的！它们是范畴遵循的定律！不过这意味着我们需要一个组合函数来给出一个完整定义。见证吧：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> mcompose <span class="token operator">=</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">chain</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// left identity</span>\n<span class="token function">mcompose</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token operator">===</span> f<span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// right identity</span>\n<span class="token function">mcompose</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> M<span class="token punctuation">)</span> <span class="token operator">===</span> f<span class="token punctuation">;</span>\n\n<span class="token comment" spellcheck="true">// associativity</span>\n<span class="token function">mcompose</span><span class="token punctuation">(</span><span class="token function">mcompose</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">,</span> h<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">mcompose</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token function">mcompose</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n      </div>\n<p>毕竟它们是范畴学里的定律。monad 来自于一个叫 “Kleisli 范畴”的范畴，这个范畴里边所有的对象都是 monad，所有的态射都是联结函数（chained funtions）。我不是要在没有提供太多解释的情况下，拿范畴学里各式各样的概念来取笑你。我的目的是涉及足够多的表面知识，向你说明这中间的相关性，让你在关注日常实用特性之余，激发起对这些定律的兴趣。</p>\n<h3 id="summary"><a href="#summary" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Summary</h3>\n<p>monad 让我们深入到嵌套的运算当中，使我们能够在完全避免回调金字塔（pyramid of doom）情况下，为变量赋值，运行有序的作用，执行异步任务等等。当一个值被困在几层相同类型的容器中时，monad 能够拯救它。借助 “pointed” 这个可靠的帮手，monad 能够借给我们从盒子中取出的值，而且知道我们会在结束使用后还给它。</p>\n<p>是的，monad 非常强大，但我们还需要一些额外的容器函数。比如，假设我们想同时运行一个列表里的 api 调用，然后再搜集返回的结果，怎么办？是可以使用 monad 实现这个任务，但必须要等每一个 api 完成后才能调用下一个。合并多个合法性验证呢？我们想要的肯定是持续验证以搜集错误列表，但是 monad 会在第一个 Left 登场的时候停掉整个演出。</p>\n<p>下一章，我们将看到 applicative functor 如何融入这个容器世界，以及为何在很多情况下它比 monad 更好用。</p>',
frontmatter:{title:"FP14：Monad-1",img:"./img/2018-09-02.jpeg",author:["Sylvenas"],excerpt:null,catalogue:null},fields:{date:"September 01, 2018",path:"blog/functional/2018-09-02-FP14-Monad-1.md",slug:"/blog/2018/09/02/FP14-Monad-1.html"}},allMarkdownRemark:{edges:[{node:{frontmatter:{title:"FP18：Semigroup"},fields:{slug:"/blog/2018/12/13/FP18-Semigroup.html"}}},{node:{frontmatter:{title:"FP17：Transform Naturally"},fields:{slug:"/blog/2018/12/11/FP17-Transform-Naturally.html"}}},{node:{frontmatter:{title:"FP16：Applicative Functor"},fields:{slug:"/blog/2018/11/07/FB16-Applicative-Functor.html"}}},{node:{frontmatter:{title:"FP15：Monad-2"},fields:{slug:"/blog/2018/09/11/FB15-Monad-2.html"}}},{node:{frontmatter:{title:"FP14：Monad-1"},fields:{slug:"/blog/2018/09/02/FP14-Monad-1.html"}}},{node:{frontmatter:{title:"代理模式"},fields:{slug:"/blog/2018/08/24/代理-pattern.html"}}},{node:{frontmatter:{title:"'类'模式"},fields:{slug:"/blog/2018/08/24/class-pattern.html"}}},{node:{frontmatter:{title:"FP13：IO - keep code pure"},fields:{slug:"/blog/2018/08/08/FP13-IO.html"}}},{node:{frontmatter:{title:"FP12：Either:Left or Right"},fields:{slug:"/blog/2018/08/03/FP12-Either.html"}}},{node:{frontmatter:{title:"FP11：Schrödinger's Maybe"},fields:{slug:"/blog/2018/08/02/FP11-Maybe.html"}}}]}},pathContext:{slug:"/blog/2018/09/02/FP14-Monad-1.html"}}}});