webpackJsonp([0x6ccd42df8799],{720:function(s,n){s.exports={data:{markdownRemark:{html:'<p>Nginx 是一个遵循主从架构的 Web 服务器，可以用作反向代理、负载均衡器、邮件代理和 HTTP 缓存。\n哇！复杂的术语和混乱的定义，里面充斥着大量令人困惑的词语，对吧？不用担心，这篇文章可以帮大家先了解 Nginx 的基本架构和术语，然后我们将安装并创建 Nginx 配置。</p>\n<p>Nginx 是一个神奇的 Web 服务器。</p>\n<p>简单来说，Web 服务器就像个中间人。比如你想访问 dev.to，输入地址 <code class="gatsby-code-text">https://dev.to</code>，你的浏览器就会找出 <code class="gatsby-code-text">https://dev.to</code>的 Web 服务器地址，然后将其定向到后台服务器，后台服务器会把响应返回给客户端。</p>\n<h2 id="代理-vs-反向代理"><a href="#%E4%BB%A3%E7%90%86-vs-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代理 vs 反向代理</h2>\n<p>Nginx 的基本功能是代理，所以现在就需要了解什么是代理和反向代理。</p>\n<h2 id="proxy"><a href="#proxy" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Proxy</h2>\n<p>目前国内无法访问 google，但是我们有时说挂个代理，然后就能顺利访问，而这种代理模式就是正向代理。假如我们在香港有一台服务器，这台服务器是能访问 google 的，而国内无法直接访问谷歌，但是可以访问香港的服务器。每次我们请求香港服务器，香港服务器拿到我们请求以后，再去访问 google 服务器，google 服务器把响应返回给香港服务器，香港服务器再把响应返回给我们。这样我们就能顺利的访问 google 了。</p>\n<p>但是如果过多的客户端使用代理，导致代理服务器频繁请求 google，而 google 可能认为代理服务器是爬虫，会做一些反扒机制，这样客户端就无法正常访问，所以有时候代理服务器会告诉 google 我是一台代理服务器。</p>\n<p>好的，我们有一个或多个客户端、一个中间 Web 服务器 A（在这种情况下，我们称它为代理）和一个真正提供服务的服务器 B。这其中最主要的事情是<strong>B 服务器不知道哪个客户端正在请求</strong>。是不是有点困惑？让我用一张示意图来解释一下。</p>\n<p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/8543146241/55e6/1631/c35a/451a4a3805baa4646e25b80b6331f415.png" alt="proxy"></p>\n<p>一般来说代理分为三种，即透明代理，匿名代理和高匿名代理。</p>\n<ul>\n<li>透明代理，代理服务器暴露了客户端真实的信息。</li>\n<li>匿名代理，隐藏了客户端信息，但是会声明自己是代理服务器。</li>\n<li>高匿名代理，隐藏了客户端信息，也不会声明自己是代理服务器，目标服务器不知道是否使用了代理，更不知道客户端真实信息</li>\n</ul>\n<h3 id="reverse-proxy"><a href="#reverse-proxy" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reverse Proxy</h3>\n<p>例如淘宝，每天访问量很大，不可能只用单个服务器处理所有业务，于是出现了分布式部署。也就是通过部署多台服务器来解决访问人数限制的问题。</p>\n<p>客户端请求 taobao.com，DNS 服务器把域名解析到 nginx 服务器上（简单的这么理解），nginx 服务器接收到之后，按照一定的规则(比如：轮询调度 Round-Robin)分发给了后端的业务处理服务器进行处理了。</p>\n<p>反向请求的来源也就是客户端是明确的，但是请求的具体由哪台服务器处理并不明确，nginx 扮演的就是一个反向代理角色。</p>\n<p>反向代理隐藏了具体处理业务的服务器信息。</p>\n<p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/8543309473/ebbe/f458/593c/28fe58d5c83ee7cb2822fb0e362969da.png" alt="Reverse Proxy"></p>\n<h2 id="负载均衡"><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>负载均衡</h2>\n<p>可恶，又是一个新词，但是这个词比较容易理解，因为它是“反向代理”本身的一个实际应用。</p>\n<p>我们先说说基本的区别。在负载均衡中，必须要有两个或者更多的后台服务器；但在反向代理设置中，这不是必须的，它甚至可以只跟单台后台服务器一起使用。</p>\n<p>让我们从幕后看一下，如果我们有大量来自客户端的请求，这个负载均衡器会检查每个后台服务器的状态并分配请求的负载，然后将响应更快地发送给客户端，目的就是保障每台服务器的会比较平均的处理请求，而不会是“旱的旱死，涝的涝死”，分担了服务器压力，避免了服务器崩溃的情况。</p>\n<h2 id="nginx-配置"><a href="#nginx-%E9%85%8D%E7%BD%AE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>NGINX 配置</h2>\n<h3 id="代理静态资源"><a href="#%E4%BB%A3%E7%90%86%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>代理静态资源</h3>\n<p>在这里，我们让 NGINX 监听 <code class="gatsby-code-text">5000</code> 端口，并指向 <code class="gatsby-code-text">/nginx-demo/</code> 文件夹下的静态资源。</p>\n<p>此时我们通过 <code class="gatsby-code-text">curl -k http://localohost:5000</code> 就可以访问到 <code class="gatsby-code-text">/nginx-demo/</code> 下的静态文件，默认为 <code class="gatsby-code-text">/nginx-demo/index.html</code></p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-config"><code class="gatsby-code-config">  http {\n\n     server {\n       listen 5000;\n       root /path/to/nginx-demo/;\n      }\n\n  }\n\n  events {}</code></pre>\n      </div>\n<p>添加 <code class="gatsby-code-text">events {}</code> 是必须的，因为对于 NGINX 架构来讲，它通常被用来表示 <code class="gatsby-code-text">Worker</code> 的数量。</p>\n<h3 id="reverse-proxy-1"><a href="#reverse-proxy-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Reverse Proxy</h3>\n<p>NGINX 反向代理主要通过 <code class="gatsby-code-text">proxy_pass</code> 来配置，将你项目的开发机地址填写到 <code class="gatsby-code-text">proxy_pass</code> 后面，正常的格式为 <code class="gatsby-code-text">proxy_pass URL</code> 即可</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-nginx"><code class="gatsby-code-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>\n  <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>\n  <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>\n    <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">10.10</span><span class="token number">.10</span><span class="token number">.10</span><span class="token punctuation">:</span><span class="token number">20186</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>现在我们通过 <code class="gatsby-code-text">curl -k http://localhost/hello</code> 访问某个服务，NGINX 会把该请求转发到 <code class="gatsby-code-text">http://10.10.10.10:20186/hello</code> 然后拿到结果，然后返回。</p>\n<p>同时多个服务我们可以通过反向代理合并到一个端口中，比如现在服务器上有 app1 处理部分请求，app2 处理另外一部分请求，同时我们知道 Node.js http server 端口号不能重叠，所以我们可以让 app1 server 监听 1000 端口，app2 监听 2000 端口，然后通过 NGINX 反向代理到同一个端口</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-nginx"><code class="gatsby-code-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>\n  <span class="token keyword">listen</span> <span class="token number">80</span><span class="token punctuation">;</span>\n    <span class="token keyword">location</span> <span class="token operator">/</span>app1<span class="token operator">/</span> <span class="token punctuation">{</span>                            <span class="token comment"># 处理 http://localhost/app1/xxxx</span>\n      <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">1000</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">location</span> <span class="token operator">/</span>app2<span class="token operator">/</span> <span class="token punctuation">{</span>                            <span class="token comment"># 处理 http://localhost/app2/xxxx</span>\n      <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">2000</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>具体转发到 app1,还是 app2 是根据请求的 url 决定的。url 匹配规则可以采用正则表达式，全等，前缀，后缀等等，后面会继续讲解</p>\n<h3 id="https"><a href="#https" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>HTTPS</h3>\n<p>NGINX 同样可以简单的创建 https 服务，比如我们有内部 http 服务，通过反向代理的方式可以转换成“对外”的 HTTPS 服务，通过监听 443 端口以及指定 https 证书文件和私钥文件的地址(服务器上的绝对路径)，可以简单的创建 https 服务</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-sh"><code class="gatsby-code-sh">curl -k https://sylvenas.xyz/a/xxx 转发到 http://localhost:1000\n\ncurl -k https://sylvenas.xyz/b/xxx 转发到 http://localhost:2000</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-nginx"><code class="gatsby-code-nginx"><span class="token keyword">server</span> <span class="token punctuation">{</span>\n  <span class="token keyword">listen</span>       <span class="token number">443</span> <span class="token keyword">ssl</span><span class="token punctuation">;</span>\n  <span class="token keyword">server_name</span>  sylvenas<span class="token punctuation">.</span>xyz<span class="token punctuation">;</span>\n\n  <span class="token keyword">ssl_certificate</span>      <span class="token operator">/</span>Users<span class="token operator">/</span>sylvenas<span class="token operator">/</span>Documents<span class="token operator">/</span>feature<span class="token operator">/</span>nginx<span class="token operator">/</span>final<span class="token punctuation">.</span>crt<span class="token punctuation">;</span>\n  <span class="token keyword">ssl_certificate_key</span>  <span class="token operator">/</span>Users<span class="token operator">/</span>sylvenas<span class="token operator">/</span>Documents<span class="token operator">/</span>feature<span class="token operator">/</span>nginx<span class="token operator">/</span>site<span class="token punctuation">.</span>key<span class="token punctuation">;</span>\n\n  <span class="token keyword">ssl_session_cache</span>    shared<span class="token punctuation">:</span><span class="token keyword">SSL</span><span class="token punctuation">:</span><span class="token number">1</span>m<span class="token punctuation">;</span>\n  <span class="token keyword">ssl_session_timeout</span>  <span class="token number">5</span>m<span class="token punctuation">;</span>\n\n  <span class="token keyword">ssl_ciphers</span>  HIGH<span class="token punctuation">:</span><span class="token operator">!</span>aNULL<span class="token punctuation">:</span><span class="token operator">!</span>MD5<span class="token punctuation">;</span>\n  <span class="token keyword">ssl_prefer_server_ciphers</span>  on<span class="token punctuation">;</span>\n\n  <span class="token keyword">location</span> <span class="token operator">/</span>a<span class="token operator">/</span> <span class="token punctuation">{</span>\n    <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">1000</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">location</span> <span class="token operator">/</span>b<span class="token operator">/</span> <span class="token punctuation">{</span>\n    <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>localhost<span class="token punctuation">:</span><span class="token number">2000</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<h2 id="location-匹配规则"><a href="#location-%E5%8C%B9%E9%85%8D%E8%A7%84%E5%88%99" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>location 匹配规则</h2>\n<p>语法规则很简单，一个 location 关键字，后面跟着可选的<strong>修饰符</strong>(=, ~, ~*, ^~)，后面是要匹配的字符(uri)，花括号中是要执行的操作。</p>\n<h3 id="修饰符"><a href="#%E4%BF%AE%E9%A5%B0%E7%AC%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>修饰符</h3>\n<p>= 表示精确匹配。只有请求的 url 路径与后面的字符串完全相等时，才会命中。\n~ 表示该规则是使用正则定义的，区分大小写。\n~* 表示该规则是使用正则定义的，不区分大小写。\n^~ 表示如果该符号后面的字符是最佳匹配，采用该规则，不再进行后续的查找。</p>\n<h3 id="匹配过程"><a href="#%E5%8C%B9%E9%85%8D%E8%BF%87%E7%A8%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>匹配过程</h3>\n<p>对请求的 url 序列化。例如，对 <code class="gatsby-code-text">%xx</code> 等字符进行解码，去除 url 中多个相连的<code class="gatsby-code-text">/</code>，解析 url 中的<code class="gatsby-code-text">.</code>，<code class="gatsby-code-text">..</code>等。这一步是匹配的前置工作。</p>\n<p>location 有两种表示形式，一种是使用前缀字符，一种是使用正则。如果是正则的话，前面有 <code class="gatsby-code-text">~</code> 或 <code class="gatsby-code-text">~\\*</code> 修饰符。</p>\n<blockquote>\n<p>正则也是前缀字符的一种，这里只是单独拿出来说罢了，就是为了区分正则和普通的前缀字符</p>\n</blockquote>\n<p>具体的匹配过程如下：</p>\n<ul>\n<li>首先先检查使用前缀字符定义的 location，选择最长匹配的项并记录下来。</li>\n<li>如果找到了精确匹配的 location，也就是使用了 <code class="gatsby-code-text">=</code> 修饰符的 location，结束查找，使用它的配置。</li>\n<li>然后按顺序查找使用正则定义的 location，如果匹配则停止查找，使用它定义的配置。</li>\n<li>如果没有匹配的正则 location，则使用前面记录的最长匹配前缀字符 location。</li>\n</ul>\n<p>基于以上的匹配过程，我们可以得到以下两点启示：</p>\n<p>使用正则定义的 location 在配置文件中出现的顺序很重要。因为找到第一个匹配的正则后，查找就停止了，后面定义的正则就是再匹配也没有机会了。\n使用精确匹配可以提高查找的速度。例如经常请求 <code class="gatsby-code-text">/</code> 的话，可以使用 <code class="gatsby-code-text">=</code> 来定义 location。</p>\n<h3 id="实例"><a href="#%E5%AE%9E%E4%BE%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实例</h3>\n<p>假如我们有下面的一段配置文件：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-nginx"><code class="gatsby-code-nginx"><span class="token keyword">location</span> <span class="token operator">=</span> <span class="token operator">/</span> <span class="token punctuation">{</span>\n    <span class="token punctuation">[</span> configuration A <span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>\n    <span class="token punctuation">[</span> configuration B <span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">location</span> <span class="token operator">/</span><span class="token keyword">user</span><span class="token operator">/</span> <span class="token punctuation">{</span>\n    <span class="token punctuation">[</span> configuration C <span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">location</span> <span class="token operator">^</span><span class="token operator">~</span> <span class="token operator">/</span>images<span class="token operator">/</span> <span class="token punctuation">{</span>\n    <span class="token punctuation">[</span> configuration D <span class="token punctuation">]</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">location</span> <span class="token operator">~</span><span class="token operator">*</span> \\<span class="token punctuation">.</span><span class="token punctuation">(</span>gif<span class="token operator">|</span>jpg<span class="token operator">|</span>jpeg<span class="token punctuation">)</span>$ <span class="token punctuation">{</span>\n    <span class="token punctuation">[</span> configuration E <span class="token punctuation">]</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<ul>\n<li>\n<p>请求 <code class="gatsby-code-text">/</code> 精准匹配 A，不再往下查找。</p>\n</li>\n<li>\n<p>请求 <code class="gatsby-code-text">/index.html</code> 匹配 B。首先查找匹配的前缀字符，找到最长匹配是配置 B，接着又按照顺序查找匹配的正则。结果没有找到，因此使用先前标记的最长匹配，即配置 B。</p>\n</li>\n<li>\n<p>请求 <code class="gatsby-code-text">/user/index.html</code> 匹配 C。首先找到最长匹配 C，由于后面没有匹配的正则，所以使用最长匹配 C。</p>\n</li>\n<li>\n<p>请求 <code class="gatsby-code-text">/user/1.jpg</code> 匹配 E。首先进行前缀字符的查找，找到最长匹配项 C，继续进行正则查找，找到匹配项 E。因此使用 E。</p>\n</li>\n<li>\n<p>请求 <code class="gatsby-code-text">/images/1.jpg</code> 匹配 D。首先进行前缀字符的查找，找到最长匹配 D。但是，特殊的是它使用了 <code class="gatsby-code-text">^~</code> 修饰符，不再进行接下来的正则的匹配查找，因此使用 D。这里，如果没有前面的修饰符，其实最终的匹配是 E。大家可以想一想为什么。</p>\n</li>\n<li>\n<p>请求 <code class="gatsby-code-text">/documents/about.html</code> 匹配 B。因为 B 表示任何以 <code class="gatsby-code-text">/</code> 开头的 URL 都匹配。在上面的配置中，只有 B 能满足，所以匹配 B。</p>\n</li>\n</ul>\n<h2 id="负载均衡-1"><a href="#%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1-1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>负载均衡</h2>\n<p>NGINX 通过 <code class="gatsby-code-text">upstream</code> 模块实现负载均衡</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-nginx"><code class="gatsby-code-nginx"><span class="token keyword">worker_processes</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token keyword">events</span> <span class="token punctuation">{</span>\n    <span class="token keyword">worker_connections</span> <span class="token number">1024</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">http</span> <span class="token punctuation">{</span>\n    <span class="token keyword">upstream</span> firstdemo <span class="token punctuation">{</span>\n        <span class="token keyword">server</span> <span class="token number">39.106</span><span class="token number">.145</span><span class="token number">.33</span><span class="token punctuation">;</span>\n        <span class="token keyword">server</span> <span class="token number">47.93</span><span class="token number">.6</span><span class="token number">.93</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">server</span> <span class="token punctuation">{</span>\n        <span class="token keyword">listen</span> <span class="token number">8080</span><span class="token punctuation">;</span>\n        <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>\n            <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span>firstdemo<span class="token punctuation">;</span>\n        <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<ul>\n<li>\n<p>worker_processes<br>\n工作进程数，和CPU核数相同</p>\n</li>\n<li>\n<p>worker_connections<br>\n每个进程允许的最大连接数</p>\n</li>\n<li>\n<p>upstream 模块<br>\n负载均衡就靠它\n语法格式：upstream name {}\n里面写的两个server分别对应着不同的服务器</p>\n</li>\n<li>\n<p>server 模块<br>\n实现反向代理\nlisten 监督端口号\nlocation / {}访问根路径\nproxy_pass <a href="http://firstdemo%EF%BC%8C%E4%BB%A3%E7%90%86%E5%88%B0">http://firstdemo，代理到</a> firstdemo 里两个服务器上</p>\n</li>\n</ul>\n<h4 id="ip_hash"><a href="#ip_hash" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ip_hash</h4>\n<p>当用户第一次访问到其中一台服务器后，下次再访问的时候就直接访问该台服务器就好了，不用总变化了。那么就发挥了 <code class="gatsby-code-text">ip_hash</code> 的威力了</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-nginx"><code class="gatsby-code-nginx"><span class="token keyword">upstream</span> firstdemo <span class="token punctuation">{</span>\n    <span class="token keyword">ip_hash</span><span class="token punctuation">;</span>\n    <span class="token keyword">server</span> <span class="token number">39.106</span><span class="token number">.145</span><span class="token number">.33</span><span class="token punctuation">;</span>\n    <span class="token keyword">server</span> <span class="token number">47.93</span><span class="token number">.6</span><span class="token number">.93</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p><code class="gatsby-code-text">ip_hash</code> 它的作用是如果第一次访问该服务器后就记录，之后再访问都是该服务器了，这样比如第一次访问是服务器A，那之后再访问也会分配为服务器A访问了。</p>\n<h2 id="常用命令"><a href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>常用命令</h2>\n<ul>\n<li>\n<p>启动</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-sh"><code class="gatsby-code-sh">sudo nginx</code></pre>\n      </div>\n</li>\n<li>\n<p>重启</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-sh"><code class="gatsby-code-sh">sudo nginx -s reopen </code></pre>\n      </div>\n</li>\n<li>\n<p>重新加载Nginx配置文件，然后以优雅的方式重启Nginx</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-sh"><code class="gatsby-code-sh">nginx -s reload </code></pre>\n      </div>\n</li>\n<li>\n<p>强制停止Nginx服务</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-sh"><code class="gatsby-code-sh">nginx -s stop </code></pre>\n      </div>\n</li>\n<li>\n<p>优雅地停止Nginx服务（即处理完所有请求后再停止服务）</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-sh"><code class="gatsby-code-sh">nginx -s stop </code></pre>\n      </div>\n</li>\n<li>\n<p>检测配置文件是否有语法错误，然后退出</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-sh"><code class="gatsby-code-sh">nginx -t  </code></pre>\n      </div>\n</li>\n<li>\n<p>杀死所有nginx进程</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-sh"><code class="gatsby-code-sh">killall nginx </code></pre>\n      </div>\n</li>\n</ul>',frontmatter:{title:"NGINX 基础知识",img:"./img/2013-06-12.jpeg",author:["sylvenas"],excerpt:null,catalogue:null},fields:{date:"June 22, 2019",path:"blog/http/2019-06-23-nginx.md",slug:"/blog/2019/06/23/nginx.html"}},allMarkdownRemark:{edges:[{node:{frontmatter:{title:"React Hooks 原理及实现"},fields:{slug:"/blog/2021/03/30/react-hooks.html"}}},{node:{frontmatter:{title:"被讨厌的勇气"},fields:{slug:"/blog/2020/05/14/被讨厌的勇气.html"}}},{node:{frontmatter:{title:"自然变换 - Natural Transformation"},fields:{slug:"/blog/2020/05/02/自然变换.html"}}},{node:{frontmatter:{title:"遍历与队列 - Traversable"},fields:{slug:"/blog/2020/04/25/遍历与队列.html"}}},{node:{frontmatter:{title:"加法是自然之道 - Monoid"},fields:{slug:"/blog/2020/03/02/加法是自然之道.html"}}},{node:{frontmatter:{title:"俄罗斯套娃娃 - Monad"},fields:{slug:"/blog/2020/02/12/俄罗斯套娃娃.html"}}},{node:{frontmatter:{title:"纪念刘和珍君"},fields:{slug:"/blog/2020/02/07/记念刘和珍君.html"}}},{node:{frontmatter:{title:"应用函子 - Applicative"},fields:{slug:"/blog/2020/02/05/应用函子.html"}}},{node:{frontmatter:{title:"动物庄园"},fields:{slug:"/blog/2020/02/01/动物庄园.html"}}},{node:{frontmatter:{title:"薛定谔的 Maybe - IO"},fields:{slug:"/blog/2020/01/30/薛定谔的Maybe.html"}}}]}},pathContext:{slug:"/blog/2019/06/23/nginx.html"}}}});