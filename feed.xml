<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Little Forest]]></title><description><![CDATA[A JavaScript library for building user interfaces]]></description><link>https://reactjs.org</link><generator>RSS for Node</generator><lastBuildDate>Mon, 19 Apr 2021 12:35:06 GMT</lastBuildDate><item><title><![CDATA[React Hooks 原理及实现]]></title><description><![CDATA[<p>React Hooks 主要用来解决两个问题，</p>
<ul>
<li>组件之间复用逻辑
社区中普遍采用的 <a href="https://reactjs.org/docs/higher-order-components.html">High-Order-Components</a>和<a href="https://reactjs.org/docs/render-props.html">render props</a>,然而这两种方案分别会带来 “wrapper hell” 和代码难以理解/维护的问题。</li>
</ul>
<p><img src="https://d1.music.126.net/dmusic/obj/w5zCg8OAw6HDjzjDgMK_/8151104070/3cc4/6483/97d5/b4a91b516060489f7575f401ec69cd94.gif?download=20201012104934119.gif" alt="wrapper hell"></p>
<ul>
<li>函数式组件如何拥有状态
函数式组件在 <code class="gatsby-code-text">Hooks API</code> 出现之前，只能充当“渲染组件”的角色，然而鉴于 <code class="gatsby-code-text">ES6 Class</code> 本身的问题，以及复杂的 <code class="gatsby-code-text">Class Component</code> 难以维护的问题，所以 <code class="gatsby-code-text">FC</code> 组件维护状态是一个迫切的需求。</li>
</ul>
<p>本篇文章主要介绍 <code class="gatsby-code-text">Hook</code> 的实现原理，我们不会从社区中广泛采用的“源码函数调用链路”出发，把整个 <code class="gatsby-code-text">Hook</code> 的创建/使用的源代码大概过一遍，就算理解了 <code class="gatsby-code-text">Hook</code> 的实现原理；我并不认同这种方案，主要因为只是读一遍代码，并没有自己实现，那么过不了多久，就完全抛之脑后了。所以本篇文章我们要自己实现一个 <code class="gatsby-code-text">Hook</code>。</p>
<blockquote>
<p>纸上得来终觉浅，绝知此事要躬行。</p>
</blockquote>
<h2 id="函数如何拥有状态"><a href="#%E5%87%BD%E6%95%B0%E5%A6%82%E4%BD%95%E6%8B%A5%E6%9C%89%E7%8A%B6%E6%80%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>函数如何拥有状态</h2>
<p>看一个简单的函数：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">computeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>很明显这是个绝对的 “pure function”，任何时候，任何上下文调用该函数，都会返回固定结果：<code class="gatsby-code-text">1</code>。但是假设我们想在第一个调用该函数的时候返回 <code class="gatsby-code-text">1</code>，第二次返回 <code class="gatsby-code-text">2</code>，第三次返回 <code class="gatsby-code-text">3</code>，依次类推…</p>
<p>换句话说，我们想在下一次调用的时候，依赖上一次的计算结果，如果仅仅使用 <code class="gatsby-code-text">computeCount</code> 函数，很明显这是不可能的，除非使用“外部变量”，</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">let</span> outCount<span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">computeCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> count <span class="token operator">=</span> outCount <span class="token operator">||</span> <span class="token number">0</span><span class="token punctuation">;</span>
  outCount <span class="token operator">=</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> count <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>同样的道理，在 React Function Component 中，如果不借助“外部变量”，我们就不可能实现组件重新渲染的时候，依据上一次 <code class="gatsby-code-text">state</code> 计算本次渲染的 <code class="gatsby-code-text">state</code>，所以必定存在着某个“外部变量”，在 React 中，这个外部变量就是 <code class="gatsby-code-text">fiber node</code>，不过本篇文章，我们不详细介绍 <code class="gatsby-code-text">state</code> 如何挂载到 <code class="gatsby-code-text">fiber node</code> 上了，仅仅使用简单的“外部变量”来保存 <code class="gatsby-code-text">state</code> 相关的信息。</p>
<blockquote>
<p>这里不得不提一句，在函数式组件中插入状态(需要记忆函数内的 state)的概念，不是那么“函数式”，违背了 <code class="gatsby-code-text">pure function</code> 的理念，纯函数不应该依赖上文，也不应该每次调用的结果不一致。</p>
</blockquote>
<h2 id="单向链表存储-hook-list"><a href="#%E5%8D%95%E5%90%91%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8-hook-list" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单向链表存储 hook list</h2>
<p>另外我们根据 <a href="https://reactjs.org/docs/hooks-rules.html">hooks-rules</a> 文档知道知道 Hook 可以在一个函数内使用多次，换句话说可以拥有多个 hook，并且不能在循环，条件判断中使用，只能在函数在顶层调用，设定规则的原因是 Hook 是使用<a href="https://dev.to/aspittel/thank-u-next-an-introduction-to-linked-lists-4pph">链表数据结构</a>存储的。</p>
<p>也就是，我们只要在“外部变量”中保存 <code class="gatsby-code-text">firstHook</code> 即可，第二个 hook 为 <code class="gatsby-code-text">firstHook.next</code>，第三个为 <code class="gatsby-code-text">firstHook.next.next</code>，以此类推，所以第一步，可以定义 hook 数据结构为：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">interface</span> <span class="token class-name">hook</span> <span class="token punctuation">{</span>
  memoizedState<span class="token punctuation">:</span> any<span class="token punctuation">;</span> <span class="token comment">// 保存当前 hook 的 state</span>
  next<span class="token punctuation">:</span> hook<span class="token punctuation">;</span>         <span class="token comment">// next 指向下一个 hook</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>在 React 中使用最多，也是最简单的 hook 就是 <code class="gatsby-code-text">useState</code>，下面我们已实现 <code class="gatsby-code-text">useState</code>，同时保持和 React 相同的 API 为目标，来逐步推进：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">TeamsInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>age<span class="token punctuation">,</span> setAge<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'income'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Age: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">; Name: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>在这个例子中，使用<strong>打印数据的方式替代 React 的渲染到页面的过程</strong>，毕竟这个不是关注的重点。</p>
<p><code class="gatsby-code-text">useState</code> 接收一个值作为初始值，然后返回一个数组，数组第一项是，对应的 <code class="gatsby-code-text">state</code>，也是后面需要不断计算和更新的 <code class="gatsby-code-text">state</code>，数组第二项为一个函数 <code class="gatsby-code-text">setState</code>，用来修改 <code class="gatsby-code-text">state</code>。</p>
<p><code class="gatsby-code-text">setState</code> 第一次调用的时候会创建第一个 <code class="gatsby-code-text">hook</code>，第二次调用的时候产生第二个 <code class="gatsby-code-text">hook</code>，并挂载到第一个 <code class="gatsby-code-text">hook</code> 的 <code class="gatsby-code-text">next</code> 上，创建 <code class="gatsby-code-text">hooks</code> 链表，所以我们需要两个变量：</p>
<ul>
<li><code class="gatsby-code-text">firstHook</code>存储创建的第一个 <code class="gatsby-code-text">hook</code>,</li>
<li><code class="gatsby-code-text">lastHook</code>用来标记当前的最后一个 hook，在下一次新增 hook 的时候，可以快速的挂载到当前的 lastHook 的 next 上，这样可以避免了循环 firstHook 获取最后一个 hook，时间复杂度从 O<sup>n</sup> 降低到 O<sup>1</sup>。</li>
</ul>
<p>创建 <code class="gatsby-code-text">hook linked list</code> 的过程实现如下：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">let</span> firstHook<span class="token punctuation">:</span> hook <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> lastHook<span class="token punctuation">:</span> hook <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

<span class="token keyword">function</span> <span class="token function">mountHookLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token punctuation">{</span>
    memoizedState<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    next<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="gatsby-highlight-code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>lastHook <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="gatsby-highlight-code-line">    firstHook <span class="token operator">=</span> lastHook <span class="token operator">=</span> hook<span class="token punctuation">;</span>
</span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
</span><span class="gatsby-highlight-code-line">    lastHook <span class="token operator">=</span> lastHook<span class="token punctuation">.</span>next <span class="token operator">=</span> hook<span class="token punctuation">;</span>
</span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span>
</span>
  <span class="token keyword">return</span> lastHook<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>创建 hook 的过程肯定是放在 <code class="gatsby-code-text">useState</code> 函数内的,现在 <code class="gatsby-code-text">useState</code> 函数为：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">useState</span><span class="token punctuation">(</span>initialState<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>any<span class="token punctuation">,</span> Function<span class="token punctuation">]</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">mountHookLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="gatsby-highlight-code-line">  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> initialState<span class="token punctuation">;</span>
</span>
  <span class="token comment">// TODO:</span>
  <span class="token keyword">let</span> <span class="token function-variable function">setState</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">[</span>hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span> setState<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>使用目前自定义的 useState:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">TeamsInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>age<span class="token punctuation">,</span> setAge<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'income'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Age: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">; Name: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">[</span>setAge<span class="token punctuation">,</span> setName<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token punctuation">[</span>setAge<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">TeamsInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>firstHook<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p><code class="gatsby-code-text">firstHook</code> 的数据结构如下,其中 <code class="gatsby-code-text">memoizedState</code> 存储着初始值，<code class="gatsby-code-text">next</code> 属性指向 <code class="gatsby-code-text">name hook</code>，数据结构如下所示；</p>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/8155886335/4bed/bd29/7ec7/01e925dbbb77714a3f615e51dfa61091.png"></p>
<p>整个 <code class="gatsby-code-text">hook</code> 的链路如下：</p>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/8163787932/1456/1791/9c13/6eb05ae42e59c1daba85c5553fc0e3f2.png"></p>
<h2 id="循环链表存储-updater-queue"><a href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%AD%98%E5%82%A8-updater-queue" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>循环链表存储 updater queue</h2>
<p>现在思考一下 <code class="gatsby-code-text">setState</code> 函数该如何实现，先观察一下 <code class="gatsby-code-text">React Hooks</code> 中 <code class="gatsby-code-text">setState</code> 的表现：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">App</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>count<span class="token punctuation">,</span> setCount<span class="token punctuation">]</span> <span class="token operator">=</span> React<span class="token punctuation">.</span><span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">handleClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">setCount</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> <span class="token punctuation">(</span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">className</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>App<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">></span></span><span class="token punctuation">{</span>count<span class="token punctuation">}</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">></span></span>
      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">onClick</span><span class="token script language-javascript"><span class="token script-punctuation punctuation">=</span><span class="token punctuation">{</span>handleClick<span class="token punctuation">}</span></span><span class="token punctuation">></span></span><span class="token operator">+</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
  <span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>第一次点击按钮之后，count 重新渲染为 2,计算过程为<code class="gatsby-code-text">0 + 1 = 1</code>，<code class="gatsby-code-text">1 * 2 = 2</code>：</p>
<p>请注意一个非常关键的点，点击按钮调用了两次 <code class="gatsby-code-text">setCount</code>， 但是只触发了一次更新，可以推断<strong>setCount()函数调用本身并没有触发 count 的计算，count 的计算是发生在 React 再次渲染过程中调用 useState 重新计算得到的值</strong>，也就是说<code class="gatsby-code-text">setCount</code>仅仅是存储了 count 的计算方法，而不是直接触发了数据计算。</p>
<blockquote>
<p>这里不要混淆 class component 的合并 <code class="gatsby-code-text">this.setState</code>,请注意合并 <code class="gatsby-code-text">this.setState</code>，也并不是所有情况下都成立的，<code class="gatsby-code-text">this.setState((x)=&gt; x + 1)</code>的调用方式就不会合并，读者可以自行做个简单的<a href="https://codesandbox.io/s/lucid-pike-88kx8?file=/src/App.js">测试</a>。</p>
</blockquote>
<p>因为可以连续调用<code class="gatsby-code-text">setState</code>，所以需要一个<strong>队列</strong>来保存所有 state 的计算方法，这个队列应该挂载到 hook 对象上，这样就能区分每个 hook 的计算逻辑，因为 <code class="gatsby-code-text">setState</code> 可能会触发很多次，为了性能考虑该队列采用循环链表的方式存储：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">interface</span> <span class="token class-name">queue</span> <span class="token punctuation">{</span>
  last<span class="token punctuation">:</span> updater<span class="token punctuation">;</span> <span class="token comment">// 最后一个updater</span>
<span class="token punctuation">}</span>

<span class="token keyword">interface</span> <span class="token class-name">updater</span> <span class="token punctuation">{</span>
  action<span class="token punctuation">:</span> Function <span class="token operator">|</span> any<span class="token punctuation">;</span> <span class="token comment">// 更新函数</span>
  next<span class="token punctuation">:</span> updater<span class="token punctuation">;</span> <span class="token comment">// 下一个updater</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">dispatchAction</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> action<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> updater <span class="token operator">=</span> <span class="token punctuation">{</span> action<span class="token punctuation">,</span> next<span class="token punctuation">:</span> <span class="token keyword">null</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token comment">// 将updater对象添加到循环链表中</span>
  <span class="token keyword">const</span> last <span class="token operator">=</span> queue<span class="token punctuation">.</span>last<span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>last <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 链表为空，将当前更新作为第一个，并保持循环</span>
    updater<span class="token punctuation">.</span>next <span class="token operator">=</span> updater<span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> first <span class="token operator">=</span> last<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 在最新的updater对象后面插入新的updater对象</span>
      updater<span class="token punctuation">.</span>next <span class="token operator">=</span> first<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    last<span class="token punctuation">.</span>next <span class="token operator">=</span> updater<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 将表头保持在最新的updater对象上</span>
  queue<span class="token punctuation">.</span>last <span class="token operator">=</span> updater<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>现在只需要把 <code class="gatsby-code-text">queue</code> 挂载到 <code class="gatsby-code-text">hook</code> 上,并通过 <a href="https://sylvenas.github.io/blog/2017/11/23/FP6-Curry-and-PartialApplication.html">bind</a> 方法闭包 <code class="gatsby-code-text">queue</code> 到 <code class="gatsby-code-text">dispatcher</code> 函数中,这样在添加计算函数的时候，可以添加到指定的 <code class="gatsby-code-text">queue</code> 中：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">useState</span><span class="token punctuation">(</span>initialState<span class="token punctuation">:</span> any<span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>any<span class="token punctuation">,</span> Function<span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> hook <span class="token operator">=</span> <span class="token function">mountHookLinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  hook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> initialState<span class="token punctuation">;</span>

<span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">(</span>hook<span class="token punctuation">.</span>queue <span class="token operator">=</span> <span class="token punctuation">{</span>
</span>    last<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    dispatch<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> dispatcher <span class="token operator">=</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>dispatch <span class="token operator">=</span> dispatchAction<span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> queue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">[</span>hook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">,</span> dispatcher<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>现在 <code class="gatsby-code-text">hook</code> 的创建以及 <code class="gatsby-code-text">updater</code> 队列的添加逻辑已经完成.</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">TeamsInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>age<span class="token punctuation">,</span> setAge<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> <span class="token punctuation">[</span>name<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">useState</span><span class="token punctuation">(</span><span class="token string">'income'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Age: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">; Name: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> <span class="token punctuation">[</span>setAge<span class="token punctuation">,</span> setName<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token punctuation">[</span>setAge<span class="token punctuation">,</span> setName<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">TeamsInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="gatsby-highlight-code-line"><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="gatsby-highlight-code-line"><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">+</span> <span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="gatsby-highlight-code-line"><span class="token function">setAge</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>firstHook<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>所有的数据都挂载到了 <code class="gatsby-code-text">firstHook</code> 上，所以我们打印了 <code class="gatsby-code-text">firstHook</code> 的数据结构如下：</p>
<p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/8156078893/8aa1/8f81/21d3/62dc163e9c7c21b99c3fc9342e0ffe18.png"></p>
<p>现在对着图片进行一次回顾，<code class="gatsby-code-text">firstHook</code> 的三个属性，<code class="gatsby-code-text">memoizedState</code>指向初始值 <code class="gatsby-code-text">18</code>，<code class="gatsby-code-text">queue</code> 存储了所有的数据计算 <code class="gatsby-code-text">updater</code> (注意 <code class="gatsby-code-text">queue</code> 是一个循环链表)，<code class="gatsby-code-text">next</code> 属性指向第二个 <code class="gatsby-code-text">hook</code>(name 相关)，第二个 <code class="gatsby-code-text">hook</code> 的数据结构和 <code class="gatsby-code-text">firstHook</code> 完类似。</p>
<p>在添加数据更新队列之后，目前 <code class="gatsby-code-text">hook</code> 链表如下：</p>
<p><img src="https://p6.music.126.net/obj/wo3DlcOGw6DClTvDisK1/8163959419/4d6b/dab9/15e2/c0040ff64e63c55103a8b49e9fbe99f6.png"></p>
<h2 id="计算最新的值"><a href="#%E8%AE%A1%E7%AE%97%E6%9C%80%E6%96%B0%E7%9A%84%E5%80%BC" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>计算最新的值</h2>
<p>由于 hooks 在每次重新渲染的时候(re-call the function)都是一样的，所以在重新渲染的时候没必要重新创建 hooks 的单向链表，只要根据 queue 的环形链表存储的计算逻辑进行循环计算即可，所以我们需要一个变量 <code class="gatsby-code-text">mounted</code> 存储是否是首次渲染:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 首次渲染完成</span>
<span class="token keyword">let</span> mounted<span class="token punctuation">:</span> boolean <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">TeamsInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="gatsby-highlight-code-line">  mounted <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>setAge<span class="token punctuation">,</span> setName<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>然后在第二，三，四…次渲染的时候，都会跳过创建 hook 的过程，直接进入计算逻辑：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">useState</span><span class="token punctuation">(</span>initialState<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="gatsby-highlight-code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>mounted<span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="gatsby-highlight-code-line">    <span class="token keyword">return</span> <span class="token function">updateState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span>
</span>  <span class="token comment">// ...</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p><code class="gatsby-code-text">updateState</code> 函数的主要逻辑就是循环 <code class="gatsby-code-text">queue</code> 环形链表，根据初始值，计最终的结果，然后赋值给 <code class="gatsby-code-text">hook.memoizedState</code>，<strong>并且要清空 queue 环形链，这样做的原因是本次渲染已经完成，下一个周期内的计算 state 的逻辑和本次未必相同，所以清空；下一个周期会重新添加 updater 到 queue cycle linked list</strong>。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">updateState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>any<span class="token punctuation">,</span> Function<span class="token punctuation">]</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>currentUpdateHook <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    currentUpdateHook <span class="token operator">=</span> firstHook<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">const</span> queue <span class="token operator">=</span> currentUpdateHook<span class="token punctuation">.</span>queue<span class="token punctuation">;</span>
<span class="gatsby-highlight-code-line">  <span class="token keyword">const</span> last <span class="token operator">=</span> queue<span class="token punctuation">.</span>last<span class="token punctuation">;</span>
</span>  <span class="token keyword">let</span> first <span class="token operator">=</span> last <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">?</span> last<span class="token punctuation">.</span>next <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">;</span>

  <span class="token keyword">let</span> newState <span class="token operator">=</span> currentUpdateHook<span class="token punctuation">.</span>memoizedState<span class="token punctuation">;</span>

<span class="gatsby-highlight-code-line">  <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="gatsby-highlight-code-line">    <span class="token keyword">let</span> update <span class="token operator">=</span> first<span class="token punctuation">;</span>
</span><span class="gatsby-highlight-code-line">    <span class="token keyword">do</span> <span class="token punctuation">{</span>
</span><span class="gatsby-highlight-code-line">      <span class="token comment">// 执行每一次更新，去更新状态</span>
</span><span class="gatsby-highlight-code-line">      <span class="token keyword">const</span> action <span class="token operator">=</span> update<span class="token punctuation">.</span>action<span class="token punctuation">;</span>
</span><span class="gatsby-highlight-code-line">      <span class="token comment">// 函数则调用</span>
</span><span class="gatsby-highlight-code-line">      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> action <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
</span><span class="gatsby-highlight-code-line">        newState <span class="token operator">=</span> <span class="token function">action</span><span class="token punctuation">(</span>newState<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="gatsby-highlight-code-line">      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
</span><span class="gatsby-highlight-code-line">        newState <span class="token operator">=</span> action<span class="token punctuation">;</span>
</span><span class="gatsby-highlight-code-line">      <span class="token punctuation">}</span>
</span><span class="gatsby-highlight-code-line">      update <span class="token operator">=</span> update<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
</span><span class="gatsby-highlight-code-line">    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>update <span class="token operator">!==</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> update <span class="token operator">!==</span> first<span class="token punctuation">)</span><span class="token punctuation">;</span>
</span><span class="gatsby-highlight-code-line">  <span class="token punctuation">}</span>
</span>
  currentUpdateHook<span class="token punctuation">.</span>memoizedState <span class="token operator">=</span> newState<span class="token punctuation">;</span>
  <span class="token comment">// 关键代码，执行一轮调用之后要把更新队列清空，在下一轮的调用中重新添加队列</span>
<span class="gatsby-highlight-code-line">  queue<span class="token punctuation">.</span>last <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
</span>  currentUpdateHook <span class="token operator">=</span> currentUpdateHook<span class="token punctuation">.</span>next<span class="token punctuation">;</span>

  <span class="token keyword">const</span> dispatch <span class="token operator">=</span> queue<span class="token punctuation">.</span>dispatch<span class="token punctuation">;</span>

  <span class="token comment">// 返回最新的状态和修改状态的方法</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>newState<span class="token punctuation">,</span> dispatch<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>到现在为止我们已经完成了 hook 的创建，添加更新方法，re-render 计算最新的 state 的整个链路，hook 分为 mount 阶段和 update 阶段的链路图，如下所示：</p>
<p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/8164082314/fb2f/7f50/4577/dbe0756881d058dbccef364c3c405dcf.png"></p>
<p>完整代码: <a href="https://gist.github.com/Sylvenas/28d23025ff369ab63c95cd8a40122d4c">GitHub Gist</a></p>
<h3 id="hook-链表存放在哪里？"><a href="#hook-%E9%93%BE%E8%A1%A8%E5%AD%98%E6%94%BE%E5%9C%A8%E5%93%AA%E9%87%8C%EF%BC%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>hook 链表存放在哪里？</h3>
<p>从前面创建 hooks 单向链表的过程可以看出来，我们所有的数据的入口都是放在 <code class="gatsby-code-text">firstHook</code> 上，目前 <code class="gatsby-code-text">firstHook</code> 是作为一个函数“外部变量”存储在“全局环境”中的。</p>
<p>在 React 中，这个 <code class="gatsby-code-text">firstHook</code> 实际上是挂载到该组件对应的 <code class="gatsby-code-text">fiberNode.memoizedState</code> 属性上的，如图所示：</p>
<p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/8164187813/c844/e330/629b/07d5a006885d54a9c0e81b8a874b21cd.png"></p>
<p><code class="gatsby-code-text">fiber node</code> 的数据结构本篇文章不再重复讲解，可以参考 <a href="/blog/2019/03/04/react-fiber.html">React Fiber 中为何以及如何使用链表遍历组件树
</a></p>
<h3 id="next"><a href="#next" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>next</h3>
<p>实现<code class="gatsby-code-text">useEffect</code></p>]]></description><link>https://reactjs.org/blog/2021/03/30/react-hooks.html</link><guid isPermaLink="false">https://reactjs.org/blog/2021/03/30/react-hooks.html</guid><pubDate>Mon, 29 Mar 2021 16:00:00 GMT</pubDate></item><item><title><![CDATA[被讨厌的勇气]]></title><description><![CDATA[<h3 id="人生是一连串的刹那"><a href="#%E4%BA%BA%E7%94%9F%E6%98%AF%E4%B8%80%E8%BF%9E%E4%B8%B2%E7%9A%84%E5%88%B9%E9%82%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>人生是一连串的刹那 　　</h3>
<p>哲人：明白了。你所说的远大目标就好比登山时以山顶为目标。 　   　</p>
<p>青年：是的，就是这样。人人都会以山顶为目标吧！ 　　</p>
<p>哲人：但是，假如人生是为了到达山顶的登山，那么人生的大半时光就都是在“路上”。也就是说，“真正的人生”始于登上山顶的时候，那之前的路程都是“临时的我”走过的“临时的人生”。 　　</p>
<p>青年：可以这么说。现在的我正是在路上的人。 　　</p>
<p>哲人：那么，假如你没能到达山顶的话，你的人生会如何呢？有时候会因为事故或疾病而无法到达山顶，登山活动本身也很有可能以失败告终。“在路上”“临时的我”，还有“临时的人生”，人生就此中断。这种情况下的人生又是什么呢？ 　　</p>
<p>青年：那……那是自作自受！我没有能力、没有足以登上山顶的体力、没有好的运气、没有足够的实力，仅此而已！是的，我也做好了接受这种现实的准备！ 　　</p>
<p>哲人：阿德勒心理学的立场与此不同。把人生当作登山的人其实是把自己的人生看成了一条“线”。自降生人世那一瞬间便己经开始的线，画着大大小小形形色色的曲线到达顶点，最终迎来“死”这一终点。但是，这种把人生理解为故事的想法与弗洛伊德式的原因论紧密相关，而且会把人生的大半时光当作“在路上”。 　　</p>
<p>青年：那么，您认为人生是什么样的呢？ 　　</p>
<p>哲人：请不要把人生理解为一条线，而要理解成点的连续。如果拿放大镜去看用粉笔画的实线，你会发现原本以为的线其实也是一些连续的小点。看似像线一样的人生其实也是点的连续，也就是说<strong>人生是连续的刹那</strong>。 　　</p>
<p>青年：连续的刹那？ 　　</p>
<p>哲人：是的，是“现在”这一刹那的连续。我们只能活在“此时此刻”，我们的人生只存在于刹那之中。不了解这一点的大人们总是想要强迫年轻人过“线”一样的人生。<strong>在他们看来，上好大学、进好企业、拥有稳定的家庭，这样的轨道才是幸福的人生。但是，人生不可能是一条线</strong>。 　　</p>
<p>青年：您是说没必要进行人朱规划或者职业规划？ 　　</p>
<p>哲人：如果人生是一条线，那么人生规划就有可能。但是，我们的人生只是点的连续。计划式的人生不是有没有必要，而是根本不可能。 　　</p>
<p>青年：哎呀，太无聊了！多么愚蠢的想法！ 　　 </p>
<h3 id="舞动人生"><a href="#%E8%88%9E%E5%8A%A8%E4%BA%BA%E7%94%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>舞动人生 　　</h3>
<p>哲人：哪里有问题呢？ 　　</p>
<p>青年：你的主张不仅否定了人生的计划性，甚至还否定了努力！例如，自幼便梦想着成为小提琴手而拼命练习的人，最终进入了梦寐以求的乐团；或者是拼命学习通过司法考试的人最终成了律师。这些都是没有目标和计划的人绝对不可能实现的人生！ 　　</p>
<p>哲人：也就是他们以山顶为目标默默前行？ 　　</p>
<p>青年：当然！ 　　</p>
<p>哲人：果真如此吗？也许是这些人在人生的每一个瞬间都活在“此时此刻”吧。也就是说，不是活在“在路上”的人生之中，而是时常活在“此时此刻”。例如，梦想着成为小提琴手的人也许总是只看见眼前的乐曲，将注意力集中于这一首曲子、这一个小节、这一个音上面。 　　</p>
<p>青年：这样能够实现目标吗？ 　　</p>
<p>哲人：请你这样想。人生就像是在每一个瞬间不停旋转起舞的连续的刹那。并且，暮然四顾时常常会惊觉：“已经来到这里了吗？” 在跳着小提琴之舞的人中可能有人成了专业小提琴手，在跳着司法考试之舞的人中也许有人成为律师，或许还有人跳着写作之舞成了作家。当然，也有可能有着截然不同的结果。但是，所有的人生都不是终结“在路上”，只要跳着舞的“此时此刻”充实就已经足够。 　　</p>
<p>青年：只要跳好当下就可以？ 　　</p>
<p>哲人：是的。在舞蹈中，跳舞本身就是目的，最终会跳到哪里谁都不知道。当然，作为跳的结果最终会到达某个地方。因为一直在跳动所以不会停在原地。但是，并不存在目的地。 　　</p>
<p>青年：怎么能有不存在目的地的人生呢？！谁会承认这种游移不定、随风飘摇的人生呢？！ 　　</p>
<p>哲人：你所说的想要到达目的地的人生可以称为“潜在性的人生”。与此相对，我所说的像跳舞一样的人生则可以称为“现实性的人生”。 　　</p>
<p>青年：潜在性和现实性？ 　　</p>
<p>哲人：我们可以引用亚里士多德的说明。一般性的运动——我们把这叫作移动——有起点和终点。从起点到终点的运动最好是尽可能地高效而快速。如果能够搭乘特快列车的话，那就没有必要乘坐各站都停的普通列车。</p>
<p>青年：也就是说，如果有了想要成为律师这个目的地，那就最好是尽早尽快地到达。 　　</p>
<p>哲人：是的。并且，到达目的地之前的路程在还没有到达目的地这个意义上来讲并不完整。这就是潜在性的人生。 　　</p>
<p>青年：也就是半道？ 　　</p>
<p>哲人：是这样。另一方面，现实性运动是一种“当下做了当下即完成”的运动。 　　</p>
<p>青年：当下做了当下即完成？ 　　</p>
<p>哲人：用别的话说也可以理解为“把过程本身也看作结果的运动”，跳舞是如此，旅行等本身也是如此。 　　</p>
<p>青年：啊，我有些乱了……旅行究竟是怎么回事呢？ 　　</p>
<p>哲人：旅行的目的是什么？例如你要去埃及旅行。这时候你会想尽早尽快地到达胡夫金字塔，然后再以最短的距离返回吗？如果是这样的话，那就不能称为旅行。跨出家门的那一瞬间，“旅行”已经开始，朝着目的地出发途中的每一个瞬间都是旅行。当然，即使因为某些事情而没能够到达金字塔，那也并非没有旅行。这就是现实性的人生。 　　</p>
<p>青年：哎呀，我还是不明白啊。您刚才否定了以山顶为目标的价值观吧？那如果把这种现实性的人生比喻为登山又会如何呢？ 　　</p>
<p>哲人：如果登山的目的是登上山顶，那它就是潜在性的行为。说得极端点儿，乘坐电梯登上山顶，逗留5分钟，然后再乘电梯回来也可以。当然，如果没能到达山顶的话，其登山活动就等于失败。但是，如果登山的目的不是登顶而是登山本身，那就可以说是现实性的活动。最终能不能登上山顶都没有关系。 　　</p>
<p>青年：这种论调根本不成立！先生，你完全陷入了自我矛盾之中。在你于世人面前丢脸之前，让我先来揭穿你吧！ 　　</p>
<p>哲人：噢，那太好了！ 　　 </p>
<h3 id="最重要的是此时此刻"><a href="#%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84%E6%98%AF%E6%AD%A4%E6%97%B6%E6%AD%A4%E5%88%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>最重要的是“此时此刻” 　　</h3>
<p>青年：先生在否定原因论的时候也否定了关注过去。您说过去并不存在，过去没有意义。这一点我同意。过去的确无法改变，能改变的只有未来。但是，现在通过说明现实性生活方式又否定了计划性，也就是否定了按照自己的意思改变未来。您既否定往后看，同时也否定朝前看。这简直就是说要在没路的地方盲目前行呀！ 　　</p>
<p>哲人：你是说既看不见后面也看不到前面？ 　　</p>
<p>青年：看不见！ 　　</p>
<p>哲人：这不是很自然的事情吗？究竟哪里有问题呢？ 　　</p>
<p>青年：您、您说什么？！ 　　</p>
<p>哲人：请你想象一下自己站在剧场舞台上的样子。此时，如果整个会场都开着灯，那就可以看到观众席的最里边。但是，如果强烈的聚光灯打向自己，那就连最前排也看不见。我们的人生也完全一样。正因为把模糊而微弱的光打向人生整体，所以才能够看到过去和未来；不，是感觉能够看得到。但是，如果把强烈的聚光灯对准“此时此刻”，那就会既看不到过去也看不到未来。 　　</p>
<p>青年：强烈的聚光灯？ 　　</p>
<p>哲人：是的。我们应该更加认真地过好“此时此刻”。如果感觉能够看得到过去也能预测到未来，那就证明你没有认真地活在“此时此刻”，而是生活在模糊而微弱的光中。人生是连续的刹那，根本不存在过去和未来。你是想要通过关注过去或未来为自己寻找免罪符。过去发生了什么与你的“此时此刻”没有任何关系，未来会如何也不是“此时此刻”要考虑的问题。假如认真地活在“此时此刻”，那就根木不会说出那样的话。 　　</p>
<p>青年：但、但是…… 　　</p>
<p>哲人：如果站在弗洛伊德式原因论的立场上，那就会把人生理解为基于因果律的一个长故事。何时何地出生、度过了什么样的童年时代、从什么样的学校毕业、进了什么样的公司，正是这些因素决定了现在的我和将来的我。 的确，把人生当作故事是很有趣的事情。但是，在故事的前面部分就能看到“模糊的将来”；并且，人们还会想要按照这个故事去生活。我的人生就是这样，所以我只能照此生活，错不在我而在于过去和环境。这里搬出来的过去无非是一种免罪符，是人生的谎言。但是，人生是点的连续、是连续的刹那。如果能够理解这一点，那就不再需要故事。 　　</p>
<p>青年：如果这么说的话，阿德勒所说的生活方式不也是一种故事吗？！ 　　</p>
<p>哲人：生活方式说的是“此时此刻”，是可以按照自己意志改变的事情。像直线一样的过去的生活只不过是在你反复下定决心“不做改变”的基础上才貌似成了直线而己。并且，将来的人生也完全是一张白纸，并未铺好行进的轨道。这里没有故事。 　　</p>
<p>青年：但是，这是一种逍遥主义！不，应该说是更加恶劣的享乐主义！ 　　</p>
<p>哲人：不！聚焦“此时此刻”是认真而谨慎地做好现在能做的事情。 　　 </p>
<h3 id="对决人生最大的谎言"><a href="#%E5%AF%B9%E5%86%B3%E4%BA%BA%E7%94%9F%E6%9C%80%E5%A4%A7%E7%9A%84%E8%B0%8E%E8%A8%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>对决“人生最大的谎言” 　　</h3>
<p>青年：认真而谨慎地生活？ 　　</p>
<p>哲人：例如，虽然想上大学但却不想学习，这就是没有认真过好“此时此刻”的态度。当然，考试也许是很久之后的事情，也不知道该学到什么程度，所以也许会感到麻烦。但是，每天进步一点点也可以，解开一个算式或者记住一个单词都可以。也就是要不停地跳舞。如此一来，势必会有“今天能够做到的事情”。今天这一天就为此存在，而不是为遥远的将来的考试而存在。 又或者，你父亲也是在认真地做好每一天的工作，与远大目标或者那种目标的实现没有关系，只是认真地过好“此时此刻”。假若如此，你父亲的人生应该是很幸福的。 　　</p>
<p>青年：您是对我说应该肯定那种生活方式？认可父亲那种整日忙于工作的姿态？ 　　</p>
<p>哲人：没有必要勉强去认可。只是，不要用线的形式去看其到达了哪里，而是应该去关注其如何度过这一刹那， 　　</p>
<p>青年：关注刹那…… 　　</p>
<p>哲人：<strong>你自己的人生也同样。为遥远的将来设定一个目标，并认为现在是其准备阶段。一直想着“真正想做的是这样的事情，等时机到了就去做”，是一种拖延人生的生活方式。只要在拖延人生，我们就会无所进展，只能每天过着枯燥乏味的单调生活。因为在这种情况下，人就会认为“此时此刻”只是准备阶段和忍耐阶段。但是，为了遥远将来的考试而努力学习的“此时此刻”却是真实的存在。</strong> 　　</p>
<p>青年：是的，我承认！认真过好“此时此刻”、不去设定根本不存在的线，这些我的确认同！但是先生，我找不到理想和目标，就连应该跳什么舞都不知道，我的“此时此刻”只有一些毫无用处的刹那！ 　　</p>
<p>哲人：没有目标也无妨。认真过好“此时此刻”，这本身就是跳舞。不要把人生弄得太深刻。请不要把认真和深刻混为一谈。 　　</p>
<p>青年：认真但不深刻。 　　</p>
<p>哲人：是的。人生很简单，并不是什么深刻的事情。如果认真过好了每一个刹那，就没有什么必要令其过于深刻。 并且还要记住一点。站在现实性角度的时候，人生总是处于完结状态。 　　</p>
<p>青年：完结状态？ 　　</p>
<p>哲人：你还有我，即使生命终结于“此时此刻”，那也并不足以称为不幸。无论是20岁终结的人生还是90岁终结的人生，全都是完结的、幸福的人生。 　　</p>
<p>青年：您是说假如我认真过好了“此时此刻”，那每一个刹那就都是一种完结？ 　　</p>
<p>哲人：正是如此。前面我说过好几次“人生谎言”这个词。最后，我还要说一下人生中最大的谎言。 　　</p>
<p>青年：洗耳恭听。 　　</p>
<p>哲人：<strong>人生中最大的谎言就是不活在“此时此刻”。纠结过去、关注未来，把微弱而模糊的光打向人生整体，自认为看到了些什么。你之前就一直忽略“此时此刻”，只关注根本不存在的过去和未来。对自己的人生和无可替代的刹那撒了一个大大的谎言。</strong> 　　</p>
<p>青年：啊！ 　　</p>
<p>哲人：来吧，甩开人生的谎言，毫不畏惧地把强烈的聚光灯打向“此时此刻”。你一定能做到！ 　　</p>
<p>青年：我……我能做到吗？不依赖人生谎言、认真过好每一个刹那，您认为我有这种“勇气”吗？ 　　</p>
<p>哲人：因为过去和未来根本不存在，所以才要谈现在。起决定作用的既不是昨天也不是明天，而是“此时此刻”。</p>
<p>— 岸见一郎 ， 古贺史健</p>
<hr>
<p>世界很简单，人生也是一样。</p>]]></description><link>https://reactjs.org/blog/2020/05/14/被讨厌的勇气.html</link><guid isPermaLink="false">https://reactjs.org/blog/2020/05/14/被讨厌的勇气.html</guid><pubDate>Wed, 13 May 2020 16:00:00 GMT</pubDate></item><item><title><![CDATA[自然变换 - Natural Transformation]]></title><description><![CDATA[<h3 id="自然变换"><a href="#%E8%87%AA%E7%84%B6%E5%8F%98%E6%8D%A2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>自然变换</h3>
<p>所谓自然变换也也就是变化包裹值的容器盒子：<code class="gatsby-code-text">F(x) =&gt; G(x)</code>,举个简单的例子，把Either转换为Task:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">eitherToTask</span> <span class="token operator">=</span> e <span class="token operator">=></span>
    e<span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span>rejected<span class="token punctuation">,</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">eitherToTask</span><span class="token punctuation">(</span><span class="token function">Right</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>err <span class="token operator">=></span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'err'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> x <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'res'</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// res hello</span>

<span class="token keyword">const</span> res2 <span class="token operator">=</span> <span class="token function">eitherToTask</span><span class="token punctuation">(</span><span class="token function">Left</span><span class="token punctuation">(</span><span class="token string">'errrrrr'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>err <span class="token operator">=></span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'err'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> x <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'res'</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// err errrrrr</span></code></pre>
      </div>
<h3 id="同构"><a href="#%E5%90%8C%E6%9E%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同构</h3>
<p>前面我们介绍过Task 是一种Lazy Promise的概念，那么是否可以将Task转为promise呢？答案是肯定的！</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"> <span class="token comment">// taskToPromise :: Task a b -> Promise a b</span>
<span class="token keyword">const</span> <span class="token function-variable function">taskToPromise</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span> x<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> task <span class="token operator">=</span> <span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rej<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">res</span><span class="token punctuation">(</span><span class="token string">'hello taskToPromise'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">200</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">taskToPromise</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>x <span class="token operator">=></span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> x <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'something went wrong'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// => hello taskToPromise</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// => Promise { &lt;pending> }</span></code></pre>
      </div>
<p>同样的，我们也可以把Promise转换为Task</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">promiseToTask</span> <span class="token operator">=</span> p <span class="token operator">=></span> <span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span> <span class="token operator">=></span> p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>reject<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> promise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'hello promiseToTask'</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">promiseToTask</span><span class="token punctuation">(</span>promise<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>
        err <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'something went wrong'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
        x <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// => hello promiseToTask</span></code></pre>
      </div>
<p><strong>Note：</strong>我们没办法实现<code class="gatsby-code-text">taskToEither</code>,因为我们不能把一个异步的逻辑转换为同步的过程，这个是不合理的，因为异步的结果，必须要等到异步call back的时候才能拿到。</p>
<h3 id="定律"><a href="#%E5%AE%9A%E5%BE%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>定律</h3>
<h4 id="nthfxmapf--ntfxmapf"><a href="#nthfxmapf--ntfxmapf" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>nth(fx).map(f) == nt(fx.map(f))</h4>
<p>也就是先进行map然后自然变换和先自然变化然后map的结果是一样的</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">    <span class="token comment">// 因为nt必须满足这个定律所以boxToEither必须使用Right,因为left会跳过map</span>
    <span class="token keyword">const</span> <span class="token function-variable function">boxToEither</span> <span class="token operator">=</span> b <span class="token operator">=></span>
        b<span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>Right<span class="token punctuation">)</span>

    <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">boxToEither</span><span class="token punctuation">(</span><span class="token function">Box</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token comment">// Right(400)</span>

    <span class="token keyword">const</span> res2 <span class="token operator">=</span> <span class="token function">boxToEither</span><span class="token punctuation">(</span><span class="token function">Box</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res2<span class="token punctuation">)</span> <span class="token comment">// Right(400)</span></code></pre>
      </div>
<h4 id="自然变换的目的"><a href="#%E8%87%AA%E7%84%B6%E5%8F%98%E6%8D%A2%E7%9A%84%E7%9B%AE%E7%9A%84" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>自然变换的目的</h4>
<p>是为了函数组合，其实我们目前所做的所有努力都是为了让函数组合更方便,是想如果自然变换，我们怎么进行不同容器的chain和map呢？</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">fake</span> <span class="token operator">=</span> id <span class="token operator">=></span>
    <span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`user</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">,</span> best_friend_id<span class="token punctuation">:</span> id <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> Db <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    find<span class="token punctuation">:</span> id <span class="token operator">=></span>
        <span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rej<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token function">res</span><span class="token punctuation">(</span>id <span class="token operator">></span> <span class="token number">2</span> <span class="token operator">?</span> <span class="token function">Right</span><span class="token punctuation">(</span><span class="token function">fake</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">Left</span><span class="token punctuation">(</span><span class="token string">'not found'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">eitherToTask</span> <span class="token operator">=</span> e <span class="token operator">=></span>
    e<span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span>rejected<span class="token punctuation">,</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">app</span> <span class="token operator">=</span> id <span class="token operator">=></span> Db<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token comment">// Task(Right(user))</span>
    <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>eitherToTask<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>user <span class="token operator">=></span> Db<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>best_friend_id<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>eitherToTask<span class="token punctuation">)</span>

<span class="token function">app</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>error<span class="token punctuation">,</span> console<span class="token punctuation">.</span>log<span class="token punctuation">)</span> <span class="token comment">// { id: 4, name: 'user4', best_friend_id: 5 }</span>
<span class="token function">app</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>error<span class="token punctuation">,</span> console<span class="token punctuation">.</span>log<span class="token punctuation">)</span> <span class="token comment">//not found</span></code></pre>
      </div>]]></description><link>https://reactjs.org/blog/2020/05/02/自然变换.html</link><guid isPermaLink="false">https://reactjs.org/blog/2020/05/02/自然变换.html</guid><pubDate>Fri, 01 May 2020 16:00:00 GMT</pubDate></item><item><title><![CDATA[遍历与队列 - Traversable]]></title><description><![CDATA[<h3 id="array-insideout"><a href="#array-insideout" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Array insideOut</h3>
<p>假如我们现在有一个数字的数组，我们要把这些数字转换为对应的26个英文字母，但是这个转换肯能会失败，因为并不是所有的数字都是可以转换的，所以这种情况下我们可以使用Either来处理转换成功和转换失败：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">toChar</span> <span class="token operator">=</span> n <span class="token operator">=></span> n <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> n <span class="token operator">></span> <span class="token number">25</span>
  <span class="token operator">?</span> <span class="token function">Left</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token string">' is out of bounds!'</span><span class="token punctuation">)</span>
  <span class="token punctuation">:</span> <span class="token function">Right</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">65</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>下面继续使用<code class="gatsby-code-text">toChar</code>函数:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">  <span class="token keyword">const</span> res2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>toChar<span class="token punctuation">)</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res2<span class="token punctuation">)</span> <span class="token comment">// [ Right(A), Right(B), Right(C) ]</span></code></pre>
      </div>
<p>看上去问题不大！但是感觉怪怪的啊！或许我们理想的结果是<code class="gatsby-code-text">Right([A,B,C])</code>?</p>
<p>类似的例子:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">httpGet</span> <span class="token operator">=</span> name <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>rej<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">res</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> 

<span class="token keyword">const</span> nameList <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'James'</span><span class="token punctuation">,</span><span class="token string">'Melo'</span><span class="token punctuation">]</span>

nameList<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>name <span class="token operator">=></span> <span class="token function">httpGet</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// => [Promise,Promise]</span>

<span class="token comment">// 我们一般不会这么操作的，我们会借助Promise.all来完成这个过程</span>
Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>nameList<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>name <span class="token operator">=></span> <span class="token function">httpGet</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// => Promise([])</span></code></pre>
      </div>
<p>现在回头看一下，我们如何把<code class="gatsby-code-text">[Right(A),Right(B),Right(C)]</code>转换为<code class="gatsby-code-text">Right([A,B,C])</code>呢？实际上这是一个<code class="gatsby-code-text">insideOut</code>的过程，也就是把<code class="gatsby-code-text">Right(A)</code>,<code class="gatsby-code-text">Right(B)</code>从Array中解救出来，然后再集合放到Right中。</p>
<p>这个过程我们可以借助Array.reduce来完成：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>toChar<span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">lift2</span> <span class="token operator">=</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> fx<span class="token punctuation">,</span> fy<span class="token punctuation">)</span> <span class="token operator">=></span> fx<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>fy<span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token function-variable function">append</span> <span class="token operator">=</span> y <span class="token operator">=></span> xs <span class="token operator">=></span> xs<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token function-variable function">insideOut</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">T</span><span class="token punctuation">,</span> xs<span class="token punctuation">)</span> <span class="token operator">=></span>
    xs<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>
        <span class="token punctuation">(</span>acc<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">lift2</span><span class="token punctuation">(</span>append<span class="token punctuation">,</span> x<span class="token punctuation">,</span> acc<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token constant">T</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">insideOut</span><span class="token punctuation">(</span>Either<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// => Right(A,B,C)    </span></code></pre>
      </div>
<p>本质上就是对一个数组先进行map,然后进行reduce(或者先reducer，然后map,结果应该是一样的)，这段代码，我们可以稍微做个抽象：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">traverse</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token constant">T</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>
        <span class="token punctuation">(</span>acc<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>append<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>acc<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token constant">T</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

 <span class="token keyword">const</span> res1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">traverse</span><span class="token punctuation">(</span>Either<span class="token punctuation">,</span> toChar<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res1<span class="token punctuation">)</span> <span class="token comment">// => Left(-1 is out of bounds!)</span>

<span class="token keyword">const</span> res2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">traverse</span><span class="token punctuation">(</span>Either<span class="token punctuation">,</span> toChar<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res2<span class="token punctuation">)</span> <span class="token comment">// => Right(A,B,C,D,E)</span></code></pre>
      </div>
<h3 id="list"><a href="#list" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>List</h3>
<p>之前我们仿照Array的<code class="gatsby-code-text">map</code>创建了一个最简单的Functor - box,现在，我们可以仿照<code class="gatsby-code-text">traverse</code>创建一个新的Functor：List</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">List</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  x<span class="token punctuation">,</span>
  map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">List</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  concat<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> y <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">List</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  ap<span class="token punctuation">:</span> o <span class="token operator">=></span> x<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f <span class="token operator">=></span> o<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token operator">=></span> acc<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  chain<span class="token punctuation">:</span> f <span class="token operator">=></span> x<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> a<span class="token punctuation">)</span> <span class="token operator">=></span> acc<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  traverse<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token constant">T</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token operator">=></span> x<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>append<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>acc<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">T</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">[</span>inspect<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`List([</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">])`</span></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

List<span class="token punctuation">.</span><span class="token function-variable function">of</span> <span class="token operator">=</span> x <span class="token operator">=></span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">List</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>List的参数原则上是一个数组；
map方法：和普通的Box有所区别在于是变换List中的每一项
concat方法：是把新项追加到数组中，然后用List重新包装,
ap方法：接收另外一个List,然后把x中func逐一应用到o的item上(注意此时x为函数的数组)，然后通过reducer合并
chain方法：接收一个函数直接把List中的每一项全部应用map，然后通过reducer合并
traverse方法：完全相同与上面介绍的Array.prototype.traverse</p>
<h4 id="list应用与并发应用"><a href="#list%E5%BA%94%E7%94%A8%E4%B8%8E%E5%B9%B6%E5%8F%91%E5%BA%94%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>List应用与并发应用</h4>
<p>得益于Applicative的并行特性，我们可以使用traverse创建更简洁的并行逻辑</p>
<p>List traverse 同步逻辑</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">app</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">List</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">traverse</span><span class="token punctuation">(</span>Either<span class="token punctuation">,</span> toChar<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>x <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'log left'</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">,</span>
        x <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'log right'</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> res1 <span class="token operator">=</span> <span class="token function">app</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// log right [ 'A', 'B', 'C', 'D' ]</span>
<span class="token keyword">const</span> res2 <span class="token operator">=</span> <span class="token function">app</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// log left  '-2 is out of bounds!-1 is out of bounds!'</span></code></pre>
      </div>
<p>List traverse 异步逻辑</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">httpGet</span> <span class="token operator">=</span> name <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span>rej<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">res</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`My name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span> 

 <span class="token keyword">const</span> users <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'melo'</span><span class="token punctuation">,</span> <span class="token string">'james'</span><span class="token punctuation">,</span> <span class="token string">'brian'</span><span class="token punctuation">]</span>

console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'getName'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span>users<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">traverse</span><span class="token punctuation">(</span>Task<span class="token punctuation">,</span> httpGet<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>x <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'log left'</span><span class="token punctuation">,</span> <span class="token keyword">typeof</span> x<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">,</span>
        x <span class="token operator">=></span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'getName'</span><span class="token punctuation">)</span> <span class="token comment">//2006.420ms</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'log right'</span><span class="token punctuation">,</span> <span class="token keyword">typeof</span> x<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token comment">// log right object ['My name is melo', 'My name is james', 'My name is brian']</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
      </div>]]></description><link>https://reactjs.org/blog/2020/04/25/遍历与队列.html</link><guid isPermaLink="false">https://reactjs.org/blog/2020/04/25/遍历与队列.html</guid><pubDate>Fri, 24 Apr 2020 16:00:00 GMT</pubDate></item><item><title><![CDATA[加法是自然之道 - Monoid]]></title><description><![CDATA[<h3 id="积木游戏"><a href="#%E7%A7%AF%E6%9C%A8%E6%B8%B8%E6%88%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>积木游戏</h3>
<blockquote>
<p>说出来你可能不信，我只花了十分钟的时间就教会三岁的小孩什么是半群,ahhhhh.jpg</p>
</blockquote>
<p>周末在家陪小侄女玩了一个小时的积木，在不断叠加积木的过程中，突然想到用搭积木的案例来描述什么是<code class="gatsby-code-text">半群</code>异常的清晰,看下面三个积木：</p>
<p><img src="" alt="红黄蓝积木"></p>
<p>看到这三个积木，(<del>是不是有一种把他们叠在一起的冲动</del>)，按照常规操作，有一部分人可能会总左向右开始叠加，也就是先把最左边的红色积木和中间的黄色积木，搭在一起；然后把最后一个蓝色叠加上，那么最后的结果是：</p>
<p><img src="" alt="积木拼接结果"></p>
<p>然后可能有另一部分人从右向左叠加，那么就是先拼接黄色和蓝色；然后最后加上红色的积木；最后得到的结果，毫无疑问和第一种是一样的，<del>你这不是废话吗!!</del></p>
<p>组合方法如果满足这种不论先拼接哪一块，最后按顺序组合在一起，得到的结果就是一样的，这被称为<strong>associative</strong>(可结合的)，积木的游戏很明显是满足这个法则的；而这个过程，我只演示了一遍，三岁的小侄女，就明白了这个道理；我觉的我们20多岁的人，可能不需要任何解释吧；</p>
<p>而满足结合律的数据类型，则可以称之为半群(Semigroup)，是不是想起来了，很常用的<code class="gatsby-code-text">Array.prototype.concat</code>就是一个完全类似的东西，下面我们给半群一个精确的定义和解释。</p>
<h3 id="半群"><a href="#%E5%8D%8A%E7%BE%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>半群</h3>
<p>一个半群(Semigroup)是带有组合方法(i.e.,<code class="gatsby-code-text">Array</code>的<code class="gatsby-code-text">concat</code>)的数据类型，假设我们的组合符号是<code class="gatsby-code-text">+</code>,那么组合方法满足结合律:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">a <span class="token operator">+</span> <span class="token punctuation">(</span>b <span class="token operator">+</span> c<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">+</span> c</code></pre>
      </div>
<p>在举个小学数学的知识来验证一下：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> c <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>

a <span class="token operator">+</span> <span class="token punctuation">(</span>b <span class="token operator">+</span> c<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token punctuation">(</span>a <span class="token operator">+</span> b<span class="token punctuation">)</span> <span class="token operator">+</span> c   <span class="token comment">// => true</span>

<span class="token keyword">const</span> e <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> f <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> g <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>

e <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>f <span class="token operator">&amp;&amp;</span> g<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token punctuation">(</span>e <span class="token operator">&amp;&amp;</span> f<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> g   <span class="token comment">// => true</span></code></pre>
      </div>
<p>Ok!让我们切换到JavaScript的世界：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span> <span class="token comment">// => true</span>

<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// [1,2,3,4,5,6,7,8,9]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span>   <span class="token comment">// [1,2,3,4,5,6,7,8,9]</span></code></pre>
      </div>
<p>由于JavaScript中<code class="gatsby-code-text">String</code>,<code class="gatsby-code-text">Array</code>类型，原型链上本身具有<code class="gatsby-code-text">cancat</code>方法，所以我们可以不断的<code class="gatsby-code-text">.concat .concat</code>;但是我们<code class="gatsby-code-text">Number</code>类型却没有，所以没法实现类似<code class="gatsby-code-text">1.concat(2).concat(3)</code>的代码；</p>
<p>回想一下第一章中的Box理念，如果我们把数字<code class="gatsby-code-text">1</code>，包裹进Box中，则我们可以调用<code class="gatsby-code-text">Box(1)</code>上面的<code class="gatsby-code-text">map</code>方法，我们可以仿照Box再创建一个容器<code class="gatsby-code-text">Sum</code>,来包裹数字,让<code class="gatsby-code-text">Sum(1)</code>拥有<code class="gatsby-code-text">concat</code>方法，看看Sum的实现：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Sum</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> y <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Sum</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>inspect<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Sum(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>下面我们可以做个验证：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// => Sum(6)</span>
<span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment">// => Sum(6)</span></code></pre>
      </div>
<p>研究明白了加法的知识，不妨继续扩展一下小学数学知识：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">a <span class="token operator">*</span> <span class="token punctuation">(</span>b <span class="token operator">*</span> c<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token punctuation">(</span>a <span class="token operator">*</span> b<span class="token punctuation">)</span> <span class="token operator">*</span>  c                   <span class="token comment">// 乘法</span>
<span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token function">max</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token function">max</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>       <span class="token comment">// 最大值</span>
<span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token function">min</span><span class="token punctuation">(</span>b<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">min</span><span class="token punctuation">(</span><span class="token function">min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">)</span>       <span class="token comment">// 最小值</span></code></pre>
      </div>
<p>相信根据<code class="gatsby-code-text">Sum</code>的案例，大家可以很轻松的写出很多类似的案例：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 对任意的 bool 类型求 并(&amp;&amp;) 的结果</span>
<span class="token keyword">const</span> <span class="token function-variable function">All</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> y <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">All</span><span class="token punctuation">(</span>x <span class="token operator">&amp;&amp;</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>inspect<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`All(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 对任意的自然数求 max(最大值) 的结果</span>
<span class="token keyword">const</span> <span class="token function-variable function">Max</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> y <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Max</span><span class="token punctuation">(</span>x <span class="token operator">></span> y <span class="token operator">?</span> x <span class="token punctuation">:</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>inspect<span class="token punctuation">]</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Max(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
      </div>
<blockquote>
<p><strong>Note:</strong>类似于<code class="gatsby-code-text">functor</code>为一个<code class="gatsby-code-text">mappable</code>的数据类型，也可以类比半群就是一个<code class="gatsby-code-text">concatible</code>的数据类型，这样更好理解</p>
</blockquote>
<blockquote>
<p>在 <a href="https://github.com/fantasyland/fantasy-land#semigroup">Fantasy Land Spec</a>中半群的结合方法也确实就叫concat)</p>
</blockquote>
<h3 id="加法是自然之道"><a href="#%E5%8A%A0%E6%B3%95%E6%98%AF%E8%87%AA%E7%84%B6%E4%B9%8B%E9%81%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>加法是自然之道</h3>
<p>让我们再次探索一下小学数学知识：我们已经不断的验证了加法满足结合律，那么减法呢？减法满足结合律吗？</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token comment">// => 2</span>
<span class="token number">5</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// => 4</span></code></pre>
      </div>
<p>这就是小学数学老师教的，做加法的时候，可以随意的添加和删除括号；而减法绝不能这样操作！</p>
<p><strong>为什么？因为减法不满足结合律！</strong></p>
<p>我们经常说道法自然，那么自然之道是什么？我认为自然是在做加法，老子道德经说“道生一，一生二，二生三，三生万物”；反映在数学上就是，假如我们创造一个数字<code class="gatsby-code-text">1</code>,然后有一个计算法则<code class="gatsby-code-text">+</code>,则我们可以很轻松很直觉的创造出所有的自然数！</p>
<p>我们平常写代码的时候，可能刚开始设计的很巧妙，思路很清晰；但是随着业务的迭代(<del>产品经理的频繁变换</del>),代码不可避免会变得很多很多；
贴一个经常吐槽Java(<del>假装很懂Java</del>)的一句话：Java的问题不是太啰嗦而是OOP使得类的数目很多。我想不管使用什么语言，代码量增多迟早会面对，而是要积极面对。面向对象原则和GOF设计模式已经在告诉我们如何维护拓展这些类代码：宁可增加新的类代码，尽量不要去修改那些经过测试已经成熟稳定的代码；也就是说不要去做修改替换，而是要做增加！这种增加如同树的自然成长，是一种干生枝，枝生叶的繁茂。</p>
<p>切换到FP的理念中，我们听了太多的<a href="">纯函数</a>,<a href="">不可变数据</a>，<a href="">避免共享状态</a>等等，细想一下不管是函数也好，数据也好，他们有一个共同点就是在原来的基础上添加(<code class="gatsby-code-text">append/concat</code>)而是修改原来的！</p>
<h3 id="幺元"><a href="#%E5%B9%BA%E5%85%83" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>幺元</h3>
<p>现在我们来看一个特殊的数字<strong>0</strong>，在加法中<code class="gatsby-code-text">0</code>是一个很特殊的存在，特殊在哪里呢？</p>
<ul>
<li>任何自然数和<code class="gatsby-code-text">0</code>相加都等于它本身：<code class="gatsby-code-text">1 + 0 = 1</code></li>
<li><code class="gatsby-code-text">0</code>可以添加到加法运算中的任意位置，而不影响计算结果：<code class="gatsby-code-text">1 + 2 + 3 = 0 + 1 + 2 + 3 = 1 + 2 + 0 + 3</code></li>
</ul>
<p>仔细思考一下，<code class="gatsby-code-text">0</code>存在的意义在哪里呢？实际上0是数学中对于自然世界中<code class="gatsby-code-text">空</code>的抽象。</p>
<p>在代码的世界中，<code class="gatsby-code-text">空</code>是一个很常见的定义，比如：空字符串<code class="gatsby-code-text">&#39;&#39;</code>,空数组<code class="gatsby-code-text">[]</code>,这些空值通常用来实现初始化的值，而这种’空值’(和任何元素结合都不会影响结果的单位元)在函数式编程中被称为<code class="gatsby-code-text">幺元(Identity Element)或者单位元</code>。用数组的例子来看就是：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span></code></pre>
      </div>
<blockquote>
<p>加号表示组合的意思，等号表示“值”相等。 </p>
</blockquote>
<p>结合半群<code class="gatsby-code-text">Sum</code>来看,很明显加法操作的幺元为<code class="gatsby-code-text">Sum(0)</code>：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Sum<span class="token punctuation">.</span><span class="token function-variable function">empty</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> res1 <span class="token operator">=</span> Sum<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// => Sum(3)</span>
<span class="token keyword">const</span> res2 <span class="token operator">=</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>Sum<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// => Sum(3)</span></code></pre>
      </div>
<p>同样对于All的幺元则为：<code class="gatsby-code-text">All.empty = () =&gt; All(true)</code>,true和任何boolean值结合都不会影响原来的值。</p>
<p>除了<code class="gatsby-code-text">Sum(0)</code>,<code class="gatsby-code-text">All(true)</code>,我们可以在代码中找到很多其他的幺元的例子，比如：<code class="gatsby-code-text">&#39;&#39;</code>,<code class="gatsby-code-text">[]</code>,<code class="gatsby-code-text">{}</code>。</p>
<p>下面我们看一个稍微特殊一点的数字：无穷大(∞)。在加法中，我们不是找到了0作为幺元吗？无穷大看上去是空数字的反面，但是它也是一个单位元，但是如何描述无穷大是数字的空元素呢？答案是使用min操作,看下面伪代码：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-text"><code class="gatsby-code-text">min(∞, x) = x;  
min(x, ∞) = x;</code></pre>
      </div>
<p>对于求最小值的操作来说，在任何地方插入无穷大都不会影响计算结果，对吧！
同样的负无穷大就是max操作的幺元；数字1就是乘法运算的幺元。现在看来多个‘空对象’是可以同时存在的，只是在不同操作下对于空的定义不同罢了。</p>
<h4 id="单元函数"><a href="#%E5%8D%95%E5%85%83%E5%87%BD%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单元函数</h4>
<p>函数式编程的核心在于函数组合，那么对于函数组合这个操作来说，它的幺元是什么呢？答案是一个很简单的单元函数(identity function):<code class="gatsby-code-text">x =&gt;x</code>,通常被简称为id。</p>
<p>单元函数是一个对函数输入没有做任何操作直接返回的函数(<code class="gatsby-code-text">id(1) === 1</code>,<code class="gatsby-code-text">id(x) === x</code>)，很明显这个函数和任意的函数进行组合，或者插入到函数组合的任意位置，都不影响函数组合的结果。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">compose</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>fns<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> fns<span class="token punctuation">.</span><span class="token function">reduceRight</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>

<span class="token function">compose</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> h<span class="token punctuation">,</span> x<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">compose</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> h<span class="token punctuation">)</span>
<span class="token function">compose</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> x<span class="token punctuation">,</span> h<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">compose</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> h<span class="token punctuation">)</span>
<span class="token function">compose</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> g<span class="token punctuation">,</span> h<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">compose</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> h<span class="token punctuation">)</span></code></pre>
      </div>
<p>通过这种组合方式，我们可以看到单元函数是函数组合操作的幺元</p>
<h3 id="广群，半群，幺半群"><a href="#%E5%B9%BF%E7%BE%A4%EF%BC%8C%E5%8D%8A%E7%BE%A4%EF%BC%8C%E5%B9%BA%E5%8D%8A%E7%BE%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>广群，半群，幺半群</h3>
<p>上面介绍了半群和幺元的概念，本质上来说是很简单的东西，平常代码中也会经常用到，只是没有特意的强化和准确的定义这个概念;下面继续介绍另一个简单的概念：广群</p>
<h4 id="广群"><a href="#%E5%B9%BF%E7%BE%A4" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>广群</h4>
<p>对于某非空集合<code class="gatsby-code-text">S</code>，若存在<code class="gatsby-code-text">S</code>上的二元运算<code class="gatsby-code-text">&quot;*&quot;</code>使得对于任意的<code class="gatsby-code-text">a,b∈S</code>,有<code class="gatsby-code-text">a*b∈S</code>（运算封闭），则称<code class="gatsby-code-text">{S,*}</code>为广群(Group)。</p>
<p>广群只是定义一个集合，集合中有元素和操作，操作结果也属于这个集合，这样泛泛的集合称为广群。　</p>
<p>如果广群再加上结合律约束，就会得到半群，因此半群是广群的子集，要求更苛刻些，而半群可以找到一个合适的<code class="gatsby-code-text">幺元</code>（identity element），则可以把该半群称为幺半群，也就是<strong><code class="gatsby-code-text">结合律</code>+<code class="gatsby-code-text">幺元</code>=<code class="gatsby-code-text">幺半群</code></strong>，所以，Monid对应的中文是幺半群。</p>
<p>所以半群是广群的子集，而幺半群很明显是半群的子集。</p>
<h3 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>
<p>这一节介绍的概念比较多，但是在我们完全理解了Functor的基础上，理解半群(<code class="gatsby-code-text">concatible</code>),幺元(<code class="gatsby-code-text">id</code>),幺半群(半群 + 幺元)就是很简单的概念；一个<code class="gatsby-code-text">monoid</code>是一个元素(也可称对象)的集合，<code class="gatsby-code-text">monoid</code>首先是一个集合，但是这个集合有一些约束条件，也就是说，是一个特殊的集合，满足结合律和幺元，这种元和其他元素结合时，并不会改变那些元素。</p>
<p>下面的一章则会进入我们函数式编程进阶的核心内容了：<code class="gatsby-code-text">Monad</code>。我们使用一句经典名言，来做个引言：</p>
<blockquote>
<p>“A monad is just a monoid in the category of endofunctors. What’s the problem?”</p>
</blockquote>]]></description><link>https://reactjs.org/blog/2020/03/02/加法是自然之道.html</link><guid isPermaLink="false">https://reactjs.org/blog/2020/03/02/加法是自然之道.html</guid><pubDate>Sun, 01 Mar 2020 16:00:00 GMT</pubDate></item><item><title><![CDATA[俄罗斯套娃娃 - Monad]]></title><description><![CDATA[<p>前面两篇分别介绍了 <a href="https://musicfe.dev/javascript-functional-programming-advance/">Functor</a> 和 <a href="https://musicfe.dev/javascript-functional-programming-functor/">Applicative</a> 的概念和实际应用，并列举了几个具体的例子，说明了 Functor 和 Applicative 的实际用途，比如：使用 <code class="gatsby-code-text">Either</code> 来处理无处不在的 <code class="gatsby-code-text">null</code> 和创建可组合的 <code class="gatsby-code-text">try-catch</code>；使用 Applicative 来做高度灵活高度可拓展的表单校验；相信读者应该已经牢牢掌握了 Functor 的核心：<strong>map-应用一个函数到包裹的值</strong>，Applicative的核心：<strong>ap-应用一个包裹的函数到一个包裹的值</strong>。</p>
<p>别忘了之前遗留的几个问题：</p>
<ul>
<li>如何解决嵌套的 <code class="gatsby-code-text">try-catch</code></li>
<li>异步函数的组合</li>
<li>Promise 也是一种 Functor ?</li>
</ul>
<p>三个问题从易到难一个一个的解决，先从第一个：嵌套的 <code class="gatsby-code-text">try-catch</code> 开始入手。</p>
<blockquote>
<p>本篇文章建立在前两篇的基础之上，所以建议先阅读前两篇的文章，再读本篇，不然可能会对某些概念和名词感到困惑</p>
</blockquote>
<h2 id="嵌套的-array"><a href="#%E5%B5%8C%E5%A5%97%E7%9A%84-array" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>嵌套的 Array</h2>
<p>Javascript Array 的 <code class="gatsby-code-text">map</code> 方法，相信开发者们都很熟悉，并且几乎在每天的编程中都会用到，但 Array 原型链上的另一个方法 <code class="gatsby-code-text">Array.prototype.flatMap</code> 可能很多人没怎么用过，从字面意思上理解就是<code class="gatsby-code-text">扁平化的 map</code>，实际作用也确实是的，看一个和 <code class="gatsby-code-text">map</code> 做对比的使用案例：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">]</span>

arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=></span> <span class="token punctuation">[</span>x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// => [[2], [4], [6], [8]]</span>

arr<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>x <span class="token operator">=></span> <span class="token punctuation">[</span>x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">)</span>  <span class="token comment">// => [2, 4, 6, 8]</span></code></pre>
      </div>
<p><code class="gatsby-code-text">flatMap</code> 相对于 <code class="gatsby-code-text">map</code> 的区别是：</p>
<ul>
<li><code class="gatsby-code-text">map</code> 是把函数执行的结果，放在一起然后装进 Box 中；</li>
<li><code class="gatsby-code-text">flatMap</code> 的结果是把<strong>函数执行的结果分别去掉一层“包装”</strong>，然后放在一起装进 Box 中</li>
</ul>
<p>所以 <code class="gatsby-code-text">flatMap</code> 相当于是先 <code class="gatsby-code-text">map</code> (映射)然后 <code class="gatsby-code-text">flat</code> (拍平)， 仅仅是多了一个“去包装”的操作！</p>
<h2 id="俄罗斯套娃"><a href="#%E4%BF%84%E7%BD%97%E6%96%AF%E5%A5%97%E5%A8%83" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>俄罗斯套娃</h2>
<p>上面介绍了 Array 的一种先 <code class="gatsby-code-text">map</code> 在 <code class="gatsby-code-text">flat</code> 的方法，Array 也是 <code class="gatsby-code-text">Box</code> 理念的一个具体实现案例，那其他的 Box 呢？比如前面两篇一直在用的 <code class="gatsby-code-text">Either</code> 又是如何实现的呢？从一个更简单的函数组合的案例出发，需求是：编写一个获取用户地址的街道名称函数：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">compose</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>fns<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> fns<span class="token punctuation">.</span><span class="token function">reduceRight</span><span class="token punctuation">(</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token function-variable function">address</span> <span class="token operator">=</span> user <span class="token operator">=></span> user<span class="token punctuation">.</span>address
<span class="token keyword">const</span> <span class="token function-variable function">street</span> <span class="token operator">=</span> address <span class="token operator">=></span> address<span class="token punctuation">.</span>street

<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>street<span class="token punctuation">,</span> address<span class="token punctuation">)</span>

<span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
    address<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        street<span class="token punctuation">:</span> <span class="token string">'长河'</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">app</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token comment">// => 长河</span></code></pre>
      </div>
<p>函数组合的理论也非常简单，只要上一个函数的返回值类型可以作为下一个函数的入参就可以放心大胆的进行组合了。</p>
<p>值得警惕的是，<code class="gatsby-code-text">user</code> 对象上面 <code class="gatsby-code-text">address</code> 属性值可能为 <code class="gatsby-code-text">null</code> ，上面的这段代码如果不做任何防范，那么 <code class="gatsby-code-text">TypeError</code> 的错误是可能发生的。这个问题不用担心，毕竟之前已经准备好了用来处理 <code class="gatsby-code-text">null/undefined</code> 的 <code class="gatsby-code-text">Either</code> 函子，可以使用 <code class="gatsby-code-text">fromNullable</code> 包装一下上面代码：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">address</span> <span class="token operator">=</span> user <span class="token operator">=></span> <span class="token function">fromNullable</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>u <span class="token operator">=></span> u<span class="token punctuation">.</span>address<span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token function-variable function">street</span> <span class="token operator">=</span> address <span class="token operator">=></span> <span class="token function">fromNullable</span><span class="token punctuation">(</span>address<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>a <span class="token operator">=></span> a<span class="token punctuation">.</span>street<span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">app</span> <span class="token operator">=</span> user <span class="token operator">=></span>
    <span class="token function">address</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>     <span class="token comment">// Either(address)                                       </span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>street<span class="token punctuation">)</span>  <span class="token comment">// Either(Either(street))</span>

<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">app</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token comment">// => Rirgt(Right('长河'))</span></code></pre>
      </div>
<p>审视一下上面的代码，<code class="gatsby-code-text">street</code> 函数返回的是一个 <code class="gatsby-code-text">Either</code> ，但是别忘了，<code class="gatsby-code-text">map</code> 方法( <code class="gatsby-code-text">map: f =&gt; Right(f(x))</code> )会把函数执行的结果重新包装进“盒子”中，也就是：最终得到的结果是：<code class="gatsby-code-text">Rirgt(Right(&#39;长河&#39;))</code>。</p>
<p>这很明显不是我们想要的结果，我们只想要被包裹一层的 <code class="gatsby-code-text">street</code> ，问题是出现 <code class="gatsby-code-text">map</code> 方法上(map 会进行二次包装)，那么只要使用 <code class="gatsby-code-text">fold</code> 方法把 <code class="gatsby-code-text">street</code> 函数执行的结果从“盒子”里“拆包”解放出来即可。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">app</span> <span class="token operator">=</span> user <span class="token operator">=></span>
        <span class="token function">address</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>                              <span class="token comment">// Either(address)</span>
       <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">=></span> <span class="token function">street</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x<span class="token punctuation">,</span> x <span class="token operator">=></span> x<span class="token punctuation">)</span><span class="token punctuation">)</span>   <span class="token comment">// Either(street)</span>
       <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token string">'default street'</span><span class="token punctuation">,</span> x <span class="token operator">=></span> x<span class="token punctuation">)</span>       <span class="token comment">// street</span>
       
<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">app</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>  <span class="token comment">// => '长河'</span></code></pre>
      </div>
<p>毫无疑问，有几次包装，就需要几次“拆包”操作，这样做逻辑上自然没有问题。但这岂不是和前端常见的<a href="http://callbackhell.com/">回调地狱</a>问题很类似，这样的代码写下去实在是太难维护和阅读，总不能写一行就要数数有几层包装吧！</p>
<p>这简直是代码版本的俄罗斯套娃：</p>
<p><img src="https://d1.music.126.net/dmusic/obj/w5zCg8OAw6HDjzjDgMK_/5473369813/a3d5/d99f/df90/f221f2e6dd3b4a8fc6ee7bc400ba4008.gif?download=russian-dolls.gif" alt="russian-dolls"></p>
<p>出现两层包装的原因是：<code class="gatsby-code-text">map</code> 会把函数计算的结果重新包装进 Box 中，而这一层包装有点赘余，因为之后立即进行了拆箱操作，这非常类似于 <code class="gatsby-code-text">Array flatmap</code> (先 map 然后 flat )。</p>
<p><strong>因为函数的执行结果已经是被包装好了的，所以只需要一个方法( flatMap )直接执行函数，不做其他的任何操作</strong></p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Right</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  flatMap<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">Left</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  flatMap<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Left</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">app</span> <span class="token operator">=</span> user <span class="token operator">=></span>
    <span class="token function">address</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>                             <span class="token comment">// Either(address)</span>
        <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>street<span class="token punctuation">)</span>                      <span class="token comment">// Either(street)</span>
        <span class="token punctuation">.</span><span class="token function">flod</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token string">'default street'</span><span class="token punctuation">,</span>x <span class="token operator">=></span> x<span class="token punctuation">)</span>  <span class="token comment">// street</span></code></pre>
      </div>
<p><code class="gatsby-code-text">map</code> 和 <code class="gatsby-code-text">flatMap</code> 的不同点：<code class="gatsby-code-text">map</code> 方法接收一个仅仅变换容器内值的函数，所以需要用 Box 重新包装；但是 <code class="gatsby-code-text">flatMap</code> 接收<strong>一个返回Box类型的函数</strong>，直接调用即可。</p>
<p><code class="gatsby-code-text">map</code> 和 <code class="gatsby-code-text">flatMap</code> 的相同点却是非常明显的：都是返回一个 Box 的实例，方便后面继续链式的调用。</p>
<blockquote>
<p><code class="gatsby-code-text">flatMap</code> 方法和 <code class="gatsby-code-text">flod</code> 方法逻辑一样？这里得承认他们确实很类似，但是他们的使用场景却完全不同！<code class="gatsby-code-text">flod</code> 的用途是把一个值从 Box 中解放出来；<code class="gatsby-code-text">flatMap</code> 的用途是把一个返回 Box 的函数应用到一个 Box 上，这样后面可以继续保持链式的调用。</p>
</blockquote>
<blockquote>
<p>根据<a href="https://github.com/fantasyland/fantasy-land#chain">规范</a> <code class="gatsby-code-text">flatMap</code> 方法后面会改写为 <code class="gatsby-code-text">chain</code>，在别的语言中，可能也称为 <code class="gatsby-code-text">bind</code>。</p>
</blockquote>
<p>既然解决了嵌套的 <code class="gatsby-code-text">Either</code> 问题，那么嵌套的 <code class="gatsby-code-text">try-catch</code> ，自然用同样的理论也可以迎刃而解了：</p>
<p>举例来说，如果要从文件系统读取一个配置文件，然后读取内容(请注意 <code class="gatsby-code-text">fs.readFileSync</code> 和 <code class="gatsby-code-text">JSON.parse</code> 都是可能发生错误的，所以会用 <code class="gatsby-code-text">try-catch</code> 包裹)：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">readConfig</span> <span class="token operator">=</span> <span class="token punctuation">(</span>filepath<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> str <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> config <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> config<span class="token punctuation">.</span>version
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'0.0.0'</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">readConfig</span><span class="token punctuation">(</span><span class="token string">'/config.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">// => '1.0.0'</span></code></pre>
      </div>
<p>现在使用“盒子”理念 + “chain” 函数重写上面的代码为：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">readConfig</span> <span class="token operator">=</span> <span class="token punctuation">(</span>filepath<span class="token punctuation">)</span> <span class="token operator">=></span>
    <span class="token function">tryCatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>filepath<span class="token punctuation">)</span><span class="token punctuation">)</span>             <span class="token comment">// Either('')</span>
        <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>json <span class="token operator">=></span> <span class="token function">tryCatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// Either('') </span>
        <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token string">'0.0.0'</span><span class="token punctuation">,</span> c <span class="token operator">=></span> c<span class="token punctuation">.</span>version<span class="token punctuation">)</span>

<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">readConfig</span><span class="token punctuation">(</span><span class="token string">'/config.json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token comment">// => '1.0.0'</span></code></pre>
      </div>
<p>如果一个 Functor 实现了 <code class="gatsby-code-text">chain</code> 方法，那么我们可以称这个函子为<strong>单子(Monad)</strong>，不错单子的概念就是这么简单；
如果你去 Google 搜索 <code class="gatsby-code-text">Monad</code> ，有无数篇在讲解 <code class="gatsby-code-text">Monad</code> 的文章，其中最经(戏)典(虐)的一个解释为：</p>
<blockquote>
<p>“A monad is just a monoid in the category of endofunctors. What’s the problem?”</p>
</blockquote>
<p><img src="https://d1.music.126.net/dmusic/obj/w5zCg8OAw6HDjzjDgMK_/5473423836/7034/6444/5f4c/6221ec38ef408e8a25b7be620202b998.gif?download=tenor.gif" alt="monad"></p>
<p>上面这句话的出处是<a href="http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html">brief-incomplete-and-mostly-wrong</a>,完全是为了吐槽 Haskell，理论上没有错，但更多的是调侃(<del>该文章极其经典，点明了所有主流开发语言的“特色与优点”，推荐阅读背诵</del>)。</p>
<p>而 Monad 的准确定义是：</p>
<blockquote>
<p>All told, a monad in X is just a monoid in the category of endofunctors of X, with product × replaced by composition of endofunctors and unit set by the identity endofunctor. — <a href="https://en.wikipedia.org/wiki/Saunders_Mac_Lane">Saunders Mac Lane</a></p>
</blockquote>
<p>所以上面这个定义你看懂了吗？(<del>别打我</del>)看不懂，真的没有关系，因为那是为专业的数学学生而准备的，我们只要掌握 Monad 在编程中可以理解为 <code class="gatsby-code-text">chainable</code> 的对象，用来解决嵌套的 Box 问题，抓住这个重点已经足够了。</p>
<h2 id="异步"><a href="#%E5%BC%82%E6%AD%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>异步</h2>
<p>毫无疑问 异步 是 JavaScript 世界的主流，从按钮的 <code class="gatsby-code-text">onclick</code> 点击回调，到 AJAX 请求的 <code class="gatsby-code-text">onload</code> 回调，再到 Node.js 里的 <code class="gatsby-code-text">readFile</code> 回调，这种根基级的手法都万变不离其宗，「异步非阻塞」意味着一种以回调函数为基础的编程范式。</p>
<p>关于异步和事件循环的理论，可以参考网易云音乐团队的另一篇文章：<a href="https://musicfe.dev/eventloop/">聊聊 JavaScript 的并发、异步和事件循环</a></p>
<h3 id="callback-与-异步"><a href="#callback-%E4%B8%8E-%E5%BC%82%E6%AD%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>callback 与 异步</h3>
<p>从最简单的回调函数开始，首先看一典型的 Node.js 风格的 callback :</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">getUrl</span> <span class="token operator">=</span> url <span class="token operator">=></span> callback <span class="token operator">=></span> <span class="token function">request</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> callback<span class="token punctuation">)</span>
<span class="token keyword">const</span> getSomeJSON <span class="token operator">=</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token string">'http://example.com/somedata.json'</span><span class="token punctuation">)</span>
<span class="token function">getSomeJSON</span><span class="token punctuation">(</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//do something with err</span>
  <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token comment">//do something with data</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>这是一段简单的异步 HTTP 请求，首先采用柯里化的方式传入 <code class="gatsby-code-text">url</code> ，然后传入 <code class="gatsby-code-text">callback</code> ，这种风格有什么缺点呢？</p>
<ul>
<li>1.函数的调用者无法直接控制请求，必须要把所有的后续操作放在 <code class="gatsby-code-text">callback</code> 里面</li>
<li>2.函数无法组合，因为 <code class="gatsby-code-text">getSomeJSON</code> 调用之后没有返回任何结果</li>
</ul>
<p>还有一个关键点在于，<code class="gatsby-code-text">callback</code> 接收两个参数，一个错误信息，一个成功的数据，这导致我们不得不在一个函数里面同时处理错误与数据的逻辑。</p>
<p>那么转换一下思路，<strong>与其传递一个接收两个参数(err &#x26; data)的函数，不如传递两个函数(handleError &#x26; handleData)，每个接收一个参数</strong>。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">getUrl</span> <span class="token operator">=</span> url <span class="token operator">=></span>
    <span class="token punctuation">(</span>reject<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token function">request</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">{</span>
            err<span class="token operator">?</span> <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>现在调用 <code class="gatsby-code-text">getUrl</code> 之后，我们可以继续传递 <code class="gatsby-code-text">handleError</code> 和 <code class="gatsby-code-text">handleData</code></p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> getSomeJSON <span class="token operator">=</span> <span class="token function">getUrl</span><span class="token punctuation">(</span><span class="token string">'http://example.com/somedata.json'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token function-variable function">handleError</span> <span class="token operator">=</span> err <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Error fetching JSON'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span>
<span class="token keyword">const</span> handleData <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>renderData<span class="token punctuation">,</span> <span class="token constant">JSON</span><span class="token punctuation">.</span>parse<span class="token punctuation">)</span>

<span class="token function">getSomeJSON</span><span class="token punctuation">(</span>handleError<span class="token punctuation">,</span> handleData<span class="token punctuation">)</span> <span class="token comment">// 触发请求</span></code></pre>
      </div>
<p>现在完全分离了 <code class="gatsby-code-text">handleData</code> 和 <code class="gatsby-code-text">handleError</code> 的逻辑，并且 <code class="gatsby-code-text">handleData</code> 函数已经可以按照我们的期望进行组合了，而<code class="gatsby-code-text">(reject, resolve) =&gt; {}</code> 函数我们称之为fork，意为：两个“分支”。</p>
<h3 id="task与异步"><a href="#task%E4%B8%8E%E5%BC%82%E6%AD%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Task与异步</h3>
<p>现在我们发现了另外一个问题，我们总是需要在 <code class="gatsby-code-text">handleData</code> 中进行 <code class="gatsby-code-text">JSON.parse</code> 操作，因为把字符串转换为 JSON 是任何数据处理逻辑的第一步，如果我们能把 <code class="gatsby-code-text">getSomeJSON</code> 与 <code class="gatsby-code-text">JSON.parse</code> 函数组合在一起就好了；现在问题明确了：<strong>如何把一个普通的函数和fork函数进行组合？</strong></p>
<p>这个问题看上去非常棘手，不过可以从简单的问题开始一步步解决，假设现在有字符串 <code class="gatsby-code-text">stringifyJson</code> ，如何转换为 JSON 呢，借用前面一章中介绍的<a href="https://musicfe.dev/javascript-functional-programming-functor/">LazyBox</a>的概念：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> stringifyJson<span class="token operator">=</span> <span class="token string">'{"a":1}'</span>

<span class="token function">LazyBox</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> stringifyJson<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span>parse<span class="token punctuation">)</span> <span class="token comment">// => LazyBox({ a: 1 })</span></code></pre>
      </div>
<p>我们可以把一个函数包装进 <code class="gatsby-code-text">LazyBox</code> 中，然后通过 <code class="gatsby-code-text">map</code> 不断的进行函数组合，直到最后调用 <code class="gatsby-code-text">fold</code> 函数，真正的触发函数调用；   </p>
<p><code class="gatsby-code-text">LazyBox</code> 用来包裹同步的函数，那么同理对于处理异步逻辑的 <code class="gatsby-code-text">fork</code> 函数，也可以用一个盒子包装起来，然后 <code class="gatsby-code-text">map</code> 普通函数 <code class="gatsby-code-text">f</code> ，不也可以实现函数组合吗？对于异步的逻辑，可以称之为 <code class="gatsby-code-text">Task</code> (任务：将来才会完成某个目标或者达成某种结果，<del>是不是很好理解</del>)</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Task</span> <span class="token operator">=</span> fork <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span> <span class="token operator">=></span>          <span class="token comment">// return another Task, including a new fork.</span>
            <span class="token function">fork</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> x <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>   <span class="token comment">// when called,the new fork will run `f` over the value, before calling `resolve`</span>
    fork<span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token string">'Task(?)'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
      </div>
<p><code class="gatsby-code-text">Task</code> 的 <code class="gatsby-code-text">map</code> 方法，接收一个函数 <code class="gatsby-code-text">f</code> ，返回一个新的 <code class="gatsby-code-text">Task</code>，关键点在：新的 <code class="gatsby-code-text">fork</code> 函数会调用上一个 <code class="gatsby-code-text">fork</code> ，如果是正确的分支则 <code class="gatsby-code-text">resolve</code> 被函数 <code class="gatsby-code-text">f</code> 计算过后的结果，如果是失败的分支，则传递 <code class="gatsby-code-text">reject</code>。</p>
<blockquote>
<p>如果之前没有深入了解过 Promise 的实现原理，可能这里比较难以理解，但是请停下来，花点时间思考一下。</p>
</blockquote>
<p>现在使用 <code class="gatsby-code-text">Task</code> 改写一下 <code class="gatsby-code-text">readConfig</code> 函数：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">readConfig</span> <span class="token operator">=</span> filepath <span class="token operator">=></span> <span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span> <span class="token operator">=></span>
    fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token operator">=></span>
        err <span class="token operator">?</span> <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">readConfig</span><span class="token punctuation">(</span><span class="token string">'config.json'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span>parse<span class="token punctuation">)</span>

app<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'something went wrong'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> json <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'json'</span><span class="token punctuation">,</span> json<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
      </div>
<p><code class="gatsby-code-text">Task.map</code> 和 <code class="gatsby-code-text">LazyBox</code> 的 <code class="gatsby-code-text">map</code> 完全类似，一直都是在做函数组合的工作，并没有进行实际的函数调用，<code class="gatsby-code-text">LazyBox</code> 最后通过调用 <code class="gatsby-code-text">fold</code> 真正实现函数调用，而 <code class="gatsby-code-text">Task</code> 最后通过调用 <code class="gatsby-code-text">fork</code> ，实现异步函数的执行。</p>
<h3 id="task与异步函数的组合"><a href="#task%E4%B8%8E%E5%BC%82%E6%AD%A5%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%84%E5%90%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Task与异步函数的组合</h3>
<p>现在通过 <code class="gatsby-code-text">Task</code> 实现了一个比较“优雅”的 <code class="gatsby-code-text">readConfig</code> 函数，如果要继续修改配置文件并保存到本地，又该如何处理呢？先从 <code class="gatsby-code-text">writeConfig</code> 函数开始吧，完全仿照 <code class="gatsby-code-text">readConfig</code> 函数的写法：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">readConfig</span><span class="token punctuation">(</span>readPath<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span>parse<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>c <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> version<span class="token punctuation">:</span> c<span class="token punctuation">.</span>version <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span>stringify<span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">writeConfig</span> <span class="token operator">=</span> <span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> contents<span class="token punctuation">)</span> <span class="token operator">=></span>
    <span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
        fs<span class="token punctuation">.</span><span class="token function">writeFile</span><span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> contents<span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=></span>
            err <span class="token operator">?</span> <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>contents<span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>那么怎么继续把 <code class="gatsby-code-text">writeConfig</code> 应用到 <code class="gatsby-code-text">app</code> 上呢，既然 <code class="gatsby-code-text">writeConfig</code> 函数返回一个 <code class="gatsby-code-text">Task</code>，那么很明显需要一个类似 <code class="gatsby-code-text">Array.prototype.flatMap</code> 和 <code class="gatsby-code-text">Either.chain</code> 函数，帮我们把这个返回 <code class="gatsby-code-text">Task</code> 的函数应用到 <code class="gatsby-code-text">app</code> 上：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Task</span> <span class="token operator">=</span> fork <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    chain<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span> <span class="token operator">=></span>                   <span class="token comment">// return another Task</span>
            <span class="token function">fork</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> x <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// calling `f` with the eventual value</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>类似于 <code class="gatsby-code-text">Either</code> 中的 <code class="gatsby-code-text">chain</code> 函数，首先会直接调用函数 <code class="gatsby-code-text">f</code> (返回TaskB)，然后传入<code class="gatsby-code-text">(reject, resolve)</code>调用 <code class="gatsby-code-text">TaskB</code> 的 <code class="gatsby-code-text">fork</code> 函数去处理后续的逻辑。</p>
<p>现在就可以流畅的使用 <code class="gatsby-code-text">chain</code> 继续组合 <code class="gatsby-code-text">writeConfig</code> 函数了</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">readConfig</span><span class="token punctuation">(</span>readPath<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span>parse<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>c <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> version<span class="token punctuation">:</span> c<span class="token punctuation">.</span>version <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span>stringify<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>c <span class="token operator">=></span> <span class="token function">writeConfig</span><span class="token punctuation">(</span>writeFilepath<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span>

app<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'something went wrong'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> 
    <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'read and write config success'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>看到这里，应该可以举一反三的想到，需要链式调用的 HTTP 请求，比如：连续调用两个接口，第二个接口依赖第一个接口的返回值作为参数，那么完全可以用 <code class="gatsby-code-text">chain</code> 组合两个异步 HTTP 请求：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">httpGet</span> <span class="token operator">=</span> content <span class="token operator">=></span> <span class="token function">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span>rej<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">res</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">getUser</span> <span class="token operator">=</span> <span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">httpGet</span><span class="token punctuation">(</span><span class="token string">'Melo'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token function-variable function">getAge</span> <span class="token operator">=</span> name <span class="token operator">=></span> <span class="token function">httpGet</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span>

<span class="token function">getUser</span><span class="token punctuation">(</span><span class="token string">'id'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>name <span class="token operator">=></span> <span class="token function">getAge</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">' 18'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>error<span class="token punctuation">,</span> console<span class="token punctuation">.</span>log<span class="token punctuation">)</span> <span class="token comment">// => 4000ms later， log： "Melo 18"</span></code></pre>
      </div>
<h2 id="monad-vs-promise"><a href="#monad-vs-promise" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Monad VS Promise</h2>
<p><code class="gatsby-code-text">Task</code> 的代码实现，不如之前介绍的 <code class="gatsby-code-text">Box</code>，<code class="gatsby-code-text">Either</code>， <code class="gatsby-code-text">LazyBox</code> 那么直观和好理解，但是请仔细思考和理解一下，你会发现 <code class="gatsby-code-text">Task</code> 和 <code class="gatsby-code-text">Promise</code> 是非常非常相似的，甚至我们可以认为 <code class="gatsby-code-text">Task</code> 就是一个 Lazy-Promise ：<strong>Promise 是在创建的时候立即开始执行，而 Task 是在调用 fork 之后，才会开始执行</strong>。</p>
<p>关于读取配置文件，修改内容，然后重新保存到本地，我想大家都可以轻松的写出来 Promise 版本的实现，作为对比展示一下示例代码：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">readConfig</span> <span class="token operator">=</span> filepath <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span>
    fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> data<span class="token punctuation">)</span> <span class="token operator">=></span>
        err <span class="token operator">?</span> <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
    <span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">writeConfig</span> <span class="token operator">=</span> <span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> contents<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    fs<span class="token punctuation">.</span><span class="token function">writeFile</span><span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> contents<span class="token punctuation">,</span> <span class="token punctuation">(</span>err<span class="token punctuation">,</span> _<span class="token punctuation">)</span> <span class="token operator">=></span>
        err <span class="token operator">?</span> <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">resolve</span><span class="token punctuation">(</span>contents<span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token function">readConfig</span><span class="token punctuation">(</span>readPath<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span>parse<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>c <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> version<span class="token punctuation">:</span> c<span class="token punctuation">.</span>version <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span>stringify<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>c <span class="token operator">=></span> <span class="token function">writeConfig</span><span class="token punctuation">(</span>writeFilepath<span class="token punctuation">,</span> c<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>两个版本中 <code class="gatsby-code-text">readConfig</code> 和 <code class="gatsby-code-text">writeConfig</code> 的实现非常类似，不再叙述；关键的不同点在于：Task 版本的组合函数使用的是 <code class="gatsby-code-text">map</code> 和 <code class="gatsby-code-text">chain</code> 函数，而 Promise 版本一直使用的都是 <code class="gatsby-code-text">then</code>。所以 Promise 看上去和 Monad 非常类似，那么不禁要问，Promise 是不是 Monad 呢？</p>
<p>那么可以和最简单的 <code class="gatsby-code-text">Box</code> Monad 做个对比:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Box</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Box</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    chain<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> box1 <span class="token operator">=</span> <span class="token function">Box</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>                          <span class="token comment">// => Box(1)</span>
<span class="token keyword">const</span> promise1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>          <span class="token comment">// => Promise(1)</span>
    
box1<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                         <span class="token comment">// => Box(2)</span>
promise1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                    <span class="token comment">// => Promise(2)</span>

<span class="token comment">// -----------------</span>

box1<span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>x <span class="token operator">=></span> <span class="token function">Box</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                 <span class="token comment">// => Box(2)</span>
promise1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>x <span class="token operator">=></span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// => Promise(2)</span></code></pre>
      </div>
<p>可以发现，如果函数返回的是没有被包裹的值，<code class="gatsby-code-text">then</code> 和 <code class="gatsby-code-text">map</code> 的行为很类似；如果函数返回的是包裹的值，<code class="gatsby-code-text">then</code> 和 <code class="gatsby-code-text">chain</code> 很类似，都会去掉一层包装，从这个角度看 Promise 和Functor/Monad 都很类似，符合他们的数学规则。</p>
<p>下面继续看：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">box1<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=></span> <span class="token function">Box</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                   <span class="token comment">// => Box(Box(2))</span>
promise1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>x <span class="token operator">=></span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// => Promise(2)</span>

box1<span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                      <span class="token comment">// => 2</span>
promise1<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>                   <span class="token comment">// => Promise(2)</span></code></pre>
      </div>
<p>如果把一个返回包裹的值的函数，传递给 <code class="gatsby-code-text">then</code>，不会像 Functor 那样得到一个被包裹两层的值，而是只有一层；同样的把一个返回普通值的函数传递给 <code class="gatsby-code-text">then</code>，我们依然得到的是一个Promise，而 <code class="gatsby-code-text">chain</code> 的结果是去掉一层包裹，得到了值。从这个角度看，Promise 同时打破了 Functor 和 Monad 的数学规则。<strong>所以严格意义来说 Promise 不是一个 Monad</strong>，但是不可否认 Promise 的设计肯定有不少灵感来自 Monad。</p>
<blockquote>
<p>这一小节的内容较为难理解，主要难在 Task 的实现原理和异步函数的组合，在逻辑上需要很好的数学思维，希望能多思考一下，一定会有更多的收获，毕竟我们用了短短几行代码，就实现了加强版的 Promise-> Lazy Promise -> Task。</p>
</blockquote>
<blockquote>
<p>更多的关于 Promise 和 Monad 的对比可以参考：<a href="https://www.breaktech.com/post/javascript-promises-and-monads">Javascript: Promises and Monads</a>,<a href="https://glebbahmutov.com/blog/difference-between-promise-and-task/">difference between promise and task</a></p>
</blockquote>
<h2 id="应用函子与单子"><a href="#%E5%BA%94%E7%94%A8%E5%87%BD%E5%AD%90%E4%B8%8E%E5%8D%95%E5%AD%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>应用函子与单子</h2>
<p>Monad 更擅长处理的是一种拥有 <code class="gatsby-code-text">Context(上下文)</code> 的场景，上面的 <code class="gatsby-code-text">getUser</code> 与 <code class="gatsby-code-text">getAge</code> 的例子中，<code class="gatsby-code-text">getAge</code> 函数必须等到 <code class="gatsby-code-text">getUser</code> 函数中的异步执行完成才能开始调用，这是一种<strong>纵向(串行)</strong>的链路；</p>
<p>而<strong>Applicative更擅长的是处理一种横向(并行)的链路</strong>，比如上一章介绍的表单校验的例子，每个字段的校验之间完全没有什么关联关系。</p>
<p>现在不禁要问 Task 可以实现异步的并行吗？答案是肯定的！假设 <code class="gatsby-code-text">getUser</code> 和 <code class="gatsby-code-text">getAge</code> 互不依赖，则完全可以采用 Applicative 的 apply 方法来进行组合。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Task
    <span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>name <span class="token operator">=></span> age <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">,</span> age <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>getUser<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>getAge<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>error<span class="token punctuation">,</span> console<span class="token punctuation">.</span>log<span class="token punctuation">)</span> <span class="token comment">// 2000ms later， log： "{name: 'Melo', age: 18}"</span></code></pre>
      </div>
<blockquote>
<p>Task.ap 可以参考 Promise.all 的原理，具体实现可以参考<a href="https://gist.github.com/Sylvenas/2a06088257344bc1596ed03407194f49">gist.github</a>。</p>
</blockquote>
<h2 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h2>
<ul>
<li><code class="gatsby-code-text">Functor</code> 是一种实现 <code class="gatsby-code-text">map</code> 方法的数据类型</li>
<li><code class="gatsby-code-text">Applicative</code> 是一种实现了 <code class="gatsby-code-text">apply</code> 方法的数据类型</li>
<li><code class="gatsby-code-text">Monad</code> 是一种实现了 <code class="gatsby-code-text">chain</code> 或 <code class="gatsby-code-text">flatmap</code> 方法的数据类型</li>
</ul>
<p>那么<code class="gatsby-code-text">Functor</code>、<code class="gatsby-code-text">Applicative</code> 和 <code class="gatsby-code-text">Monad</code> 三个区别是什么？</p>
<p><img src="https://p5.music.126.net/obj/wo3DlcOGw6DClTvDisK1/5502286847/c6d7/0597/c401/2284b7163900c63a298fbe46ce309e4d.png" alt="functor-applicative-monad"></p>
<ul>
<li><code class="gatsby-code-text">Functor</code>: 应用一个函数到包裹的值，使用 <code class="gatsby-code-text">map</code>.</li>
<li><code class="gatsby-code-text">Applicative</code>: 应用一个包裹的函数到包裹的值，使用 <code class="gatsby-code-text">ap</code></li>
<li><code class="gatsby-code-text">Monad</code>: 应用一个返回包裹值的函数到一个包裹的值，使用 <code class="gatsby-code-text">chain</code></li>
</ul>
<p>参考资料与引用文章：   </p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap">Array.prototype.flatMap</a>     </li>
<li><a href="https://www.youtube.com/watch?v=dkZFtimgAcM">Monads and Gonads (YUIConf Evening Keynote)</a>   </li>
<li><a href="https://jrsinclair.com/articles/2016/marvellously-mysterious-javascript-maybe-monad/">Marvellously mysterious javascript maybe monad</a>   </li>
<li><a href="https://medium.com/beingprofessional/understanding-functor-and-monad-with-a-bag-of-peanuts-8fa702b3f69e">Understanding Functor and Monad With a Bag of Peanuts</a> </li>
<li><a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures</a>     </li>
<li><a href="http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html">A Brief, Incomplete, and Mostly Wrong History of Programming Languages</a>     </li>
<li><a href="https://jaysoo.ca/2016/01/13/functional-programming-little-ideas/">The Little Idea of Functional Programming</a>    </li>
<li><a href="https://github.com/fluture-js/Fluture/wiki/Comparison-to-Promises">Comparison to Promises</a>    </li>
<li><a href="https://medium.com/free-code-camp/functional-programming-in-js-with-practical-examples-part-2-429d2e8ccc9e">Functional Programming In JavaScript — With Practical Examples</a>     </li>
<li><a href="https://twitter.com/_ericelliott/status/905538090634059776">Compose monads</a></li>
<li><a href="https://blog.jcoglan.com/2011/03/05/translation-from-haskell-to-javascript-of-selected-portions-of-the-best-introduction-to-monads-ive-ever-read/">Translation from Haskell to JavaScript of selected portions of the best introduction to monads I’ve ever read</a></li>
<li><a href="https://blog.oyanglul.us/grokking-monad/part1">猫论讲解monad</a></li>
<li><a href="https://www.zhihu.com/question/24972880">怎样用简单的语言解释 monad？</a></li>
<li>《JavaScript函数式编程》   </li>
</ul>]]></description><link>https://reactjs.org/blog/2020/02/12/俄罗斯套娃娃.html</link><guid isPermaLink="false">https://reactjs.org/blog/2020/02/12/俄罗斯套娃娃.html</guid><pubDate>Tue, 11 Feb 2020 16:00:00 GMT</pubDate></item><item><title><![CDATA[纪念刘和珍君]]></title><description><![CDATA[<p>中华民国十五年三月二十五日，就是国立北京女子师范大学为十八日在段祺瑞执政府前遇害的刘和珍杨德群两君开追悼会的那一天，我独在礼堂外徘徊，遇见程君，前来问我道，“先生可曾为刘和珍写了一点什么没有？”我说“没有”。她就正告我，“先生还是写一点罢; 刘和珍生前就很爱看先生的文章。”</p>
<p>这是我知道的，凡我所编辑的期刊，大概是因为往往有始无终之故罢，销行一向就甚为寥落，然而在这样的生活艰难中，毅然预定了《莽原》全年的就有她。我也早觉得有写一点东西的必要了，这虽然于死者毫不相干，但在生者，却大抵只能如此而已。倘使我能够相信真有所谓 “在天之灵”，那自然可以得到更大的安慰，——但是，现在，却只能如此而已。</p>
<p><strong>可是我实在无话可说。我只觉得所住的并非人间。</strong>四十多个青年的血，洋溢在我的周围，使我艰于呼吸视听，那里还能有什么言语？长歌当哭，是必须在痛定之后的。而此后几个所谓学者文人的阴险的论调，尤使我觉得悲哀。我已经出离愤怒了。我将深味这非人间的浓黑的悲凉;以我的最大哀痛显示于非人间，使它们快意于我的苦痛，就将这作为后死者的菲薄的祭品，奉献于逝者的灵前。</p>
<hr>
<p>真的猛士，敢于直面惨淡的人生，敢于正视淋漓的鲜血。这是怎样的哀痛者和幸福者？然而造化又常常为庸人设计，以时间的流驶，来洗涤旧迹，仅使留下淡红的血色和微漠的悲哀。在这淡红的血色和微漠的悲哀中，又给人暂得偷生，维持着这似人非人的世界。我不知道这样的世界何时是一个尽头!</p>
<p>我们还在这样的世上活着; 我也早觉得有写一点东西的必要了。离三月十八日也已有两星期，忘却的救主快要降临了罢，我正有写一点东西的必要了。</p>
<hr>
<p>在四十余被害的青年之中，刘和珍君是我的学生。学生云者，我向来这样想，这样说，现在却觉得有些踌躇了，我应该对她奉献我的悲哀与尊敬。她不是“苟活到现在的我”的学生，是为了中国而死的中国的青年。</p>
<p>她的姓名第一次为我所见，是在去年夏初杨荫榆女士做女子师范大学校长，开除校中六个学生自治会职员的时候。其中的一个就是她;但是我不认识。直到后来，也许已经是刘百昭率领男女武将，强拖出校之后了，才有人指着一个学生告诉我，说：这就是刘和珍。其时我才能将姓名和实体联合起来，心中却暗自诧异。我平素想，能够不为势利所屈，反抗一广有羽翼的校长的学生，无论如何，总该是有些桀骜锋利的，但她却常常微笑着，态度很温和。待到偏安于宗帽胡同，赁屋授课之后，她才始来听我的讲义，于是见面的回数就较多了，也还是始终微笑着，态度很温和。待到学校恢复旧观，往日的教职员以为责任已尽，准备陆续引退的时候，我才见她虑及母校前途，黯然至于泣下。此后似乎就不相见。总之，在我的记忆上，那一次就是永别了。</p>
<hr>
<p>我在十八日早晨，才知道上午有群众向执政府请愿的事;下午便得到噩耗，说卫队居然开枪，死伤至数百人，而刘和珍君即在遇害者之列。但我对于这些传说，竟至于颇为怀疑。我向来是不惮以最坏的恶意，来推测中国人的，然而我还不料，也不信竟会下劣凶残到这地步。况且始终微笑着的和蔼的刘和珍君，更何至于无端在府门前喋血呢？</p>
<p>然而即日证明是事实了，作证的便是她自己的尸骸。还有一具，是杨德群君的。而且又证明着这不但是杀害，简直是虐杀，因为身体上还有棍棒的伤痕。</p>
<p>但段政府就有令，说她们是 “暴徒”!</p>
<p>但接着就有流言，说她们是受人利用的。</p>
<p>惨象，已使我目不忍视了;流言，尤使我耳不忍闻。我还有什么话可说呢？我懂得衰亡民族之所以默无声息的缘由了。沉默呵，沉默呵!不在沉默中爆发，就在沉默中灭亡。</p>
<hr>
<p>但是，我还有要说的话。</p>
<p>我没有亲见;听说，她，刘和珍君，那时是欣然前往的。自然，请愿而已，稍有人心者，谁也不会料到有这样的罗网。但竟在执政府前中弹了，从背部入，斜穿心肺，已是致命的创伤，只是没有便死。同去的张静淑君想扶起她，中了四弹，其一是手枪，立仆;同去的杨德群君又想去扶起她，也被击，弹从左肩入，穿胸偏右出，也立仆。但她还能坐起来，一个兵在她头部及胸部猛击两棍，于是死掉了。</p>
<p>始终微笑的和蔼的刘和珍君确是死掉了，这是真的，有她自己的尸骸为证，沉勇而友爱的杨德群君也死掉了，有她自己的尸骸为证;只有一样沉勇而友爱的张静淑君还在医院里呻吟。当三个女子从容地转辗于文明人所发明的枪弹的攒射中的时候，这是怎样的一个惊心动魂的伟大呵!中国军人的屠戮妇婴的伟绩，八国联军的惩创学生的武功，不幸全被这几缕血痕抹杀了。</p>
<p>但是中外的杀人者却居然昂起头来，不知道个个脸上有着血污……。</p>
<hr>
<p>时间永是流驶，街市依旧太平，有限的几个生命，在中国是不算什么的，至多，不过供无恶意的闲人以饭后的谈资，或者给有恶意的闲人作“流言”的种子。至于此外的深的意义，我总觉是很寥寥，因为这实在不过是徒手的请愿。人类的血战前行的历史，正如煤的形成，当时用大量的木材，结果却只是一小块，但请愿是不在其中的，更何况是徒手。</p>
<p>然而既然有了血痕了，当然不觉要扩大。至少，也当浸渍了亲族，师友，爱人的心，纵使时光流驶，洗成绯红，也会在微漠的悲哀中永存微笑的和蔼的旧影。陶潜说过，“亲戚或余悲，他人亦已歌，死去何所道，托体同山阿。”倘能如此，这也就够了。</p>
<hr>
<p>我已经说过： 我向来是不惮以最坏的恶意来推测中国人的。但这回却很有几点出于我的意外。一是当局者竟会这样地凶残，一是流言家竟至如此之下劣，一是中国的女性临难竟能如是之从容。</p>
<p>我目睹中国女子的办事，是始于去年的，虽然是少数，但看那干练坚决，百折不回的气概，曾经屡次为之感叹。至于这一回在弹雨中互相救助，虽殒身不恤的事实，则更足为中国女子的勇毅，虽遭阴谋秘计，压抑至数千年，而终于没有消亡的明证了。倘要寻求这一次死伤者对于将来的意义，意义就在此罢。</p>
<p>苟活者在淡红的血色中，会依稀看见微茫的希望;真的猛士，将更奋然而前行。</p>
<p>呜呼，我说不出话，但以此记念刘和珍君!</p>
<p>四月一日。</p>
<p>— 鲁迅</p>]]></description><link>https://reactjs.org/blog/2020/02/07/记念刘和珍君.html</link><guid isPermaLink="false">https://reactjs.org/blog/2020/02/07/记念刘和珍君.html</guid><pubDate>Thu, 06 Feb 2020 16:00:00 GMT</pubDate></item><item><title><![CDATA[应用函子 - Applicative]]></title><description><![CDATA[<p><a href="https://sylvenas.github.io/blog/2019/09/10/%E9%BB%91%E7%8F%8D%E7%8F%A0%E5%8F%B7%E7%9A%84%E8%AF%85%E5%92%92.html">上一章</a>中介绍了 <code class="gatsby-code-text">Functor(函子)</code> 的概念，简单来说，就是把一个 “value” 填装进 “Box” 中，继而可以使用 <code class="gatsby-code-text">map</code> 方法映射变换 Box 中的值：<code class="gatsby-code-text">Box(1).map(x =&gt; x+1)</code>。本章我们在继续在 <code class="gatsby-code-text">Box</code> 的基础上继续扩展其他更强大的理念，从<a href="https://en.wikipedia.org/wiki/Pure_function">纯函数</a>与<a href="https://en.wikipedia.org/wiki/Side_effect_(computer_science)">副作用</a>的概念及用途作为承上启下的开端，继续巩固 <code class="gatsby-code-text">Functor</code> 的概念以及接下来将要介绍的 <code class="gatsby-code-text">Applicative Functor</code> 的引子。</p>
<p>函数式编程中纯函数是一个及其重要的概念，甚至可以说是函数组合的基础。你可能已经听过类似的言论：“纯函数是引用透明( Referential Transparency )的”，“纯函数是无副作用( Side Effect )的”，“纯函数没有共享状态( Shared State )”。下面简单介绍下纯函数。</p>
<h3 id="纯函数与副作用"><a href="#%E7%BA%AF%E5%87%BD%E6%95%B0%E4%B8%8E%E5%89%AF%E4%BD%9C%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>纯函数与副作用</h3>
<p>在计算机编程中，假如满足下面这两个条件的约束，一个函数可以被描述为一个“纯函数”( pure function )</p>
<ul>
<li>给出相同的参数，那么函数的返回值一定相同。该函数结果值不依赖任何隐藏信息或程序执行处理可能改变的状态，也不能依赖于任何来自 I/O 的外部输入。</li>
<li>在对函数返回值的计算过程中，不会产生任何语义上可观察的副作用或输出，例如对象的变化或者输出到 I/O 的操作。</li>
</ul>
<p>关于纯函数的第一条很简单，相同的输入，总会返回相同的输出，和中学数学中学习的“函数”完全类似，传入相同的参数，返回值一定相同，函数本身就是从集合到集合的“映射”。</p>
<p>第二条不产生可观察的副作用又是什么意思呢？也就是函数不可以和系统的其他部分通信。比如：打印日志，读写文件，数据请求，数据存储等等；</p>
<p>从代码编写者的角度来看，如果一段程序运行之后没有可观察到的作用，那他到底运行了没有？或者运行之后有没有实现代码的目的？有可能它只是浪费了几个 CPU 周期之后就去睡大觉了！</p>
<p>从 JavaScript 语言的诞生之初就不可避免地需要能够与不断变化的，共享的，有状态的 DOM 互相作用；如果无法输入输出任何数据，那么数据库有什么用处呢？如果无法从网络请求信息，我们的页面又该如何展示？没有 “side effect” 我们几乎寸步难行，<strong>副作用不可避免</strong>，上述的任何一个操作，都会产生副作用，违反了引用透明性，我们似乎陷入了两难的境地！</p>
<blockquote>
<p>世間安得雙全法，不負如來不負卿</p>
</blockquote>
<p><strong>如何在 <code class="gatsby-code-text">keep pure</code> 的前提下，又能妥善的处理 <code class="gatsby-code-text">side effect</code> 呢？</strong></p>
<h3 id="惰性盒子-lazybox"><a href="#%E6%83%B0%E6%80%A7%E7%9B%92%E5%AD%90-lazybox" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>惰性盒子-LazyBox</h3>
<p>要想较理想的解决这个问题，我们把注意力转回到 JavaScript 的核心 function 上，我们知道在 JavaScript 里，函数是“一等公民”，JavaScript 允许开发人员像操作变量一样操作函数，例如将函数赋值给变量、把函数作为参数传递给其他函数、函数作为另一个函数的返回值，等等…</p>
<p>JavaScript 函数具有<strong>值的行为</strong>，也就是说，函数就是一个基于输入的且尚未求值的不可变的值，或者可以认为函数本身就是一个等待计算的惰性的值。那么我们完全可以把这个“惰性的值”装入 <code class="gatsby-code-text">Box</code> 中，然后延迟调用即可，仿照上一章的 <code class="gatsby-code-text">Box</code> ，可以实现一个 <code class="gatsby-code-text">Lazy Box</code> ：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">LazyBox</span> <span class="token operator">=</span> g <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">LazyBox</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    fold<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>注意观察，<strong>map 函数所做的一直都是在组合函数，函数并没有被实际的调用；而调用 fold 函数才会真正的执行函数调用</strong>，看例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">finalPrice</span> <span class="token operator">=</span> str <span class="token operator">=></span>
    <span class="token function">LazyBox</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> str<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=></span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'str:'</span><span class="token punctuation">,</span> str<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">return</span> x <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x <span class="token operator">*</span> <span class="token number">0.8</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x <span class="token operator">-</span> <span class="token number">50</span><span class="token punctuation">)</span>  

<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">finalPrice</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>  <span class="token comment">// => { map: [Function: map], fold: [Function: fold] }</span></code></pre>
      </div>
<p>在调用 <code class="gatsby-code-text">finalPrice</code> 函数的时候，并没有打印出 <code class="gatsby-code-text">&#39;str:100&#39;</code>，说明正如我们预期的那样，函数并没有真正的被调用，而只是在不断的进行函数组合。在没有调用 <code class="gatsby-code-text">fold</code> 函数之前，我们的代码都是 “pure” 的。</p>
<blockquote>
<p>这有点类似于递归，在未满足终止条件之前(没有调用 <code class="gatsby-code-text">fold</code> 之前)，递归调用会在栈中不断的堆叠(组合函数)，直到满足终止条件(调用 <code class="gatsby-code-text">fold</code> 函数)，才开始真正的函数计算。</p>
</blockquote>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> app <span class="token operator">=</span> <span class="token function">finalPrice</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> res2 <span class="token operator">=</span> app<span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res2<span class="token punctuation">)</span> <span class="token comment">// => 110</span></code></pre>
      </div>
<p><code class="gatsby-code-text">fold</code> 函数就像打开潘多拉魔盒的双手；通过 <code class="gatsby-code-text">LazyBox</code> 我们把可能会“弄脏双手(产生副作用)”的代码扔给了最后的 <code class="gatsby-code-text">fold</code> ，这样做又有什么意义呢？</p>
<ul>
<li>把代码中不纯的部分剥离出来，保障核心部分代码的 “pure” 特性，比如上面的代码中只有 <code class="gatsby-code-text">app.fold(x =&gt; x)</code> 是 “no pure” 的，其他部分都是 “pure” </li>
<li>类似于上一章中的错误集中管理，可以通过 <code class="gatsby-code-text">LazyBox</code> 来把副作用集中管理，如果在项目中不断的扩大 “pure” 的部分，我们甚至可以把不纯的代码推到代码的边缘，保证核心部分的 “pure” 和 “referential transparency” </li>
</ul>
<blockquote>
<p>LazyBox 也和 Rxjs 中的 <code class="gatsby-code-text">Observable</code> 有很多相似之处，两者都是惰性的，在 <code class="gatsby-code-text">subscribe</code> 之前，<code class="gatsby-code-text">Observable</code> 也不会推送数据。</p>
</blockquote>
<blockquote>
<p>此处请思考下 React 中的 <code class="gatsby-code-text">useEffect</code> 以及 Redux 中的 <code class="gatsby-code-text">reducer</code> ，<code class="gatsby-code-text">action</code> 分离的设计理念。</p>
</blockquote>
<h3 id="应用函子"><a href="#%E5%BA%94%E7%94%A8%E5%87%BD%E5%AD%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>应用函子</h3>
<h4 id="function-in-box"><a href="#function-in-box" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Function in Box</h4>
<p>上一小结，介绍了把函数装入 <code class="gatsby-code-text">LazyBox</code> 中，放在最后延迟执行，以保障最后大多数代码的 “pure” 特性。</p>
<p>转换下思维，函数可以认为是“惰性的值”，那么我们把这个稍显特殊的值，装入普通的 <code class="gatsby-code-text">Box</code> ，又会发生什么呢？还是从小学数学开始吧。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Box</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Box</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Box(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">addOne</span> <span class="token operator">=</span> x <span class="token operator">=></span> x <span class="token operator">+</span> <span class="token number">1</span>
<span class="token function">Box</span><span class="token punctuation">(</span>addOne<span class="token punctuation">)</span> <span class="token comment">// => Box(x => x + 1)</span></code></pre>
      </div>
<blockquote>
<p><code class="gatsby-code-text">inspect</code> 方法的目的是为了使用 Node.js 中的 <code class="gatsby-code-text">console.log</code> 隐式的调用它，方便我们查看数据的类型；而这一方法在浏览器中不可行，可以用 <code class="gatsby-code-text">console.log(String(x))</code> 来代替; Node.js V12 API 有变更，可以采用 <code class="gatsby-code-text">Symbol.for(&#39;nodejs.util.inspect.custom&#39;)</code> 替代 <code class="gatsby-code-text">inspect</code></p>
</blockquote>
<p>现在我们得到了一个包裹着函数的 <code class="gatsby-code-text">Box</code> ，可是我们怎么使用这个函数呢？毕竟 <code class="gatsby-code-text">Box(x).map</code> 方法都是接收一个函数！继续回到函数 <code class="gatsby-code-text">addOne</code> 上，我们需要一个数字，传递给 <code class="gatsby-code-text">addOne</code> ，对吧！所以换句话说就是，我们怎么传递一个数字进去应用这个 <code class="gatsby-code-text">addOne</code> 函数呢，答案非常简单，继续传递一个被包裹的值，然后 <code class="gatsby-code-text">map</code> 这个函数 (<code class="gatsby-code-text">addOne</code>) 不就可以啦! 看代码：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Box</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Box</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    apply<span class="token punctuation">:</span> o <span class="token operator">=></span> o<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    flod<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Box(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token function">Box</span><span class="token punctuation">(</span>addOne<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token function">Box</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// => Box(3)</span></code></pre>
      </div>
<p>看看 Box 神奇的新方法，首先被包裹的值是一个<strong>函数 x</strong> ，然后我们继续传递另一个 <code class="gatsby-code-text">Box(2)</code> 进去，不就可以使用 <code class="gatsby-code-text">Box(2)</code> 上的 <code class="gatsby-code-text">map</code> 方法调用 <code class="gatsby-code-text">addOne</code> 函数了吗！</p>
<p>现在重新审视一下我们 <code class="gatsby-code-text">Box(addOne)</code> ，<code class="gatsby-code-text">Box(1)</code> ，那么这个问题实际上可以归结为：把一个 <code class="gatsby-code-text">functor</code> 应用到另一个上 <code class="gatsby-code-text">functor</code> 上，而这也就是 <code class="gatsby-code-text">Applicative Functor</code> (应用函子)最擅长的操作了，看一下示意图来描述应用函子的操作流程：</p>
<p><img src="https://p1.music.126.net/kfldU46LvUhUaY_QjP6LHw==/109951164712439705.png" alt="Applicative Functor"></p>
<p>所以根据上面的讲解和实例我们可以得出一个结论：先把一个值 <code class="gatsby-code-text">x</code> 装进 <code class="gatsby-code-text">Box</code>，然后 <code class="gatsby-code-text">map</code> 一个函数 <code class="gatsby-code-text">f</code>  和把函数 <code class="gatsby-code-text">f</code> 装进 <code class="gatsby-code-text">Box</code>，然后 <code class="gatsby-code-text">apply</code> 一个已经已经装进 <code class="gatsby-code-text">Box</code> 的 <code class="gatsby-code-text">x</code>，是完全等价的！</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token constant">F</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">F</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token constant">F</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token function">Box</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>addOne<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">Box</span><span class="token punctuation">(</span>addOne<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token function">Box</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// => Box(3)</span></code></pre>
      </div>
<blockquote>
<p>根据<a href="https://github.com/fantasyland/fantasy-land#applicative">规范</a>，apply 方法后面我们会简写为<code class="gatsby-code-text">ap</code>!</p>
</blockquote>
<blockquote>
<p><code class="gatsby-code-text">Applicative functor (应用函子)</code> 也是函数式编程中一大堆“故弄玄虚”的概念中唯一的比较“名副其实”的了，想想 <code class="gatsby-code-text">Functor(函子)</code></p>
</blockquote>
<h4 id="应用函子与函数柯里化"><a href="#%E5%BA%94%E7%94%A8%E5%87%BD%E5%AD%90%E4%B8%8E%E5%87%BD%E6%95%B0%E6%9F%AF%E9%87%8C%E5%8C%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>应用函子与函数柯里化</h4>
<p>在继续学习函数柯里化之前，先复习一下中学数学中的高斯消元法：设函数 <code class="gatsby-code-text">f(x,y) = x + y</code>，在 <code class="gatsby-code-text">y = 1</code> 的时候，函数可以修改为 <code class="gatsby-code-text">f(x) = x + 1</code> 。基本思路就是把二元变成一元，同理我们可以把三元函数降元为二元，甚至把多元函数降元为一元函数。   </p>
<p>那么我们可以在一定程度上认为函数求值的过程，就是就是函数消元的过程，当所有的元都被消完之后，那么就可以求的函数值。</p>
<p>数学中的高斯消元法和函数式编程中的“柯里化”是有点类似的，所谓函数柯里化就是把一个接收多个参数的函数，转换为一次接收一个参数，直到收到全部参数之后，进行函数调用(计算函数值)，看例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">+</span> y
<span class="token keyword">const</span> <span class="token function-variable function">curriedAdd</span> <span class="token operator">=</span> x <span class="token operator">=></span> y <span class="token operator">=></span> x <span class="token operator">+</span> y</code></pre>
      </div>
<p>好了，简单理解了函数柯里化的概念之后，继续往前走一步，思考一下，如果现在有两个「被包裹的值」，怎么把一个函数应用上去呢？举个例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">add</span> <span class="token operator">=</span> x <span class="token operator">=></span> y <span class="token operator">=></span> x <span class="token operator">+</span> y

<span class="token function">add</span><span class="token punctuation">(</span><span class="token function">Box</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token function">Box</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>上面的方案明显是走不通的，我们没办法直接把  <code class="gatsby-code-text">Box(1)</code> 和 <code class="gatsby-code-text">Box(2)</code> 相加，他们都在盒子里; </p>
<p>可是我们的需求不就是把 <code class="gatsby-code-text">Box(1)</code> ，<code class="gatsby-code-text">Box(2)</code>，<code class="gatsby-code-text">add</code> 三者互相应用一下，想要得到最后的结果 <code class="gatsby-code-text">Box(3)</code>。</p>
<p>从第一章开始，我们的函数运算都是在 Box 的“保护”下进行的，现在不妨也把 <code class="gatsby-code-text">add</code> 函数包装进 Box 中，不就得到了一个应用函子 <code class="gatsby-code-text">Box(add)</code>，然后继续 “apply” 其他的函子了吗？</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token function">Box</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">Box</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// => Box(y => 1 + y) (得到另一个应用函子)</span>
<span class="token function">Box</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">Box</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">Box</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// => Box(3) (得到最终的结果)</span></code></pre>
      </div>
<p>上面的例子，因为每次 <code class="gatsby-code-text">apply</code> 一个 <code class="gatsby-code-text">functor</code> ，相当于把函数降元一次，我们可以得出一个结论，<strong>一个柯里化的函数，有几个参数，我们就可以 apply 几次</strong>。</p>
<blockquote>
<p>每次 apply 之后都会返回包裹新函数的应用函子，换句话说就是：应用多个数据到多个函数，这和多重循环非常类似。</p>
</blockquote>
<h3 id="应用函子的应用案例"><a href="#%E5%BA%94%E7%94%A8%E5%87%BD%E5%AD%90%E7%9A%84%E5%BA%94%E7%94%A8%E6%A1%88%E4%BE%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>应用函子的应用案例</h3>
<p>表单校验是我们日常开发中常见的一个需求，举个具体的例子，假如我们有一个用户注册的表单，我们需要校验用户名，密码两个字段，常见的代码如下：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">checkUserInfo</span> <span class="token operator">=</span> user <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> pw<span class="token punctuation">,</span> phone <span class="token punctuation">}</span> <span class="token operator">=</span> user
    <span class="token keyword">const</span> errInfo <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token regex">/^[0-9].+$/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        errInfo<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'用户名不能以数字开头'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pw<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        errInfo<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token string">'密码长度必须大于6位'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>errInfo<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> errInfo
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> userInfo <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token punctuation">:</span> <span class="token string">'1Melo'</span><span class="token punctuation">,</span>
    pw<span class="token punctuation">:</span> <span class="token string">'123456'</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> checkRes <span class="token operator">=</span> <span class="token function">checkUserInfo</span><span class="token punctuation">(</span>userInfo<span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>checkRes<span class="token punctuation">)</span>  <span class="token comment">// => [ '用户名不能以数字开头', '密码长度必须大于6位' ]</span></code></pre>
      </div>
<p>这个代码自然没有问题，但是，假如我们要继续添加需要校验的字段(e.g.,电话号码，邮箱)， <code class="gatsby-code-text">checkUserInfo</code> 函数毫无疑问会越来越庞大，并且如果我们要修改某一个字段的校验规则的话，整个 <code class="gatsby-code-text">checkUserInfo</code> 函数可能会受到影响，我们需要增加的单元测试工作要更多了。</p>
<p>回想一下第一章中介绍的 Either(Left or Rigth) <code class="gatsby-code-text">Right</code> 指代正常的分支，<code class="gatsby-code-text">Left</code> 指代出现异常的分支，他们两者绝不会同时出现，现在我们稍微换个理解方式：<code class="gatsby-code-text">Right</code> 指代校验通过的分支，<code class="gatsby-code-text">Left</code> 指代校验不通过的分支。</p>
<p>此时我们继续在第一章 Either 的基础上扩展其他的属性和方法，用来做表单校验的工具：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Right</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Right</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    ap<span class="token punctuation">:</span> o <span class="token operator">=></span> o<span class="token punctuation">.</span>isLeft <span class="token operator">?</span> o <span class="token punctuation">:</span> o<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    fold<span class="token punctuation">:</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    isLeft<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    isRight<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Right(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">Left</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Left</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    ap<span class="token punctuation">:</span> o <span class="token operator">=></span> o<span class="token punctuation">.</span>isLeft <span class="token operator">?</span> <span class="token function">Left</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">Left</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    fold<span class="token punctuation">:</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    isLeft<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    isRight<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Left(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>相对比与原 <code class="gatsby-code-text">Either</code>，新增了 <code class="gatsby-code-text">x</code> 属性和 <code class="gatsby-code-text">ap</code> 方法，其他的属性完全类似，就不做解释了；新增 <code class="gatsby-code-text">x</code> 属性的原因在于需要记录表单校验的错误信息，这个很好理解，而新增的 <code class="gatsby-code-text">isLeft</code> ，<code class="gatsby-code-text">isRight</code> 属性就更简单了，用来区分 <code class="gatsby-code-text">Left/Right</code> 分支。 </p>
<p>我们仔细看一下新增的 <code class="gatsby-code-text">ap</code> 方法，先看 <code class="gatsby-code-text">Right</code> 分支的 <code class="gatsby-code-text">ap: o =&gt; o.isLeft ? o : o.map(x)</code>，毫无疑问 <code class="gatsby-code-text">ap</code> 方法接收另一个 <code class="gatsby-code-text">functor</code> ，如果另一个 <code class="gatsby-code-text">functor</code> 是 <code class="gatsby-code-text">Left</code> 的实例，则不需要 <code class="gatsby-code-text">Right</code> 处理直接返回，如果是 <code class="gatsby-code-text">Right</code> ，则和平常 <code class="gatsby-code-text">applicative functor</code> 一样，对 <code class="gatsby-code-text">o</code> 作为主体进行 <code class="gatsby-code-text">map</code>。</p>
<p><code class="gatsby-code-text">Left</code> 分支上的 <code class="gatsby-code-text">ap: o =&gt; o.Left ? Left(x.concat(o.x)) : Left(x)</code>，如果是 <code class="gatsby-code-text">Left</code> 的实例，则进行一个“叠加”，实际上就是为了累加错误信息，而如果不是 <code class="gatsby-code-text">Left</code> 的实例则直接返回原本已经记录的错误信息。</p>
<p>做好了前期的准备工作，我们就可以大刀阔斧的按照函数式的思维(函数组合)来拆分一下 <code class="gatsby-code-text">checkUserInfo</code> 函数：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">checkName</span> <span class="token operator">=</span> name <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token operator">/</span><span class="token operator">^</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token operator">+</span>$<span class="token operator">/</span><span class="token punctuation">.</span><span class="token function">test</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">Left</span><span class="token punctuation">(</span><span class="token string">'用户名不能以数字开头'</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">Right</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> <span class="token function-variable function">checkPW</span> <span class="token operator">=</span> pw <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> pw<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">6</span> <span class="token operator">?</span> <span class="token function">Left</span><span class="token punctuation">(</span><span class="token string">'密码长度必须大于6位'</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">Right</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>上面把两个字段校验从一个函数中拆分成了两个函数，更重要的是完全解耦；返回值要么是校验不通过的 <code class="gatsby-code-text">Left</code> ，要么是校验通过的 <code class="gatsby-code-text">Right</code> ，所以我们可以理解为现在有了两个 <code class="gatsby-code-text">Either</code>，只要我们再拥有一个 <strong>被包裹进Either盒子并且柯里化两次的函数</strong> 不就可以让他们互相 apply 了吗？</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token constant">R</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'ramda'</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">success</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token boolean">true</span>

<span class="token keyword">function</span> <span class="token function">checkUserInfo</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> pw<span class="token punctuation">,</span> phone <span class="token punctuation">}</span> <span class="token operator">=</span> user
    <span class="token comment">// 2 是因为我们需要 `ap` 2 次。</span>
    <span class="token keyword">const</span> returnSuccess <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">curryN</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> success<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">Right</span><span class="token punctuation">(</span>returnSuccess<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">checkName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">checkPW</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> checkRes <span class="token operator">=</span> <span class="token function">checkUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'1Melo'</span><span class="token punctuation">,</span> pw<span class="token punctuation">:</span> <span class="token string">'123456'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>checkRes<span class="token punctuation">)</span> <span class="token comment">// => Left(用户名不能以数字开头密码长度必须大于6位)</span>

<span class="token keyword">const</span> checkRes2 <span class="token operator">=</span> <span class="token function">checkUserInfo</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Melo'</span><span class="token punctuation">,</span> pw<span class="token punctuation">:</span> <span class="token string">'1234567'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>checkRes2<span class="token punctuation">)</span> <span class="token comment">// => Right(true)</span></code></pre>
      </div>
<p>现在 <code class="gatsby-code-text">checkUserInfo</code> 函数的返回值是一个 Either(Left or Righr) 函子，具体后面就可以继续使用 <code class="gatsby-code-text">fold</code> 函数，展示校验不通过弹窗或者进行下一步的表单提交了。</p>
<blockquote>
<p>关于校验参数使用 <a href="https://codurance.com/2018/01/11/applicatives-validation/">Validation</a> 函子更合适 ，这里为了聚焦讲解 Applicative Functor 理念这条主干线，就不再继续引入新概念了。</p>
</blockquote>
<h3 id="pointfree风格"><a href="#pointfree%E9%A3%8E%E6%A0%BC" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PointFree风格</h3>
<p>上面举例说明的 <code class="gatsby-code-text">checkUserInfo</code> 函数，需要 <code class="gatsby-code-text">ap</code> 两次，感觉有点繁琐(想想如果我们需要校验更多的字段呢？)，我们可以抽象出一个 point-free 风格的函数来完成上述操作：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">apply2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">T</span><span class="token punctuation">,</span> g<span class="token punctuation">,</span> funtor1<span class="token punctuation">,</span> functor2<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">T</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>funtor1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor2<span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">checkUserInfo</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> pw<span class="token punctuation">,</span> phone <span class="token punctuation">}</span> <span class="token operator">=</span> user
    <span class="token keyword">const</span> returnSuccess <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">curryN</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> success<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">apply2</span><span class="token punctuation">(</span>Right<span class="token punctuation">,</span> returnSuccess<span class="token punctuation">,</span> <span class="token function">checkName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">checkPW</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p><code class="gatsby-code-text">apply2</code> 函数的参数特别多，尤其是需要传递 <code class="gatsby-code-text">T</code> 这个不确定的容器，用来把普通函数 <code class="gatsby-code-text">g</code> 装进盒子里。</p>
<blockquote>
<p>把一个“值”(任意合法类型，当然包括函数)，装进容器中 (Box or Context) 中有一个统一的方法叫 <code class="gatsby-code-text">of</code> ，而这个过程被称为 <code class="gatsby-code-text">lift</code> ，意为提升：即把一个值提升到一个上下文中。</p>
</blockquote>
<p>再回头看看前面介绍的：<code class="gatsby-code-text">Box(addOne).ap(Box(2))</code> 和 <code class="gatsby-code-text">Box(2).map(addOne)</code> 从结果 (<code class="gatsby-code-text">Box(3)</code>) 上来看是一样。也就说执行 map 操作 (<code class="gatsby-code-text">map(addOne)</code>)等同于先执行 of (<code class="gatsby-code-text">Box(addOne)</code>)，然后执行 ap (<code class="gatsby-code-text">ap(Box(2))</code>)，用公式表达就是：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token constant">F</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token constant">F</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">F</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span></code></pre>
      </div>
<p>套用公式，我们可以修改简化 <code class="gatsby-code-text">apply2</code>  函数体中的 <code class="gatsby-code-text">T(g).ap(funtor1)</code> 为 <code class="gatsby-code-text">funtor1.map(g)</code> ，看下面的对比：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">apply2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">T</span><span class="token punctuation">,</span> g<span class="token punctuation">,</span> funtor1<span class="token punctuation">,</span> functor2<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">T</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>funtor1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor2<span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">liftA2</span> <span class="token operator">=</span> <span class="token punctuation">(</span>g<span class="token punctuation">,</span> funtor1<span class="token punctuation">,</span> functor2<span class="token punctuation">)</span> <span class="token operator">=></span> funtor1<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor2<span class="token punctuation">)</span></code></pre>
      </div>
<p>看到了上面的关键点了吗？上面的 <code class="gatsby-code-text">liftA2</code> 函数中不再耦合于 “T” 这个特定类型的盒子，这样更加的通用灵活。</p>
<p>按照上面的理论，可以改写 <code class="gatsby-code-text">checkUserInfo</code> 函数为：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">checkUserInfo</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> pw<span class="token punctuation">,</span> phone <span class="token punctuation">}</span> <span class="token operator">=</span> user
    <span class="token keyword">const</span> returnSuccess <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span><span class="token function">curryN</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> success<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">return</span> <span class="token function">liftA2</span><span class="token punctuation">(</span>returnSuccess<span class="token punctuation">,</span> <span class="token function">checkName</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">checkPW</span><span class="token punctuation">(</span>pw<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>现在再假设一下我们新增了需要校验的第三个字段“手机号码”，那完全可以扩展 liftA2 函数为 liftA3，liftA4 等等:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">liftA3</span> <span class="token operator">=</span> <span class="token punctuation">(</span>g<span class="token punctuation">,</span> funtor1<span class="token punctuation">,</span> functor2<span class="token punctuation">,</span> functor3<span class="token punctuation">)</span> <span class="token operator">=></span> funtor1<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor3<span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token function-variable function">liftA4</span> <span class="token operator">=</span> <span class="token punctuation">(</span>g<span class="token punctuation">,</span> funtor1<span class="token punctuation">,</span> functor2<span class="token punctuation">,</span> functor3<span class="token punctuation">,</span> functor4<span class="token punctuation">)</span> <span class="token operator">=></span> funtor1<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor3<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor4<span class="token punctuation">)</span></code></pre>
      </div>
<blockquote>
<p>刚开始可能会觉得 <code class="gatsby-code-text">liftA2-3-4</code> 看起来又丑又没必要；这种写法的意义在于：固定参数数量，一般会在函数式的 lib 中提供，不用自己手动去写这些代码。</p>
</blockquote>
<h3 id="applicative-functor-和-functor-的区别和联系"><a href="#applicative-functor-%E5%92%8C-functor-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Applicative Functor 和 Functor 的区别和联系</h3>
<p>根据  <code class="gatsby-code-text">F(f).ap(F(x)) == F(x).map(f)</code>，我们可以得出一个结论，假如一个盒子 (Box) ，实现了 <code class="gatsby-code-text">ap</code> 方法，那么我们一定可以利用 <code class="gatsby-code-text">ap</code> 方法推导出一个 <code class="gatsby-code-text">map</code> 方法，如果拥有了 <code class="gatsby-code-text">map</code> 方法，那它就是一个 <code class="gatsby-code-text">Functor</code> ，所以我们也可以认为 <code class="gatsby-code-text">Applicative</code> 是 <code class="gatsby-code-text">Functor</code> 的拓展，比 <code class="gatsby-code-text">Functor</code> 更强大。</p>
<p>那么强大在何处呢？<code class="gatsby-code-text">Functor</code> 只能映射一个接收单个参数的函数(e.g., <code class="gatsby-code-text">x =&gt; y</code>)，如果我们想把接收多个参数的函数(e.g., <code class="gatsby-code-text">x =&gt; y =&gt; z</code>)应用到多个值上，则是 <code class="gatsby-code-text">Applicative</code> 的舞台了，想想 <code class="gatsby-code-text">checkUserInfo</code> 的例子。</p>
<blockquote>
<p>毫无疑问，Applicative Funtor 可以 <code class="gatsby-code-text">apply</code> 多次（当然包括一次），那么如果函数只有一个参数的情况下，则可以认为 <code class="gatsby-code-text">map</code> 和 <code class="gatsby-code-text">apply</code> 是等效的，换句话说：<code class="gatsby-code-text">map</code> 相当于 <code class="gatsby-code-text">apply</code> 一次。</p>
</blockquote>
<p>上面是实际应用中的对比，从抽象的数学层面来对比：</p>
<ul>
<li>Functor: 应用一个函数到包裹的值：<code class="gatsby-code-text">Box(1).map(x =&gt; x+1)</code>.</li>
<li>Applicative: 应用一个包裹的函数到包裹的值：<code class="gatsby-code-text">Box(x =&gt; x+1).ap(Box(1))</code>。</li>
</ul>
<p><img src="https://p1.music.126.net/qnIolKU9yLB9tH7onLbj7w==/109951164719087429.png" alt="applicative vs functor"></p>
<h3 id="总结与计划"><a href="#%E6%80%BB%E7%BB%93%E4%B8%8E%E8%AE%A1%E5%88%92" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结与计划</h3>
<p>我们从纯函数与副作用的概念入手介绍了 <code class="gatsby-code-text">LazyBox</code> (惰性求值)的概念，从而引入了把函数这个“特殊的值”装进 Box 中，以及怎么 apply 这个“盒子中的函数”，然后介绍了函数柯里化与应用函子的关系(被装进盒子里的函数必须是柯里化的函数)；然后使用使用扩展后的 <code class="gatsby-code-text">Either</code> 来做表单校验，解耦合函数，最后介绍了使用 point-free 风格来编写链式调用。</p>
<h4 id="计划"><a href="#%E8%AE%A1%E5%88%92" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>计划</h4>
<p>到目前为止，我们所讨论的问题都是同步的问题，但是在 Javascript 的世界中 90% 的代码都是异步，可以说异步才是 JavaScript 世界的主流，谁能更优雅的解决异步的问题，谁就是  JavaScript 中的大明星，从 <code class="gatsby-code-text">callback</code> ，到 <code class="gatsby-code-text">Promise</code> ，再到 <code class="gatsby-code-text">async await</code> ，那么在函数式编程中异步又该如何解决呢，下一章我们将会介绍一个重量级的概念 <code class="gatsby-code-text">Monad</code> 以及<code class="gatsby-code-text">异步函数的组合</code>。   </p>
<p>参考资料与引用文章：   </p>
<ul>
<li>1.<a href="https://medium.com/axiomzenteam/functor-applicative-and-why-8a08f1048d3d">Functor, Applicative, and Why</a>   </li>
<li>2.<a href="https://stackoverflow.com/questions/46752031/what-is-my-applicative-functor-not-working-with-ramdas-ap">Applicative and list</a>   </li>
<li>3.<a href="https://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures</a>     </li>
<li>4.<a href="https://codurance.com/2018/01/11/applicatives-validation/">Applicative Functors and data validation</a>     </li>
<li>5.<a href="https://hackage.haskell.org/package/validation">validation: A data-type like Either but with an accumulating Applicative</a>     </li>
<li>6.<a href="https://medium.com/beingprofessional/understanding-functor-and-monad-with-a-bag-of-peanuts-8fa702b3f69e">Understanding Functor and Monad With a Bag of Peanuts</a>     </li>
<li>7.<a href="https://jrsinclair.com/articles/2018/how-to-deal-with-dirty-side-effects-in-your-pure-functional-javascript/">How to deal with dirty side effects in your pure functional javascript</a>    </li>
<li>8.<a href="https://medium.com/free-code-camp/functional-programming-in-js-with-practical-examples-part-2-429d2e8ccc9e">Functional Programming In JavaScript — With Practical Examples</a>     </li>
<li>9.《JavaScript函数式编程》    </li>
</ul>]]></description><link>https://reactjs.org/blog/2020/02/05/应用函子.html</link><guid isPermaLink="false">https://reactjs.org/blog/2020/02/05/应用函子.html</guid><pubDate>Tue, 04 Feb 2020 16:00:00 GMT</pubDate></item><item><title><![CDATA[动物庄园]]></title><description><![CDATA[<hr>
<p>几年过去了。寒来暑往，时光流逝，寿命不长的动物一生更如白驹过隙。已经到了没有谁还记得造反前是怎么回事的那样一个时代，除了紫苜蓿、本杰明、乌鸦摩西和几口猪。</p>
<p>母山羊慕莉尔死了；蓝铃铛、杰茜和钳爪都死了。琼斯也死了——他死在本郡另一头的酒鬼收容所里。雪球已被遗忘。拳击手也被遗忘了，除非少数认识他的动物才记得。紫苜蓿如今已是一匹发福的老母马，关节僵硬，眼睛动辄分泌黏液。她已超过退休年龄两岁，但实际上从来没有动物真正退休。给超龄动物留出草地一角之议，早就被束之高阁。拿破仑如今是一头重达三百三十磅的成熟公猪。吱嘎胖得几乎睁不开眼睛。唯独老本杰明大体上还是过去的模样，只是鼻口处的毛色稍增灰白，还有就是自打拳击手死后越发孤僻自闭，寡言少语。</p>
<p>如今农场里的动物增加了许多，尽管增长幅度并不像早些年头预期的那么大。对于后来出生的动物，造反仅仅是一个口口相传的模糊的传说，而另一些从别处购进的动物，在来到此地之前压根儿就没听谁提起过这么一档子事。现在农场除紫苜蓿外拥有三匹马。他们都是挺拔健壮的好牲口，勤劳肯干，和睦友好，只是蠢得要命。他们中没有一匹认得B以后的字母。他们全盘接受所听到的关于造反和动物主义原则的说法，尤其是出自紫苜蓿之口的，因为他们对紫苜蓿怀有近乎孝心的尊敬；不过，他们对于所听到的究竟能懂得多少，那可要存疑了。</p>
<p>现在的农场比往昔较为富裕，生产组织得也较好；它的面积有所扩大，增加了从皮尔金顿那儿购得的两块地。风车最终还是圆满建成了，农场拥有属于自己的一台脱粒机和一台捆草机，此外还新盖了各种不同的建筑物。温珀给自己购置了一辆双轮轻便马车。不过，风车到头来却并没有用于发电。它被用来碾磨谷物，收益颇丰。动物们正在努力建造另一座风车；据说等这第二座建成后将要安装发电机组。不过，当初雪球教动物们梦想过上的奢华生活——有电灯照明和冷热水齐全的厩舍，一周三天工作制——再也不谈了。拿破仑指责这种想法是与动物主义的精神背道而驰的。他说，真真正正的幸福就在于勤奋的工作和俭朴的生活。</p>
<p>不知怎么的，虽然农场比过去富了，可是动物们自己似乎并没有什么富裕起来的迹象——当然，猪和狗不在此例。也许，部分原因就在于有那么多的猪和那么多的狗。倒不是说这两种动物不劳动——这是他们的做派。问题在于，就像吱嘎从来不厌其烦地解释的那样，在农场的管理和组织方面有干不完的工作。这些工作中有许多属于其他动物过于无知而理解不了的。例如，吱嘎曾告诉他们，猪不得不每天耗费大量劳动在叫做“档案”、“报告”、“议事录”、“备忘录”的神秘事务上头。那都是大张大张的纸，必须在上面密密麻麻地写上字，一旦这些纸写满了字，就会放到炉子里烧掉。这对农场的福祉都是至关重要的，吱嘎说。但迄今为止，猪也罢，狗也罢，都还没有用他们自己的劳动生产过任何食物；而他们的数量却非常之多，他们的胃口又始终非常之好。</p>
<p>至于其他动物，据他们所知，他们的生活还一直是老样子。他们普遍吃不饱，睡干草，喝池塘水，干农活；冬天他们苦于寒冷，夏天受苍蝇骚扰。有时他们中年龄大些的，会去搜索他们模糊的记忆，试图就这样一个问题做出判断：在早先造反的日子里，那会儿琼斯被赶走还不太久，当时的日子是比现在好，还是比现在差。他们记不起来了。他们没有任何东西可以拿来同当前的生活做比较，因为他们没有任何参照的依据，除非以吱嘎的长长一大串一大串数字为准，而这些数字一贯表明任何事物都是越来越好，越来越好。动物们发现这个问题没法儿解决；他们现在没工夫思考这些事情。只有老本杰明表示自己漫长一生的每一个细节他都记得起来，也知道事情从来没有、也永远不会大大好于过去或大大不如过去——反正饥饿、辛苦和失望是生活的不变法则，他如是说。</p>
<p>然则动物们从不放弃希望。非但如此，他们从来不曾，哪怕只是短短的一瞬间也不曾丧失自己作为动物农物成员之一的荣誉感和优越感。他们至今仍是全郡——也是全英格兰！——唯一属动物们所有并由动物们运作的农场。他们中的任何一员，即便是最年轻的，即便是从十英里或二十英里以外买来的，无不始终对这一点感到惊讶。每当他们听到猎枪鸣响，看见绿旗在旗杆顶上迎风飘扬，他们心中总会充盈着不灭的自豪，于是话题必然转向往昔的英雄岁月，转向驱逐琼斯，书写《七诫》，以及入侵的人类被打得落荒而逃的那两次伟大战役。旧时的梦想一个也没有舍弃。老少校曾经预言的动物共和国，动物们仍坚信不疑，到那时英格兰的绿野将不容人类践踏。这个预言总有一天会实现，也许不会很快，也许目前活着的任何动物有生之年谁也盼不到，可那一天还是会到来。甚至《英格兰的生灵》的曲调也有动物在这里或那里偷偷哼唱，至少农场的每一只动物都知道这首歌总是一个事实，尽管谁也不敢大声唱。他们的一生也许过得很苦，他们的希望也许并没有完全实现，但他们意识到自己跟别的动物不一样。如果他们吃不饱，那并非由于必须养活对他们实施暴政的人类；如果他们工作很辛苦，至少他们是为自己工作。他们中没有谁是用两条腿行走的。没有哪只动物称任何别的动物“东家”。凡动物一律平等。</p>
<p>入夏不久的一天，吱嘎命令几只绵羊跟他走，并把他们带到农场另一头一块蔓生着许多桦树苗的荒地上。绵羊们在那儿呆了一整天，在吱嘎的监督下啮食嫩叶。傍晚，吱嘎独自回到宅子，但由于天气暖和，他吩咐绵羊们仍留在荒地上。结果他们在那儿一留就是整整一个星期，这段时期其他动物都不见他们的踪影。吱嘎每天的大部分时间都和绵羊待在一起。他说自己在教他们唱一首新歌，必须不受打扰。</p>
<p>直到绵羊们回去以后，一个惬意的傍晚，动物们已经收工，正在返回农场居住区的路上，这时从院子里传来一匹马受惊的嘶鸣，收工的动物们给吓得在原地站住，一动也不动。那是紫苜蓿的嘶叫声。她再次发出一声长啸，这一回所有的动物全都撒腿飞奔冲进院子。这时他们看到了紫苜蓿所看到的情景。</p>
<p>那是一头猪在用他的后腿行走。</p>
<p>没错，那是吱嘎。他正从院子的一头向另一头踱去，稍稍显得有点儿笨拙，仿佛还不太习惯按这样的姿势支撑自己硕大的身躯，但平衡保持得十分完美。仅仅过了片刻，从农场主宅子门内走出一长列猪，全都用他们的两条后腿行走。一些猪走得比另一些较好，有一两头甚至步态略显不稳，看样子他们最好能有一根拐棍作支持，但他们每一头都成功地绕院子走了一圈。临了是一片惊心动魄的狗叫和黑色小公鸡喔喔喔的尖声啼鸣，于是拿破仑亲自驾临，气宇轩昂，目光傲慢地从这一边扫向另一边，他的狗保镖们在他周围又蹦又跳。</p>
<p>他的前蹄夹着一条鞭子。</p>
<p>这时出现了一片死一般的寂静。</p>
<p>惊愕、恐惧的动物们互相挤做一团，瞧着猪们排成长列绕院子缓慢行进。这光景就像是世界给倒了过儿似的。当最初的震悚已经消逝，尽管他们仍然慑于狗们的淫威，尽管经年累月养成的习惯就是不管发生什么事情概不抱怨，概不批评，尽管这一切并没有改变，但现在已到了这样的时刻，动物们可以置以上的一切于不顾，说出一两句表示抗议的话了。但是，恰恰在这个当口儿，所有的绵羊像接到一个信号似的，一下子爆发出声势汹汹的咩咩大合唱——“四条腿好，两条腿更好！四条腿好，两条腿更好！四条腿好，两条腿更好！”</p>
<p>如是者共持续达五分钟之久，没有停顿。及至绵羊们完全静下来，表示任何抗议的机会已经成为过去，因为猪们的队伍回到宅内去了。</p>
<p>本杰明感到有一个鼻子挤压着他的肩膀。他转过头去一看。是紫苜蓿。她的老眼似乎比以往任何时候更加昏花。她什么也不说，只是轻轻拽住本杰明的鬃毛把他带到写着《七诫》的大谷仓尽头外墙跟前。他俩站住脚，盯着涂了柏油写上白字的那堵墙约莫有一两分钟。</p>
<p>“我的眼神越来越不济了，”紫苜蓿终于说。“即使在我年轻时我也念不了那上面写的什么。可是我总觉得那堵墙看上去跟以前不一样。这《七诫》还是往常的《七诫》吗，本杰明？”</p>
<p>本杰明只此一遭同意打破他自己的规矩，把写在墙上的字念给紫苜蓿听。如今墙上只有一条戒律，其余什么都没有。那唯一的一诫是：</p>
<p>“凡动物一律平等</p>
<p>但是有些动物比别的动物更加平等”</p>
<p>明乎此，第二天农场里的监工猪一个个都用蹄子夹着皮鞭就不足为怪了。之后，据悉猪们又给自己购置了无线电收音机，并准备安装电话，还订阅了《约翰牛》、《花边新闻》和《每日镜报》，当然也不足为怪。同样不足为怪的还有拿破仑被看见叼着一支烟斗在农场主宅内花园里散步——不，不，甚至还有猪们把琼斯先生衣柜里的服装取出来穿在自己身上；拿破仑自己公然身穿黑上衣、猎装裤，绑着皮裹腿招摇过市；而深得他宠爱的一头母猪身上则是过去琼斯太太星期日才穿的一袭波纹绸连衣裙。</p>
<p>一周后的下午，一溜儿好几辆双轮小马车来到农场。由附近几位农场主组成一个代表团应邀前来考察。来宾们被领到农场各处参观，他们对所看到的一切，特别对风车表示高度赞扬。动物们正在萝卜地里锄草。他们干得很勤勉，眼睛一直看着地上，几乎连头也不抬，不知道他们更害怕猪还是人。</p>
<p>那天晚上，从农场主宅内传来喧闹异常的欢笑声和唱歌声。忽然间，动物们被混杂在一起的各种声音激起了好奇之心。既然动物和人头一回平起平坐聚在一起，倒要瞅瞅究竟会发生什么事情？于是他们不约而同地尽可能放轻脚步开始向农场主宅子的花园里溜进去。</p>
<p>到门口他们停了下来，不太敢再往前走，但紫苜蓿带头走进去。他们踮着脚挨到宅子跟前，某些个子够高的动物通过餐厅的窗户朝里张望。那里，在一张长桌周围坐着六个农场主和六头地位较高的猪。拿破仑自己占着餐桌一端的荣誉席位。猪们坐在椅子上的姿态相当自在。宾主们原先在打牌散心来着，后来放下纸牌暂停片刻，显然为了举杯祝酒。一把大酒壶不断传来递去，带把儿的大杯子一再斟满啤酒。谁也没有注意到，动物们一张张神情讶异的脸正从窗外一眼不眨地往里凝视。</p>
<p>狐苑农场的皮尔金顿先生手执酒杯站起身来。他说，此刻他想请在座的诸位干上一杯。但在举杯之前，他觉得自己有义务先说几句话。</p>
<p>皮尔金顿先生说，能感到很长一个时期以来的不信任和误会现已告终，这对他来说是皆大欢喜的缘由——他相信对在座的其他各位来说亦然如此。曾经有一段时间——虽然他或在座的任何一位都不认同这种态度——但确实曾有一段时间，尊敬的动物农场几位业主遭到来自他们的人类邻居的……他不愿说敌视，但或许可以说是某种程度的猜疑。不幸的事件时有发生，错误的观念被普遍接受。当时觉得，一家由猪当业主和经营管理的农场的存在，总有些不太正常，会对周边邻居产生一种不安定的影响。为数极多的农场主未做调查研究便认定，这样的农场里主宰一切的必然是无法无天、恣意胡为的歪风邪气。这些农场主十分忧虑他们自己的动物乃至他们的人类雇员会受到影响。但所有这一切疑虑如今均已消除。今天他和他的几位朋友一起来动物农场参观访问，亲眼考察了这里的每一寸土地，他们发现了什么呢？不光操作规程是最现代的，而且工作纪律严明，到处井然有序，这些对于任何地方的农场主都堪为楷模。动物农场的低等动物比郡内任何动物干的活更多，而消耗的饲料却更少——他相信自己这样说没错。确实，他和他的同行参观者们今天看到的很多东西，他们打算马上引进到自己的农场里去。</p>
<p>他说，在发表自己这番感想的末尾，他要再一次强调，过去存在于动物农场与它邻居之间的友好感情应该继续留存下去。猪与人之间过去没有，也没有必要产生任何利害冲突。他们努力奋斗的目标和面临的困难是相同的。劳工问题在任何地方不都是一样的吗？说到这里，皮尔金顿先生显然有意向大家抛出一句精心准备好的俏皮话，然而有一瞬间他自己越想越觉得可笑，以致话也说不出来。他呛了好一阵子，在这期间他那呈多级台阶状的下巴转成了紫色，呛过以后，他总算说出了口：“你们有你们的低等动物需要对付，”他说，“我们有我们的下层阶级需要摆平！”这句妙语一出，举座为之笑得前俯后仰；于是皮尔金顿先生就他在动物农场观察到的食品定量低、工作时间长以及绝无纪律松弛现象再一次向猪们表示祝贺。</p>
<p>皮尔金顿先生最后请在座各位全体起立，先把各自的酒杯斟满。“先生们，”皮尔金顿说，“先生们，我建议大家一起举杯：祝动物农场财运亨通！”</p>
<p>这时响起一片兴高采烈的欢呼声和跺足声。拿破仑心里简直乐开了花，竟然离开自己的席位，绕到桌子另一端去跟皮尔金顿先生先碰过杯，然后再一饮而尽。这一轮的祝酒和欢呼平静下来后，依然用两条后腿站着的拿破仑表示他也有几句话要说。</p>
<p>和拿破仑所有的发言一样，这次讲话也很短，而且直奔主题。他说，他对于误会误解的时期终于结束也感到很高兴。在一个长时期内有流言在传播——他有理由认为是敌人恶意散播的——说他自己以及他的同事们的观点含有某种颠覆性，甚至革命性的内容。外界认为他们图谋煽动附近几家农场的动物起来造反。没有比这种谣言离事实真相更远的了！拿破仑和他的同事们的唯一愿望，现在和过去都是同他们的邻居和睦共处，保持正常的商务关系。他补充说，他有幸负责监管的这个农场，是一个合作社性质的企业。由他亲自保管的产权证书属于猪们共有。</p>
<p>他说他不信旧的猜疑还会残存下来，但前不久农场在规章制度方面还是做了若干变更，这些举措应该会收到进一步推动互信的效果。到目前为止，农场的动物们有一个颇为愚蠢的惯例，就是互相称呼“同志”。这个称呼必须禁止使用。另外还有一条非常奇怪的旧规，其起因已无从查考，那就是每星期日早晨必须列队走过钉在花园内木柱上的一个公猪头颅。这一陋规也将取消，那个骷髅头已经被掩埋。来宾们可能已经看到有一面绿色旗帜飘扬在旗杆顶上。如果看到了，他们或许会留意原先标在旗帜上面的白色蹄角现在已被撤去。今后它将是一面素色的绿旗。</p>
<p>他说，对于皮尔金顿先生刚才那一席洋溢着睦邻友情的精彩讲话，他只有一点批评意见。皮尔金顿先生始终称本农场为“动物农场”。皮尔金顿先生当然不可能知道——因为他，拿破仑，现在才第一次正式宣布此事：“动物农场”这个名称已经废除。今后农场将被称为“庄园农场”——他相信这才是农场正确的原名。</p>
<p>“先生们，”拿破仑如此结束他的发言，“我也要像刚才那样建议大家一齐举杯，但要换一种方式。请把你们的酒杯斟满。先生们，我的祝酒词是：祝庄园农场财运亨通！”</p>
<p>又是和先前同样尽兴尽情的欢呼，酒杯里全都点滴不剩。但是，就在动物们从窗外注视着这幅景象时，他们觉得好像有什么事情快要发生了。猪们的脸上究竟什么起了变化？紫苜蓿的老眼把昏花的视线从一张脸移到另一张脸。其中一张有五个下巴颏儿，一张有四个，一张有三个。但究竟是什么似乎在漫漶和变化？这时，掌声停息，宾主拿起纸牌继续玩刚才被打断的牌戏，窗外的动物们悄无声息地离开那儿。</p>
<p>但是他们走开还没有超过二十码距离，又骤然站住。好多条嗓子大吵大嚷的喧哗声从农场主宅内传来。动物们赶回去重又朝窗内张望。没错儿，一场激烈的争吵正在进行中。那里边有破口大骂的，有拍桌子的，有犀利的目光怀疑对方作弊的，有气急败坏矢口否认的。翻脸的缘起好像是拿破仑和皮尔金顿先生同时都打出一张黑桃A。</p>
<p>十二条嗓门暴跳如雷地吼叫，声音全都一个样。这下弄明白了，猪们的脸究竟出了什么问题。敢情动物们从窗外朝里望，目光从猪移到人，再从人移到猪，又重新从猪移到人，要分清哪张脸是猪的，哪张脸是人的，已经不可能了。    </p>
<p>— 乔治·奥威尔</p>]]></description><link>https://reactjs.org/blog/2020/02/01/动物庄园.html</link><guid isPermaLink="false">https://reactjs.org/blog/2020/02/01/动物庄园.html</guid><pubDate>Fri, 31 Jan 2020 16:00:00 GMT</pubDate></item><item><title><![CDATA[薛定谔的 Maybe - IO]]></title><description><![CDATA[<h3 id="副作用"><a href="#%E5%89%AF%E4%BD%9C%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>副作用</h3>
<p>程序的可观察，而不是操作了一番然后睡觉去了</p>
<p>上篇文章中引入范畴学中<code class="gatsby-code-text">Functor</code>的概念，核心内容就是把一个值放入到一个<code class="gatsby-code-text">Box</code>中，然后不停的通过<code class="gatsby-code-text">map</code>函数来映射变换其中的值，而这就是一个最简单的<code class="gatsby-code-text">Identity Functor</code>,但是管他呢，我们还是叫它Box吧(多么简单形象)！</p>
<p>然后还举了个Either的例子，来说明Box理念在代码中实际用途，接下来介绍另外两个常用的<code class="gatsby-code-text">Box</code>:<strong><code class="gatsby-code-text">Maybe</code></strong>,<strong><code class="gatsby-code-text">IO</code></strong></p>
<h3 id="schrödingers-maybe"><a href="#schr%C3%B6dingers-maybe" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schrödinger’s Maybe</h3>
<p><img src="./imgs/cat.jpeg" alt="薛定谔的猫"></p>
<blockquote>
<p>I call it my billion-dollar mistake. It was the invention of the null reference in 1965. — Tony Hoare</p>
</blockquote>
<p>在项目开发中无时不刻不在遇到<code class="gatsby-code-text">null</code>的问题,举个实际的例子，最近在做一个换肤的功能，需要根据用户的选择来动态的加载CSS主题样式，需要编写一个<code class="gatsby-code-text">getThemeForUser</code>函数，根据用户的之前的选择，从URL列表中中返回合适的URL，看个简单的代码描述：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>
  id<span class="token punctuation">:</span> <span class="token string">'hzxxxx'</span><span class="token punctuation">,</span>
  name<span class="token punctuation">:</span> <span class="token string">'zhangsan'</span><span class="token punctuation">,</span>
  infos<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    theme<span class="token punctuation">:</span> <span class="token string">'red'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token constant">THEME_CSS_URLS</span> <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token string">'default'</span><span class="token punctuation">:</span> <span class="token string">'https://xxx.com/theme-default.css'</span><span class="token punctuation">,</span>
  <span class="token string">'red'</span><span class="token punctuation">:</span> <span class="token string">'https://xxx.com/theme-red.css'</span><span class="token punctuation">,</span>
  <span class="token string">'dark'</span><span class="token punctuation">:</span> <span class="token string">'https://xxx.com/theme-dark.css'</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">getThemeForUser</span> <span class="token operator">=</span> user <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token comment">// TODO</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>在编写<code class="gatsby-code-text">getThemeForUser</code>函数之前，我们先考虑一下问题：</p>
<ul>
<li>用户可能根本没有选择主题，而是使用的默认主题，<code class="gatsby-code-text">infos</code>对象中<code class="gatsby-code-text">theme</code>的value可能为null/undefined</li>
<li>user本身也可能为null，用户还没有登陆</li>
<li>数据异常，给出的主题色，可能不在<code class="gatsby-code-text">THEME_CSS_URLS</code>中   </li>
</ul>
<p>那么现在我们不得不处理很多个null/undefined,我们尝试编写第一个版本的<code class="gatsby-code-text">getThemeForUser</code>函数：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">getThemeForUser</span> <span class="token operator">=</span> user <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 没有登录进来</span>
    <span class="token keyword">return</span> <span class="token constant">THEME_CSS_URLS</span><span class="token punctuation">[</span><span class="token string">'default'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 返回默认主题</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span>infos<span class="token punctuation">.</span>theme <span class="token operator">&amp;&amp;</span> user<span class="token punctuation">.</span>infos<span class="token punctuation">.</span>theme <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">THEME_CSS_URLS</span><span class="token punctuation">[</span>user<span class="token punctuation">.</span>infos<span class="token punctuation">.</span>theme<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 如果存在主题</span>
      <span class="token keyword">return</span> <span class="token constant">THEME_CSS_URLS</span><span class="token punctuation">[</span>user<span class="token punctuation">.</span>infos<span class="token punctuation">.</span>theme<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token constant">THEME_CSS_URLS</span><span class="token punctuation">[</span><span class="token string">'default'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token constant">THEME_CSS_URLS</span><span class="token punctuation">[</span><span class="token string">'default'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">getThemeForUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// => 'https://xxx.com/theme-red.css'</span></code></pre>
      </div>
<blockquote>
<p>类似这样的代码在前端项目中，随处可见；有人认为很多的if判断增强了JavaScript代码的健壮性，但是反过来说，也可以认为这是一段简单的代码，打上各种补丁之后，终于可以正常运转了(我不认为这是让代码更健壮的方案，反而更像是一段温室中的代码)</p>
</blockquote>
<p>再举一个更普遍的例子：很多时候服务端接口文档，明确写了返回值为<code class="gatsby-code-text">Array</code>类型，但是没有值的时候，会直接给一个<code class="gatsby-code-text">null</code>而不是一个<code class="gatsby-code-text">empty Array</code>，这个时候客户端如果不做校验，直接作为<code class="gatsby-code-text">Array</code>类型来处理，<code class="gatsby-code-text">Uncaught TypeError</code>的错误是不可避免的；或者某个嵌套的JSON结构中，不知道哪一层就会出现<code class="gatsby-code-text">null</code>，我们总不能一直作出这样的判断吧<code class="gatsby-code-text">if(response &amp;&amp; response.a &amp;&amp; response.a.b ...)</code>!</p>
<p>为此经常这段代码简直就是<strong>薛定谔的猫</strong>，根据数据库数据的不同返回的结构完全不可预知，客户端只有在拿到数据的那一刻，才能确定下来！</p>
<p>现在我们面临的问题就是我们无法提前预知到底什么时候会出现<code class="gatsby-code-text">null/undefined</code>，如果出现的情况下，我们又该如何优雅而准确的处理<code class="gatsby-code-text">null/undefined</code>的问题！</p>
<p>为此薛定谔的Maybe出场的时候到了，来看一看另一个Box：<strong>Maybe</strong></p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Just</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Just</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  fold<span class="token punctuation">:</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
  getOrElse<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> x<span class="token punctuation">,</span>
  inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Maybe.Just(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">Nothing</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
  map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Nothing</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
  fold<span class="token punctuation">:</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
  getOrElse<span class="token punctuation">:</span> v <span class="token operator">=></span> v<span class="token punctuation">,</span>
  inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Maybe.Nothing`</span></span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> <span class="token function-variable function">Maybe</span> <span class="token operator">=</span> x <span class="token operator">=></span>
  x <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token function">Just</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">Nothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>Maybe的实现会把类型分为两类，一类是非空值，另一类是空值，所以经常会看到<code class="gatsby-code-text">Some(x)/None</code>或者<code class="gatsby-code-text">Just(x)/Nothing</code>这样的实现。</p>
<blockquote>
<p>Java8 和 scale中分别成为<code class="gatsby-code-text">Optional</code>和<code class="gatsby-code-text">Option</code>,他们将Just和Nothing称为Some和None,本质上并没有什么区别</p>
</blockquote>
<p>一般来说Maybe会提供一个<code class="gatsby-code-text">getOrElse</code>函数，用来做出获取到值(Just)则给出正确的值，如果没有取到则提供一个默认值,Nothing会把传进来的otherValue作为回退方案。</p>
<p>下面看一下Maybe的基本用法：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token constant">R</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'ramda'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> match <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>match<span class="token punctuation">;</span>

<span class="token function">Maybe</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/o/ig</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// => Maybe.Just(o,o)</span>
<span class="token function">Maybe</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/a/ig</span><span class="token punctuation">)</span>  <span class="token comment">// => Maybe.Nothing</span></code></pre>
      </div>
<blockquote>
<p>这里引入了<a href="https://github.com/ramda/ramda">Ramda.js</a>,提供了很多函数式风格的封装，避免了我们重复造轮子，但是他们一般不会提供函数式编程的核心的数学概念，比如：<code class="gatsby-code-text">Monad、functor、Foldable</code></p>
<p>实现了<a href="https://github.com/fantasyland/fantasy-land"><code class="gatsby-code-text">Fantasy-Land</code></a>规范的库,比如<a href="https://github.com/ramda/ramda-fantasy"><code class="gatsby-code-text">ramda-fantasy</code></a>,<a href="https://github.com/origamitower/folktale"><code class="gatsby-code-text">folktale</code></a>等,他们的实现比较工程化和严谨(适合正式的项目中引入)，但这里为了方便理解，我们选择继续扩展我们的<strong>Box</strong>,而不会引入这些类库</p>
</blockquote>
<p>现在尝试用<code class="gatsby-code-text">Maybe</code>来重写一下<code class="gatsby-code-text">getThemeForUser</code>函数：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token constant">R</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'ramda'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>path
<span class="token keyword">const</span> curry <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>curry

<span class="token keyword">const</span> <span class="token function-variable function">getThemeForUser</span> <span class="token operator">=</span> user <span class="token operator">=></span>
  <span class="token function">Maybe</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'infos'</span><span class="token punctuation">,</span> <span class="token string">'theme'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>maybeGetTheme<span class="token punctuation">,</span> maybeGetTheme<span class="token punctuation">)</span>


<span class="token keyword">const</span> maybeGetTheme <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span>
  <span class="token punctuation">(</span>urls<span class="token punctuation">,</span> themeName<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Maybe</span><span class="token punctuation">(</span>urls<span class="token punctuation">[</span>themeName<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token constant">THEME_CSS_URLS</span><span class="token punctuation">)</span>


<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">getThemeForUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span><span class="token constant">THEME_CSS_URLS</span><span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// => https://xxx.com/theme-red.css</span></code></pre>
      </div>
<blockquote>
<p><code class="gatsby-code-text">getThemeForUser</code>函数中最后为何使用<code class="gatsby-code-text">fold</code>而不是<code class="gatsby-code-text">map</code>呢？这是因为<code class="gatsby-code-text">maybeGetTheme</code>函数的入参是<code class="gatsby-code-text">themeName</code>,而<code class="gatsby-code-text">getThemeForUser</code>函数的返回值是<code class="gatsby-code-text">Maybe(themeName)</code>；</p>
<p>关于<code class="gatsby-code-text">fold</code>的两个一样的参数，在没有引入<code class="gatsby-code-text">chain</code>函数之前，我们暂时继续使用<code class="gatsby-code-text">flod</code>函数把<code class="gatsby-code-text">themeName</code>从<code class="gatsby-code-text">Maybe(themeName)</code>中释放出来,后面会和嵌套的<code class="gatsby-code-text">tryCatch</code>问题一起给出解决方案，现在先暂时放下这个问题</p>
<p>使用柯里化的<code class="gatsby-code-text">maybeGetTheme</code>函数，避免访问全局变量，并再次使用<code class="gatsby-code-text">Maybe</code>包装可能为空的数据，最后使用<code class="gatsby-code-text">getOrElse</code>取出Maybe中的值</p>
</blockquote>
<p>Maybe和Either中的<code class="gatsby-code-text">fromNullable</code>看上去非常类似，至少从代码上来看是这样的，但是现在必须要说明一点的是：Either更过的时候会被用来处理逻辑分支以及异常恢复，而Maybe则用来处理空值检查比较多，在使用理念上不同。</p>
<p>一个常见的用法是<code class="gatsby-code-text">xxx.getOrElse(throw new Error(&#39;Fail&#39;))</code>将结果是一个Nothing的Maybe转回一个异常，一般的经验法则则是在没有合理的方案能捕获异常时将其抛出；如果异常是一种可恢复的错误，使用Either会更加灵活</p>
<p>引入<code class="gatsby-code-text">Maybe</code>可能会造成一些不适，熟悉Scala的用户应该知道<code class="gatsby-code-text">Option</code>，或者Java中的<code class="gatsby-code-text">Optional</code>,是完全类似的概念；Scale中被迫在任何情况下都进行空值检查，的确让人头疼不已。随着时间的推移，空值检查会成为第二本能，说不定你还会感激它提供的安全性呢。不管怎么说，空值检查大多数时候都能防止在代码逻辑上偷工减料，让我们脱离危险。</p>
<h3 id="甩锅侠io"><a href="#%E7%94%A9%E9%94%85%E4%BE%A0io" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>甩锅侠IO</h3>
<h4 id="保持纯与副作用"><a href="#%E4%BF%9D%E6%8C%81%E7%BA%AF%E4%B8%8E%E5%89%AF%E4%BD%9C%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>保持纯与副作用</h4>
<p>我们知道函数式编程的理念中，函数要保持“纯”的概念，即不能修改外部的变量，仅仅依赖于函数入参；也不能产生任何与以上可观察的副作用或输出，比如典型的读写操作。从代码编写者的角度来看，如果一段程序运行之后没有可观察到的作用，那他到底运行了没有？或者运行之后有没有实现代码的目的？有可能它只是浪费了几个CPU周期之后就去睡大觉了！！！</p>
<p>从JavaScript语言的诞生之初就不可避免地需要能够不断变化的，共享的，有状态的DOM互相作用；如果无法输入输出任何数据，那么数据库有什么用处呢？如果无法从网络请求信息，我们的页面又该如何展示？没有<code class="gatsby-code-text">side effect</code>我们几乎寸步难行。上述的任何一个操作，都会产生副作用，违反引用透明性，我们似乎陷入了两难的境地！</p>
<blockquote>
<p>世間安得雙全法，不負如來不負卿</p>
</blockquote>
<p><strong>如何在<code class="gatsby-code-text">keep pure</code>的前提下，又能妥善的处理<code class="gatsby-code-text">side effect</code>呢？</strong></p>
<p>答案是用数学的思维：<strong>作弊</strong>！</p>
<ul>
<li><strong>Dependency injection(依赖注入)</strong>：把函数中不纯的部分，踢出去，作为参数传递进来</li>
<li><strong>IO Functor/</strong>:把产生<code class="gatsby-code-text">side effect</code>的部分包裹起来,带着这个保护壳参与运算，直到需要结果时再打开运行</li>
</ul>
<h4 id="dependency-injection"><a href="#dependency-injection" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dependency injection</h4>
<p>依赖注入式我们处理副作用的第一种方法，我们把代码中任何不纯的部分从函数中剔除，然后我们将他们作为传递进来，看一段代码：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">logSomething</span> <span class="token operator">=</span> something <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> dt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toISOString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dt<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>something<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> something<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p><code class="gatsby-code-text">logSomething</code>函数有两个不纯的因素：首先创建了一个动态的Date,然后记录到console！因此不仅执行了IO,而且每一次执行的结果也都不一样。那么如何将这个函数变得pure呢？通过依赖注入我们可以把不纯的部分作为参数，所以现在函数应该被修改为接受三个参数的函数：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">logSomething</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> cnsl<span class="token punctuation">,</span> something<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> dt <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token function">toISOString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> cnsl<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dt<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>something<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>如此这般logSomething函数就可以做到相同的输入，对应相同的输出了：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> something <span class="token operator">=</span> <span class="token string">"idiot !"</span>
<span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">logSomething</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> console<span class="token punctuation">,</span> something<span class="token punctuation">)</span></code></pre>
      </div>
<p>看到这里，你可能会想，这简直蠢爆了！就像在假装无知的说：“我不知道调用cnsl对象上的log会执行IO,只是其他人把它传给了我！”</p>
<p>尽管如此，它并不是一个单纯的傻瓜，至少这种思想可以延伸出来一个思路： </p>
<ul>
<li><strong>把不纯的部分剥离出来,让不纯的代码远离核心的logSomething函数</strong></li>
<li><strong>缩小了不确定性的范围，目前看起来只有log函数不纯</strong></li>
<li><strong>副作用集中管理，如果反复的缩小不确定的范围，我们甚至可以把不纯的代码推到代码的边缘，保证核心的pure和referential transparency</strong></li>
</ul>
<p>缺点在于：</p>
<ul>
<li>会导致方法签名过长，logSomething从一个参数变成了三个参数</li>
<li>传参的链路过长，可能导致多个函数在传递一长串的参数</li>
</ul>
<h4 id="io-functor"><a href="#io-functor" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO Functor</h4>
<p>现在我们来看看另外一种解决思路：IO Functor。在开始之前，我们先回顾一下JavaScript中的函数：由于函数的一等性和高阶性，JavaScript函数具有<strong>值的行为</strong>，也就是说，函数就是一个基于输入的切尚未求值的不可变的值，或者可以认为一个函数本身就是一个等待计算的惰性的值。</p>
<p>回想一下，我们前面一篇中说的，Box理念，既然函数只是<strong>惰性的值</strong>，我们何不把函数也包裹进Box中，等到需要的时候，在取出来！看代码：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">LazyBox</span> <span class="token operator">=</span> g <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
	map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">LazyBox</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	fold<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>
      </div>
<blockquote>
<p><code class="gatsby-code-text">map: f =&gt; LazyBox(() =&gt; f(g()))</code>，也可以使用<code class="gatsby-code-text">const compose = (...fns) =&gt; (...args) =&gt; fns.reduceRight((res, fn) =&gt; [fn.call(null, ...res)], args)[0]</code>和<code class="gatsby-code-text">map: f =&gt; LazyBox(compose(f, g))</code>的结合，并且更为合理;但是此处为了保持便于理解和代码简洁，没有采用</p>
</blockquote>
<p>注意观察，我们没有调用fold函数，解封其中的值之前,map函数所做的一直都是在组合函数，函数并没有被实际的调用:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">nextChartFromNumberString</span> <span class="token operator">=</span> str <span class="token operator">=></span>
	<span class="token function">LazyBox</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> str<span class="token punctuation">)</span>
		<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hahaha'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>r <span class="token operator">=></span> <span class="token function">parseInt</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">=></span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
		<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">=></span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">nextChartFromNumberString</span><span class="token punctuation">(</span><span class="token string">' 64'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>  <span class="token comment">// => { map: [Function: map], fold: [Function: fold] },</span>
<span class="token comment">// 而并没有打印出'hahaha' </span></code></pre>
      </div>
<blockquote>
<p>这一特性有点类似递归，在未满足终止条件之前(没用调用fold之前)，递归调用会在栈中不断的堆叠，直到满足终止条件(调用fold函数)，才真正的开始计算</p>
<p>同样类似与递归，可能会出现Maximum call stack size exceeded的错误</p>
<p>IO也和Rxjs中的<code class="gatsby-code-text">Observable</code>有很多相似之处，两者都是惰性的，在调用<code class="gatsby-code-text">subscribe</code>之前<code class="gatsby-code-text">Observable</code>也不会执行，在调用subscribe之后</p>
</blockquote>
<p>再看一个读取文件的例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">readFile</span> <span class="token operator">=</span> <span class="token punctuation">(</span>filename<span class="token punctuation">,</span> enc<span class="token punctuation">)</span> <span class="token operator">=></span>
	fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> enc<span class="token punctuation">)</span>


<span class="token keyword">const</span> content <span class="token operator">=</span> <span class="token function">LazyBox</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'config.json'</span><span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>str <span class="token operator">=></span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/8/g</span><span class="token punctuation">,</span> <span class="token string">'6'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x<span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span>  <span class="token comment">// => {"post":6666}</span></code></pre>
      </div>
<p>在没有调用fold函数之前，我们的代码都是纯的；flod函数就像打开潘多拉魔盒的双手；通过LazyBox我们把可能会弄脏双手的代码扔给了最后的fold，甩锅成功！</p>
<p>可以看到，我们这里使用的是同步的读取文件的例子，现在我们解决了<code class="gatsby-code-text">side effect</code>的问题，但是异步呢？异步该如何解决呢？不要着急，等我们介绍完了monad之后，会给出解决方案</p>
<blockquote>
<p>看到这里，是不是想起来了React中的useEffect</p>
<p>诚然，副作用依然存在，并没有消除，但是可以通过类似的方式，让大部分的代码保持纯的特性，享受纯函数带来的引用透明的好处</p>
</blockquote>
<h3 id="关于functor的定律"><a href="#%E5%85%B3%E4%BA%8Efunctor%E7%9A%84%E5%AE%9A%E5%BE%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>关于Functor的定律</h3>
<ul>
<li>
<p>必须是无副作用的。若映射<code class="gatsby-code-text">identity</code>(<code class="gatsby-code-text">x =&gt; x</code>)函数可以获取上下文中相同的值，既可以证明Functor是无副作用的。
<code class="gatsby-code-text">Box(&#39;hello world&#39;).map(identity) // =&gt; Box(hello world)</code></p>
</li>
<li>
<p>必须是可组合的。这个属性的意思是多个map函数的组合，与分别map函数的结果是一样的</p>
</li>
</ul>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token constant">R</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'ramda'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> reverse <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>reverse
<span class="token keyword">const</span> toUpper <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>toUpper
<span class="token keyword">const</span> compose <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>compose

<span class="token function">Box</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>reverse<span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>toUpper<span class="token punctuation">)</span>  <span class="token comment">// => Box(DLROW OLLEH)</span>

<span class="token function">Box</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">compose</span><span class="token punctuation">(</span>toUpper<span class="token punctuation">,</span> reverse<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
      </div>
<h3 id="summary"><a href="#summary" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Summary</h3>
<p>关于Functor的介绍暂时告一段落，我们已经介绍了几个常用的Functor:<code class="gatsby-code-text">Either</code>、<code class="gatsby-code-text">Maybe</code>、<code class="gatsby-code-text">IO</code>等等，但是其实根据应用场景的不同，我们可以创造出无数个Functor，比如：<code class="gatsby-code-text">tree</code>、<code class="gatsby-code-text">list</code>、<code class="gatsby-code-text">map</code>等等；</p>
<p>并且介绍了如果在保持pure的同时，处理side effect的两个方案：<code class="gatsby-code-text">Dependency injection</code>与<code class="gatsby-code-text">Lazy Function</code></p>
<p>同时记住我们抛出的几个尚未解决的问题？</p>
<ul>
<li>如何解决嵌套的try-catch</li>
<li>异步函数的组合</li>
<li>chain函数又是什么</li>
</ul>
<p>下面几节，将会解决这几个问题！</p>]]></description><link>https://reactjs.org/blog/2020/01/30/薛定谔的Maybe.html</link><guid isPermaLink="false">https://reactjs.org/blog/2020/01/30/薛定谔的Maybe.html</guid><pubDate>Wed, 29 Jan 2020 16:00:00 GMT</pubDate></item></channel></rss>