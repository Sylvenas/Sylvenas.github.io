<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Little Forest]]></title><description><![CDATA[A JavaScript library for building user interfaces]]></description><link>https://reactjs.org</link><generator>RSS for Node</generator><lastBuildDate>Mon, 03 Jun 2019 11:25:20 GMT</lastBuildDate><item><title><![CDATA[移动端适配方案rem & vh、vw]]></title><description><![CDATA[<h3 id="rem布局"><a href="#rem%E5%B8%83%E5%B1%80" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>rem布局</h3>
<h4 id="lib-flexible"><a href="#lib-flexible" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>lib-flexible</h4>
<p>假设设计MM给我们的设计稿尺寸为<code class="gatsby-code-text">750 x 1340</code>，那么我们前端拿到设计稿之后要如何动手开始开发呢？经过上面的介绍了移动端开发的基本概念之后，应该有了一些基本的思路，我们可以使用js动态计算rem的方案来实现。</p>
<p>rem是根据html节点的font-size来做计算的</p>
<p>举个例子：假如html元素的font-size为 <code class="gatsby-code-text">Npx</code>,一个元素的宽度设定为<code class="gatsby-code-text">2rem</code>;则该元素的实际宽度为：<code class="gatsby-code-text">2 * N px</code>；</p>
<p>换句话说px与rem的一定是成正比关系的。</p>
<p>那么既然设计MM给我们的设计稿尺寸为<code class="gatsby-code-text">750 x 1340</code>，那么我们完全可以把屏幕的布局视口平均分为750份；设计稿中的某个元的宽度直接按照，占了750份中的多少份来计算就可以了。</p>
<p>举例：
iPhone6的布局视口宽度为<code class="gatsby-code-text">document.documentElement.clientWidth = 375px</code>分为750份，则每份的宽度为<code class="gatsby-code-text">375px/750 = 0.5px</code>;并把<code class="gatsby-code-text">0.5px</code>设置为html元素的<code class="gatsby-code-text">font-size</code>;</p>
<p>现在有一个元素的宽度为<code class="gatsby-code-text">20px</code>,则只需要把元素的宽度用CSS编写为<code class="gatsby-code-text">20rem</code>即可！</p>
<p>因为<code class="gatsby-code-text">20px</code>，相对于平均分成<code class="gatsby-code-text">750</code>份之后,确实是只占了<code class="gatsby-code-text">20</code>份，每份是<code class="gatsby-code-text">0.5rem</code>。</p>
<p><strong>但是我们这样做了之后就会发现有问题啊，为何结果没有达到我们的预期呢？至少从数学计算的角度来说，我们的逻辑没问题！</strong></p>
<p>那么问题出在哪里呢？</p>
<p><strong>是浏览器在作妖！chrome的浏览器所允许的最小<code class="gatsby-code-text">font-size</code>为<code class="gatsby-code-text">12px</code>,所以我们设置了html元素的<code class="gatsby-code-text">font-size=.5px</code>是被忽略的，并且被重置为了<code class="gatsby-code-text">12px</code></strong></p>
<p>那么我们再次运用小学数学知识，只要把html元素的<code class="gatsby-code-text">font-size</code>等比例扩大100倍，然后元素的大小在缩小100倍不就可以解决这个问题啦！</p>
<p>所以我们把html元素的<code class="gatsby-code-text">font-size = 50px</code>,然后元素的宽度设定为<code class="gatsby-code-text">.2rem</code>，这样在计算之后不就没问题啦！</p>
<p>现在总结一下计算公式：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// html元素的font-size大小，单位：px</span>
<span class="token keyword">const</span> htmlFontSize <span class="token operator">=</span> <span class="token punctuation">(</span>document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientWidth <span class="token operator">/</span> <span class="token number">750</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">;</span>

<span class="token comment">// 普通元素宽度，单位：rem</span>
<span class="token keyword">const</span> eleWidth <span class="token operator">=</span> <span class="token punctuation">(</span>设计稿宽度<span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token number">100</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>如果上面的换算觉得还是麻烦，可以借助<code class="gatsby-code-text">postCss</code>的插件<code class="gatsby-code-text">px2rem</code>来帮助我们完成换算，我们在代码中直接写px就可以了！</p>
<p>其实这也是阿里巴巴<code class="gatsby-code-text">lib-flexible</code>的大概实现原理！</p>
<h4 id="rem的缺陷"><a href="#rem%E7%9A%84%E7%BC%BA%E9%99%B7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>rem的缺陷</h4>
<p>rem是弹性布局的一种实现方式，弹性布局可以算作响应式布局的一种，但响应式布局不是弹性布局，弹性布局强调等比缩放，100%还原；响应式布局强调不同屏幕要有不同的显示，比图媒体查询。</p>
<p>一般内容型的网站，都不太使用使用rem,因为大屏用户可以自己选择要更大的字体，还是更多的内容，一旦使用了rem，就剥夺了用户的自由；一些偏向App类型的，图标类的，图片类的，比如：淘宝，活动页面，比较适合使用rem,因为调大字体时并不能调大图片的大小。同时rem存在一下问题：</p>
<ul>
<li><strong>字体问题</strong> - 字体大小并不能使用rem,字体的大小和字体宽度并不成正比关系，这个关系完全取决于字体的作者。所以字体大小不能使用rem。</li>
<li><strong>PC浏览</strong> - 如果用户在PC段浏览页面怎么办？一般我们都会设置一个最大宽度，大于这个宽度的话，页面居中，两边留白，或者直接跳PC页面</li>
</ul>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> clientWidth <span class="token operator">=</span> document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>clientWidth<span class="token punctuation">;</span>
clientWidth <span class="token operator">=</span> clientWidth <span class="token operator">&lt;</span> <span class="token number">780</span> <span class="token operator">?</span> clientWidth <span class="token punctuation">:</span> <span class="token number">780</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>documentElement<span class="token punctuation">.</span>style<span class="token punctuation">.</span>fontSize <span class="token operator">=</span> clientWidth <span class="token operator">/</span> <span class="token number">100</span> <span class="token operator">+</span> <span class="token string">'px'</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>设置body的宽度为100rem，并水平居中:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-css"><code class="gatsby-code-css"><span class="token selector">body</span> <span class="token punctuation">{</span>
    <span class="token property">margin</span><span class="token punctuation">:</span> auto<span class="token punctuation">;</span>
    <span class="token property">width</span><span class="token punctuation">:</span> 100rem
<span class="token punctuation">}</span></code></pre>
      </div>
<h3 id="vh、vw方案"><a href="#vh%E3%80%81vw%E6%96%B9%E6%A1%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>vh、vw方案</h3>
<p>vh、vw方案即将视觉视口宽度<code class="gatsby-code-text">window.innerWidth</code>和视觉视口宽度<code class="gatsby-code-text">window.innerHeight</code>等分为100份。</p>
<p>本质上来说，<code class="gatsby-code-text">flexible</code>方案就是模仿这种方案，随着浏览器兼容性的进步，<code class="gatsby-code-text">vh、vw</code>方案已经可以直接用了。</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/vw-vh-5379a182408150a2dce7cf759fa14c00-1d83a.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 48.36309523809524%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAABYlAAAWJQFJUiTwAAABcklEQVQoz31Sf2uCUBT1+3+GbcQgIvqr0SA3ptCvRRCUTslW1mowjcraKrXUs/feTH0Fe3C5713PPffcexXCMITruszonZ4oijhP45cWBAHzFJMaIHQ6HeTzeRQKBTQaDQ6QJf3vZPECJdF1HaZpQpIk2ItFAjwrVtU31OsN5nu9Pvp9BbVaHYYxxOkUcMQCJTsfVVVhWRY8z8PxeEyq5nL3aDZbrM3NZoP9fo9K5RHSiwzHoe8Dy2EKNU1LEimhbdtYLlfY7fZJodubO2iazrVZrYrEnuAeXKxWa2y333+E3W6XBFZsKe12mym8bLlcfoAoPmM6/cBgYGBovDOFrdYrUbzlW5ZlGcViEaVSiSSJ2P3srgbt+z4mkynGI5ORjkZjzOefRIR3vZTZbAZFUVi7pjnhql1umc7K+rLJfE8pDjEufgvnQa9J277nZyrGZFGqICRG8dyvlflO7wIlOJDKztpBFMYA5lNwGkNiCTbi47+f4vfotZzyxAAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="vw-vh"
        title=""
        src="/static/vw-vh-5379a182408150a2dce7cf759fa14c00-acf85.png"
        srcset="/static/vw-vh-5379a182408150a2dce7cf759fa14c00-c1418.png 210w,
/static/vw-vh-5379a182408150a2dce7cf759fa14c00-5d5d8.png 420w,
/static/vw-vh-5379a182408150a2dce7cf759fa14c00-acf85.png 840w,
/static/vw-vh-5379a182408150a2dce7cf759fa14c00-de0cd.png 1260w,
/static/vw-vh-5379a182408150a2dce7cf759fa14c00-1d83a.png 1344w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>举例来说：视觉视口为375px,那么<code class="gatsby-code-text">1vw = 3.75px</code>,这时UI给定一个元素的宽为<code class="gatsby-code-text">20px</code>(设备独立像素)，那么我们只要只需要把它设置为<code class="gatsby-code-text">20 / 3.75 = 5.3333vw</code>。</p>
<p>这里的比例关系我们也不用自己换算，我们可以使用<code class="gatsby-code-text">PostCSS</code>的<code class="gatsby-code-text">postcss-px-viewport</code>插件帮助我们完成这个过程。写代码时，我们只需要根据UI给的设计图写px单位即可.</p>
<p>没有任何一种方案是完美的，vw,vh也存在一下缺陷：</p>
<ul>
<li><code class="gatsby-code-text">px</code>转换成vw不一定能完全整除，因此有一定的像素差。</li>
<li>当容器使用vw,margin使用px时，很容易造成整体宽度超过100vw,从而影响布局效果。当然我们也是可以避免的，比如使用<code class="gatsby-code-text">padding</code>代替<code class="gatsby-code-text">margin</code>，结合<code class="gatsby-code-text">calc</code>函数使用</li>
<li>兼容性
部分机型不支持vw,vh，可以采用csspolyfill来进行降级处理，推荐<a href="https://github.com/rodneyrehm/viewport-units-buggyfill">viewport-units-buggyfill</a></li>
</ul>]]></description><link>https://reactjs.org/blog/2019/05/27/mobile-css.html</link><guid isPermaLink="false">https://reactjs.org/blog/2019/05/27/mobile-css.html</guid><pubDate>Sun, 26 May 2019 16:00:00 GMT</pubDate></item><item><title><![CDATA[移动端开发基础知识]]></title><description><![CDATA[<h3 id="单位"><a href="#%E5%8D%95%E4%BD%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>单位</h3>
<h4 id="英寸"><a href="#%E8%8B%B1%E5%AF%B8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>英寸</h4>
<p>一般用英寸描述屏幕的物理大小，如电脑显示器的<code class="gatsby-code-text">13</code>、<code class="gatsby-code-text">15</code>,手机显示器的<code class="gatsby-code-text">4.8</code>,<code class="gatsby-code-text">5.7</code>等使用的单位都是英寸。</p>
<p>需要注意的是英寸都是指屏幕对角线的长度</p>
<blockquote>
<p>英寸(inch,缩写为in)在荷兰语中本意是指大拇指，一英寸就是普通人拇指指甲底部的宽度。</p>
</blockquote>
<p>英寸和厘米的换算规则为：<code class="gatsby-code-text">1英寸 = 2.54厘米</code></p>
<h4 id="屏幕比例"><a href="#%E5%B1%8F%E5%B9%95%E6%AF%94%E4%BE%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>屏幕比例</h4>
<p>只确定了对角线的长度(屏幕英寸)，2个边的长度还是无法确定，所以有了<code class="gatsby-code-text">4:3</code>，<code class="gatsby-code-text">16:9</code>这种屏幕宽高比，这样就可以计算出屏幕的两个边长了</p>
<h4 id="分辨率"><a href="#%E5%88%86%E8%BE%A8%E7%8E%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>分辨率</h4>
<h5 id="像素"><a href="#%E5%83%8F%E7%B4%A0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>像素</h5>
<p>像素即一个小方块，具有特定的位置和颜色。</p>
<p>图片、电子屏幕(手机、电脑)就是由无数个具有特定颜色和特定位置的小方块拼接而成。
像素可以作为图片或者电子屏幕的最小组成单位。
下面我们使用<code class="gatsby-code-text">sketch</code>打开一张图片：</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/pixel-ec09ddc015613e5fde67e410ac04ea5f-50506.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 78.01778907242695%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAADjklEQVQ4y22UbWyTVRTH6we/mGjEhMSQLC77oBPdQBQlilMHDIH5hrIZWBE3zBBjdEy3+S6TDyYwYEC2GQfBVyqkjLE3cVniPoDIGhyLItWt3Vjf+7R92udp61rKz3sf6MIyzpOTe899zvnf/7nnnmuKRCKosRjhmI4ejxPX4+hCw+EwISWEqgbx+p0EFBdK2IeihlGiYl0LENY1YrpOXMRpcZ2IsE2KEiQmAGOaTlSMWkwjmUySAa4IvWqMaaHyyxjrWlL4amFBQhCJRomoUcJCFVXFZHde5t9RB2OjozidTlKpFJmrGXqOWtjXUMeBuvfYX7uN/e/X0izsH79qRRdAUsbHx/F6fSJDjXBEFcAxTIGggtfnw+PxGCrFevggVSWFbFiSx6MmE4/fegsPi3HT8vupfmERh/Y1GX4OhwNFUYgKZvLoolH1WsohsRgKhVCCQVLpDAf3fMSObUW8Vb6AhbffyYLb7uChOXOoLiukseZJWptqRRYYGU26XARFnFSXmJuyhtRQSOwm6DfWm6lYOY+Nq3IoWXg3z+TPpXTxPMzCfqVoLjWbV+Jxu5mcnJzOLBAI4PN6JUPFoC0XZHEujoywfvUjvF6aw9Z1eVS/nMvWsjw+fOMB6ivnY342h7VP3UvfcSseATAxMWFkJ+MlqWlAv99PPJlgoKubdcWFNNUvoe2LZRz4bBm765/A2l7JwIkG9n5cRPmKfFoat+MURRkeHjYYZknNAEz8l6T/eAfm1Ys51dHM+dPf0PldDUdaKzjd34zTPsgvJ9upeukxDn3SYMTY7XbcIn3JbgagNFRxp8bFFdq8dimW9s8Zs//Ob78epvunBkb/6sXtPE/fsZ28WbaIU9ZjRiNIUBmfrcM0YJallCPffk3Tp6W4x/q4cO4Heo/WEfQOkYpfovP7t2lp+sDwCwavnduNGDcF/Nv2BxVPz+efEQu2wRYsrWYCrrNMJS7SuGEp1j17DT+fzzuD3SyGMu0rokt0MX8xN4e2XVsYGviSth2r8Dn6uWCz8No9d3Gp52cD0C8a4sb4WQzlDrKPpdS8Ws7GNQX0du+keVcV52xWWndvYU1BLv7LLsMncP38ZgBm70+2SolEwnDu7+niueJ83n2+hE0F97F9RTHrlz/IO5Vlxv90Oj3r/AxA+fSoohc1TTOeoampKbJiO3uGMx2dDJ3o5M+TXQx2d+G/3u/yEbkZ4P+k1ho6lRRm3gAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="像素"
        title=""
        src="/static/pixel-ec09ddc015613e5fde67e410ac04ea5f-acf85.png"
        srcset="/static/pixel-ec09ddc015613e5fde67e410ac04ea5f-c1418.png 210w,
/static/pixel-ec09ddc015613e5fde67e410ac04ea5f-5d5d8.png 420w,
/static/pixel-ec09ddc015613e5fde67e410ac04ea5f-acf85.png 840w,
/static/pixel-ec09ddc015613e5fde67e410ac04ea5f-de0cd.png 1260w,
/static/pixel-ec09ddc015613e5fde67e410ac04ea5f-50506.png 1574w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>我们通常所说的分辨率有两种，一种屏幕分辨率一种是图像分辨率</p>
<h5 id="屏幕分辨率"><a href="#%E5%B1%8F%E5%B9%95%E5%88%86%E8%BE%A8%E7%8E%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>屏幕分辨率</h5>
<p>屏幕分辨率是指一个屏幕具体有多少个像素点组成。</p>
<p>下面是<code class="gatsby-code-text">apple</code>的官网对手机分辨率的描述：</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/pixel-big-7e1c3e7fc16bb776b25bd1889425e08f-0df46.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 77.96178343949045%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAADuElEQVQ4y2WU+09bdRjG+x9pjDdgcXNsy2hpax2CYYOKsMoKLaUDeqOsXFyUxVtmYmKyLCH+YnQx0xiXLTLRIQQGdFwGNINybaH3KwJmfnxPJzrmD296zsl5P33e93m+R5VMJomn0oQTGTK5HPt7f/L48V/s7e+z88cuu3s7pLNx0rk4mZ0U+d090jsZUvltUrk82VyWfD5PLp+T+yyqREJezmRIpjOF36nxcYYGf+a3obuMDg8x/WCYyYm7jI/f5v7YbQILYwQWR1gM3COeTJCUnpT0JkVUPJVCNfFglolJP/6pKfx+P25bE9rXi9CcOIrNXMUlRxVOiw63VYu3Rc3A1fe49a2bX37s51FgnnB4m1hcppSKxRKo1jc2WVlZIRhUKoinzcbb6uOUHSuho80owAqcNh0eq46eNj1f9L/DN9dbGPzhQ1E6x9b2NltbYbbCYYGHUcXjcZSxlV3GolG8HXYqTx9Df7QYr7Mer/0NXALzWDT02HX0e9/ks94zXL9q4uGcn42NEKFQiGgsJtcbqKICUSomD7bl3zzOVgylJVSfOk7vJRMeRZ1FS1eLBq/tLfp7LtDnqeGKz8jC/AzBlVUCgQDLy0GpZVQK6GlgZ4cNfclL1J/R0Ndtwt2ilb3q6LTr+fLTK8zcn2X03hTDv47IqFuFnrSYkReXFbf/B/S2tVD+ygtY6yp4v+tdHIrCVi3OCwbufD/Io4frzEwuiSERNjfDhVEjiby4LfFKp54BRiJ4LlpQv/wc7ZZaejuNOGTcy54KuuxGvhr4iTl/EP/4PHOza8xMzxYMVcCxeEK8SBwGRiJRXM2NaF59Hq/DRLfrLK4mDV22ctobTtPeZObG13cYG5nFPznHwsIiq6urREXIgRfPACM4TQ3oil/E5zbhkwy6mzU4zWXy/ATWc0fEGDM3vxtk9PdpNiVySt8B4zBQ4qPs0FZTg0Ei43Of/yfU5TiaygSsxtN8ijZjMe7GGm7euPUk1E8JUurf2Ch5DEtAzbVGDK8Vidt1orAaZ7NOSoGV0WlRc7lDR7ellM7mKoISE2VvB4xDChVgKBTGarZgOHkEa32VAM/htD4JtkugCtB3Uc/H3RVc+6iW4NIC8URS+iP/KVT2ppRyE5KdmBtMVOvV1GpP4nHUSgYNhbPsFHPcMrqvtZwPXDoGPm9kc3258FE4tMNsNls4dtlsjozkqK6yEsNpNVWlRXRYzuKxV+CS6Dib1AJUy4kpp69Dy7VPzjMvR29paZm1tTXJYLrA+RuJBdFXssIDWAAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="像素-图片放大"
        title=""
        src="/static/pixel-big-7e1c3e7fc16bb776b25bd1889425e08f-acf85.png"
        srcset="/static/pixel-big-7e1c3e7fc16bb776b25bd1889425e08f-c1418.png 210w,
/static/pixel-big-7e1c3e7fc16bb776b25bd1889425e08f-5d5d8.png 420w,
/static/pixel-big-7e1c3e7fc16bb776b25bd1889425e08f-acf85.png 840w,
/static/pixel-big-7e1c3e7fc16bb776b25bd1889425e08f-de0cd.png 1260w,
/static/pixel-big-7e1c3e7fc16bb776b25bd1889425e08f-0df46.png 1570w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p><code class="gatsby-code-text">iphone xs max</code>和<code class="gatsby-code-text">iphone SE</code>的分辨率分别为<code class="gatsby-code-text">2688 x 1242</code>和<code class="gatsby-code-text">1136 x 640</code>,这表示手机分别在垂直和水平方向上所具有的像素点数。</p>
<p>当然分辨率高不代表屏幕就清晰，屏幕的清晰程度还与尺寸有关。</p>
<blockquote>
<p>同尺寸下，自然分辨率越高屏幕越清晰</p>
</blockquote>
<h5 id="图像分辨率"><a href="#%E5%9B%BE%E5%83%8F%E5%88%86%E8%BE%A8%E7%8E%87" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>图像分辨率</h5>
<p>我们通常所说的<code class="gatsby-code-text">图片分辨率</code>实际上是指图片所含有的<code class="gatsby-code-text">像素数</code>,比如一张图片的分辨率为<code class="gatsby-code-text">800 x 400</code>。这表示图片分别在垂直和水平上所具有的像素点数为<code class="gatsby-code-text">800</code>和<code class="gatsby-code-text">400</code>。</p>
<p>统一尺寸的图片，分辨率越高，图片越清晰。</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/pixel-img-3da3d8f9cd1802210d6ba267df228b40-033cb.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 19.27710843373494%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAABMklEQVQY0x2Qu0pCAQBA/Q+n9mho9AeioQa3NpFaBYfIQZDC7CXmC9R7MS1T8YEPNDHDyBzUEGsSLQ0NUbsqLQ01ncztDIczHNn7cMxAmtIfjfn4nDCczGj2B7yNJHrSjHqrQ3so0RlPaLx2aY+ntAYjnjs9upOvhVtvd2jN/e+fX2TrRhdq+yWGaB6VO4xGCLElxLDF0iitfjbs1zjCcRQmkR1/imNvgBWjgD6Ww3gRZNkochBOo3EFSDaayFb3zGyaXGjnoTWDBeWhg20hguDzodCdoPZE8AgCS1oT+miOI4sN+a4Ze+IGw7kTuc6KL5lFtX9GqPqCTLgtEy7VyNcaXBVKxB+rBIplnNEkYrGCmLnDHozgvq/gzRawBGO4H57wpnLY4hk8/5zIcBpJL3b8AdSB73u9VYZ3AAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="图像分辨率"
        title=""
        src="/static/pixel-img-3da3d8f9cd1802210d6ba267df228b40-acf85.png"
        srcset="/static/pixel-img-3da3d8f9cd1802210d6ba267df228b40-c1418.png 210w,
/static/pixel-img-3da3d8f9cd1802210d6ba267df228b40-5d5d8.png 420w,
/static/pixel-img-3da3d8f9cd1802210d6ba267df228b40-acf85.png 840w,
/static/pixel-img-3da3d8f9cd1802210d6ba267df228b40-de0cd.png 1260w,
/static/pixel-img-3da3d8f9cd1802210d6ba267df228b40-033cb.png 1328w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<h5 id="ppi"><a href="#ppi" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>PPI</h5>
<p><code class="gatsby-code-text">PPI</code>(Pixel Per Inch):每英寸包括的像素数。</p>
<p><code class="gatsby-code-text">PPI</code>可以用于描述屏幕的清晰度以及一张图片的质量。</p>
<p>使用<code class="gatsby-code-text">PPI</code>描述图片时，<code class="gatsby-code-text">PPI</code>越高，图片质量越高，使用<code class="gatsby-code-text">PPI</code>描述屏时，<code class="gatsby-code-text">PPI</code>越高，屏幕越清晰。</p>
<p>在上面描述手机分辨率的图片中，我们可以看到：<code class="gatsby-code-text">iPhone XS Max</code> 和 <code class="gatsby-code-text">iPhone SE</code>的<code class="gatsby-code-text">PPI</code>的分辨率分别为458和326，这足以证明前者的屏幕更清晰。</p>
<p>由于手机尺寸为手机对角线的长度，我们通常使用如下的方法计算<code class="gatsby-code-text">PPI</code>：</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/ppi-calc-836564e5f2d512435e3e3010b514155f-cfc05.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 764px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 27.486910994764397%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAwklEQVQY03VQSQqEQAz0/68RD+JBvQiiuDxAENqbeHA5aLvXUIF2GHACRUIlXUm1dd83GMzrugrO88RxHNi2Dfu+YxxHzPP88Nd1SWaPM1rrR8Mygn3foyxLpGkKx3Hg+z6yLIPruui6TsA6CALYto0wDKXveR6mafoKsuCGqqpQ1zWapkEcxyLMBQQHh2FAkiSCKIpEjL08z+XiH0Fja1kWsUYbtE6+bVsURSGLaNPw5nt4zKvlf8HLlFKSzaO3MPwHL9J4fgdjBOEAAAAASUVORK5CYII='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="ppi计算方法"
        title=""
        src="/static/ppi-calc-836564e5f2d512435e3e3010b514155f-cfc05.png"
        srcset="/static/ppi-calc-836564e5f2d512435e3e3010b514155f-fb287.png 210w,
/static/ppi-calc-836564e5f2d512435e3e3010b514155f-e130e.png 420w,
/static/ppi-calc-836564e5f2d512435e3e3010b514155f-cfc05.png 764w"
        sizes="(max-width: 764px) 100vw, 764px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>iPhone6的<code class="gatsby-code-text">PPI</code>为</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/iPhone6-ppi-a3d33327ca7eed848713665016aff809-a17e5.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 454px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 32.59911894273127%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA/ElEQVQoz5VRyWqEUBD0/7/Hg4cBQXFQx4OjiHpRUEFxGUHct0q6ISEThJCCounl1avXT8An9n3HNE1YlgXzPDPHccQwDMx1Xb97FM/zpGMcf1OgRhzHeD6fsCwLjuNA13UYhoE8z5EkCVRV5ZppmtA07U3sJ1gwCAKkaQrP8yBJEkRRxO124wGqk1Pf97kuyzKqqnoTOY4D27YxCYLruuyEXEZRxJHyvu85lmWJoii4Tm6pTk/Psgxd10FRFDZCr3s8HhBerxfqukbTNMy2bUGuaYBIOYl+zRFpp5TT3m3bZqEwDHldAi5wv995BXTBfyFc/RTtg26/6v3FD2KQEFiC2PtpAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="iphone6-ppi"
        title=""
        src="/static/iPhone6-ppi-a3d33327ca7eed848713665016aff809-a17e5.png"
        srcset="/static/iPhone6-ppi-a3d33327ca7eed848713665016aff809-1df6e.png 210w,
/static/iPhone6-ppi-a3d33327ca7eed848713665016aff809-800bf.png 420w,
/static/iPhone6-ppi-a3d33327ca7eed848713665016aff809-a17e5.png 454w"
        sizes="(max-width: 454px) 100vw, 454px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>那它每英寸包含约<code class="gatsby-code-text">326</code>个物理像素点。</p>
<h5 id="dpi"><a href="#dpi" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>DPI</h5>
<p><code class="gatsby-code-text">DPI</code>(Dot Per Inch):即每英寸包括的点数。</p>
<p>这里的点是一个抽象的单位，它可以是屏幕像素点，图片像素点也可以是打印机的墨点。</p>
<p>平时你可能会看到使用<code class="gatsby-code-text">DPI</code>来描述图片和屏幕，这时的<code class="gatsby-code-text">DPI</code>应该和PPI是等价的。</p>
<blockquote>
<p><code class="gatsby-code-text">DPI</code>更多的时候是用来描述打印机，表示打印机每英寸可以打印的点数。这个和开发无关，不继续深入研究</p>
</blockquote>
<h3 id="设备独立像素"><a href="#%E8%AE%BE%E5%A4%87%E7%8B%AC%E7%AB%8B%E5%83%8F%E7%B4%A0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>设备独立像素</h3>
<p>实际上，上面我们描述的像素像素都是物理像素，即设备上真实的物理单元。</p>
<p>下面我们来看看设备独立像素究竟是如何产生的：</p>
<p>智能手机发展的速度非常之快，在几年之前，我们还用着分辨率非常低的手机，比如下面白色的手机，它的分辨率是<code class="gatsby-code-text">320 x 480</code>，我们可以在上面浏览正常的蚊子、图片等等。</p>
<p>但是，随着科技的发展，低分辨率的手机已经不能满足我们的需求了。很快，更高分辨率的屏幕诞生了，比如下面的黑色手机，它的分辨率是640 x 960,正好是白色手机的两倍。</p>
<p>理论上来说，在白色手机上相同大小的图片和文字，在黑色手机上会被压缩一倍，因为它的分辨率提高了一倍。但是如果真的这样下去，岂不是后面出现更高分辨率的手机，页面元素会变得越来越小吗？</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/iphone-retina-f55c8ec98ceafae3cdd029db0e98a823-4d295.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 83.73590982286635%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAARCAYAAADdRIy+AAAACXBIWXMAABYlAAAWJQFJUiTwAAACt0lEQVQ4y3WUy07bQBSG8z6oqI8AafsOQDdUdE1X9AHoCoq6oohLUcVdKHuQ2KC2ggCCNoGQAK0gQBLfHTu2Qxwuf+ecYAcTONLJyM7M53/Of2ZiEFGv1+G6Lmq1Gnzf59GyyrBtG3d3d5wUnudhbW0NKysrWF1d5UwkEvyO1lHEbm9voeu6AFicJyd/IUkyKhUHqqrBESPNoRgaGkIsFnsyx8cnGsDr62vIsswwTdNwenqOYlGBbTnQVFMo90LgwMBHtLe/REdHHPH4G8Q7X6Oz8xXa2l5gePhzU6GiKAJS5FQUVShUUCiUcHlZQtW7QhBTU9NiB//EjkyeQ1ku29jd/Y2FhcUmkJQRLJ/PI5PJIps9Es8NoPcAOD39nf8LPkipqjqSyW3Mzy9EFa6vryOdTuPnj1/Y2/2D5OY2dnb2cHXlh6ZMTX5joKJo4mNFXFwUWO3W1k4USKYQlEZN03mSphkolWR4bjVUODs7h/39DA4Pc0inDpBK7ePo6ASbm1tRoGEYwtUKtw6Z4Dgeb1XXy/wcxNzcPHK5Y66baVhiHbWW06qQgOQyQWkCpeO4wmUjAiSFpMgVqisVl7Nard0DF6NAamLHaYBIIS3SNLMFmMsesxFkDJWEVEYUUsEJSDVUVZULTkmLSiWlpYYPXSZjaN6TwEKhcJ/FsCUet83MzCwODrKipSScn19yyrKKjY0k1/dJIPVfE1iMAElF8I7qbFkVce7r3LthY9/c3PBWG9ulukj8VdoKjZ5XDftwdPQrxsbGsbS0zCZQLi8nMDLyBRMTk82zLEnSvcM2Q6jQZAyZYgsVwVnu7//w7OUwOPipAaQfgtHxM02TbxhSp+sG3zq+Xw8VZjKH6O19h+7uHvT0vOWxq6sbfX3vcXaWbwKDoHuRtlw2y3gcATQIv+aLY1lrmfMfSkurdZQFH50AAAAASUVORK5CYII='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="2x手机"
        title=""
        src="/static/iphone-retina-f55c8ec98ceafae3cdd029db0e98a823-acf85.png"
        srcset="/static/iphone-retina-f55c8ec98ceafae3cdd029db0e98a823-c1418.png 210w,
/static/iphone-retina-f55c8ec98ceafae3cdd029db0e98a823-5d5d8.png 420w,
/static/iphone-retina-f55c8ec98ceafae3cdd029db0e98a823-acf85.png 840w,
/static/iphone-retina-f55c8ec98ceafae3cdd029db0e98a823-4d295.png 1242w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>然而，事实并不是这样，我们现在使用的智能手机，不管分辨率多高，他们所展示的界面比例都是类似的。乔布斯在iPhone4的发布会上首次提出了Retina Display(视网膜屏幕)的概念，它正式解决了上面的问题，这也使它成为一款跨时代的手机。</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/apple-retina-2ad95e749c50edd51012ee561609d470-f916c.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 75.55110220440882%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAAD1ElEQVQ4y02Ta2xTdRjGT1e6XtauXe+39bat62BubusubU93YyvdwCxzgaG4BJQQI5tBgxqR+AFJwBgTGZCIUaKCGk1MNJr4SRKDLvhJxMQIZtCy4WQRlojxgx/8+fYsIX54857///+c53n+5z2PMjc3RzqdRs2r5HI5rdR8nrzU/7uqqvcrn81ppWayqH0Z+rMqXW0Psu+JvSiDg4MoioLZZKLaUI3BYEAn68re/a7TaVVV6bKukjIoOjZI12vPVRqur7sHpVAo4HI6CYdChIJB6kNhAn4/4WAYv9ePz+PDbrNjs9qwWqzYaqSba7AZa6g1rZfdYtOEhvJibnR0FHutHWuNHNpsOB1O6hwOHHY7RoNRCP0kYg1ar6zdTjdBbxBvnQdPnRuPwyV4l+ZwMDdQIRzBJQfhYFTcRYlF4njdXpJNzTQ1NLGppZU6u1MTMlWbNNdxwYT8cqOA3MYbwCWEPpeP8eI4ypbCFlHwyrUqL7mFzI9bBC5cvMgv5RJffn2BDz/7go1CrNfp8fsCROujBHxBTTgoxC2pVqZ2Ps6T+w+gjBW24XVGRCkmoIgAIvjdIb5ZuMTqX/e4unSL0t17dKYz8p30ggkRiybwiTOP08Pw6BjHTr3HoWNnhPAZlK3F7QQ8zQJopjHRwbffLbBw6Xt+/nWR68srXLm6yI+LN+no6hWHBhEOUV8fF+EwGXWIIyfe4dW3PuGl195edzixbQ/hQBq3I0m2d4w7d9f4+99/WFpd5Vp5iSuLN7hSWqa7R8WoNws2RiSaJNfdy+sH93Py/OccmX+fF4+fYfbp51C2T+4jHsvQ1Vlk8/AUi+UyK2t/cGPlN64tLXH5ujgU4r7MMFajUwbRQLpnkMJIkd0zM5z66CuOnjzHkVMf8OzzL6NM75gl1TJCZ1eR9vbN4myF1T/XKP0uhMvL/FCqEN4kmy/gqK0MIsLh4/NMPTpDbmOSN899ytHT59kz9wKzB8ThrscOoQ7tozszIxGboXz7Nrfu3qEk/drKbS6XyvwkgxnYPInb1SQDaePgK29w4uy77N25nfmzH5Pa1LH+Hw7Ij71792FisUGaU0N0pKfJ9oty/y4yAzvozhZkPUH/6CM0JlXi0T4SiR7aukYY2/ow01OTtHepGPQbNMJ8Lo8yvvUhFNkw15hJPlBgU+8eGtsnsDh86PRVWK0uEvEsqdQwjQ19EkGnJMZCUyJJczyKQSZfieQ6YT9KcWwcXZVsSvwikUbUkadobB2ixmLGYjJrufXZHaQSbdQ5A1Rv0GORxNRKVM0SRUu1YIwWjXBACP8DKqwYPcS64coAAAAASUVORK5CYII='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="apple-retina"
        title=""
        src="/static/apple-retina-2ad95e749c50edd51012ee561609d470-acf85.png"
        srcset="/static/apple-retina-2ad95e749c50edd51012ee561609d470-c1418.png 210w,
/static/apple-retina-2ad95e749c50edd51012ee561609d470-5d5d8.png 420w,
/static/apple-retina-2ad95e749c50edd51012ee561609d470-acf85.png 840w,
/static/apple-retina-2ad95e749c50edd51012ee561609d470-f916c.png 998w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>在iPhone4使用的视网膜屏幕中，把两个像素当成1个像素使用，这样让屏幕看起来更精致，同时能保持元素的大小不变。</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/retina-ex-c0e2a89637045cf5de0738b1fd5c9673-5176d.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 35.74660633484163%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAB+0lEQVQozz2O20uTARiHP3XRVKRpgWw4ne1Q2xDLlTFaOkOdrUUyx0yiFqg334WUlIcwKkzDSNrWtm+HEknC0tQ2O2BYBCuFJMggvFpd9Ic8rY/o4uH3vLw/Xl4hl8sRlyQSiYRMMvmXJPF4XM5wOEw2m2Vra0v2VCr1r5eUU5Ji+a5EMBhke3sbYXllBUEQUCqLUSh2UVBQ9H8uLSmTXRRF7kxOyb67RIWydA+FCiXK4jIq9qmp1NTIu1AogvAynaHWoKfN7eaEs5VDNjtGo4FLgQBnO89TsbeC4eHrRGJJTnt76L7QR7vHh93ZgaPFxVR4hujsMr6LIvHkDEIm8wpVeTn7jSZ0hgOotVqqqquxWCwcNFspyn89OHiV6QcPqTFaabA3o9WbMdc3YrI20NTqwXXGj9ZYh5R4hLD2cRPtEQ86WwfV9a1U1TnRmI9TqT+KxnAYZbmG4ZExZhdWsZ7sosnXT4tfxOHtx9HZR6M7wDFPAFNTF8/S7/IHN75T6xpA3yaia+5Fa+9BY/OirjuF2uKkUKVj4PIQz9c2aRcn6B6NcG5Ewj8awzcUxXstJuPonWBp/QvCTu4347EFxqPz3Ao94eb0Y27cSzB2N8LYZIgrI7dZXErzbecXM8vrPH2TzfOZ+bcbzK5+Qlp8T/zFB+7Pvebrj5/8AeOMLv8ouoosAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="retina-ex"
        title=""
        src="/static/retina-ex-c0e2a89637045cf5de0738b1fd5c9673-acf85.png"
        srcset="/static/retina-ex-c0e2a89637045cf5de0738b1fd5c9673-c1418.png 210w,
/static/retina-ex-c0e2a89637045cf5de0738b1fd5c9673-5d5d8.png 420w,
/static/retina-ex-c0e2a89637045cf5de0738b1fd5c9673-acf85.png 840w,
/static/retina-ex-c0e2a89637045cf5de0738b1fd5c9673-de0cd.png 1260w,
/static/retina-ex-c0e2a89637045cf5de0738b1fd5c9673-5176d.png 1326w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>如果黑色的手机使用了视网膜屏幕的技术，那么显示结果应该是下面的情况，比如列表的宽度为300个像素，那么在一条水平线上，白色手机会用300个物理像素去渲染它，而黑色手机实际上会用600个像素去渲染它。</p>
<p>我们必须用一种单位来同时告诉不同分辨率的手机，它们在街面上显示的元素的大小是多少，这个单位就是设备独立像素(Device Independent Pixels)简称<code class="gatsby-code-text">DIP</code>或<code class="gatsby-code-text">DP</code>,上面我们说，列表的宽度为300个像素，实际上我们可以说：列表的宽度为300个设备独立像素。</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/ipnone-retina2-0801eb35c1cccccf1f3be999403d38a1-4cd15.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 90.14084507042254%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAADUUlEQVQ4y22Ua08TURCGN+BnjeESo8EfpaCSEL+Z+FH9DYhGRWJi1AAiECG0QqhRY+IFVIRCS1ugVCotvWzvpd3eb/TyemaWLqKcZHL27M4+Z+acd0aCGKVSCfl8HuVyGfV6ndeJRAKZTAbN0Wg0eHa5XDCbzbBarcIsWFtbxcLCAoLBIH+XisUiIpEIFEVhyM7ODmKxGJLJJKLRKFKpFG9CY2VlBS0tLZAkia219ZT23NV1EeFwGBKBmj/SC8v6BoKBiFhnkdhPIZlQUKvVGDgxMck/d3aeQ0dHJy6c70J7eyfa2jpw5vRZWCxWSJSW1+uFx+OB3+9HOBSF7A/Cs+eD1+NHOp3RIpyamoZeNwu3y4OtrW3YtxzY2tzm9dDQExVIZyfLMkfndrux+1u1UDCMgBwSkaY1oE6nx+dPX5FJ5xhCm+65vchlCxgZfimAFkiFQgEOhwOLi4uwWW2Ym5vHqtGEpaVlmE0WZDM5DajXv8H4+CTW161Y/mlkX7PZgtVVEx4+GITNtqECnU4njEYj36BpzcwRkuPmhl1Ek9WAs7NzmJ6ewS+HE86dXZhM6+y7uWnH0OMnAmhTgXQpNNN55nNFTqmQF9LZV8RtKxrQYHiL79+WhIaAlKL6Ksk0fxsbGxeRH6YcCoVYNmTJZIqd6IdoJC6ej2QzP2/Aly+LqJSrh5uleC6XDjA6OnZ0hnQhJBs2ASJLC9mcBPwqgAeVmpCT6kszrV+OvjoCUoQE4yhFdMciVE6IsFJlEPlRhBTx6MiYmjJVCulPNRl+X0A1vzr/LRsCfnj/kSE+r+pLWqX1i+fDaoRNIInb51XFfGSySD1zDGgwvBMajfDtunb38NvpQjgYxdOnz1QgNQKfz8eVQkYgEmzT/gUu/VhG9aCunTOlXas2MDnxWk2ZpEKVQt0iIAe4Aqj0qErI0iLlWr2m6fDGjZsYfDSE/v4BDNy9zzOJuq/vugpsdpVcLseXEo3EePdsJs+7x2P7WnOYmdFp3eUks9u3IZEzAallxeNxcdCirkMRBgfkoOiNZbCSxYjH93H71h309FzB1au96O7uwbVrvbh06TLu3bvPRyORIz00GnWWDl0ORVoXaVar1f8abHNQMyb9ViqVY+//AAXP1+vTiRV6AAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="iphone retina 例子"
        title=""
        src="/static/ipnone-retina2-0801eb35c1cccccf1f3be999403d38a1-acf85.png"
        srcset="/static/ipnone-retina2-0801eb35c1cccccf1f3be999403d38a1-c1418.png 210w,
/static/ipnone-retina2-0801eb35c1cccccf1f3be999403d38a1-5d5d8.png 420w,
/static/ipnone-retina2-0801eb35c1cccccf1f3be999403d38a1-acf85.png 840w,
/static/ipnone-retina2-0801eb35c1cccccf1f3be999403d38a1-de0cd.png 1260w,
/static/ipnone-retina2-0801eb35c1cccccf1f3be999403d38a1-4cd15.png 1278w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>打开chrome的开发者工具，我们可以模拟各个手机型号的显示情况，每种型号上面会显示一个尺寸，比如iPhone X显示的尺寸就是375 x 812,实际上iPhone X的分辨率会比这高很多，这里显示的就是设备独立像素。</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/chrome-mobile-5db0d932e1842531cf9cf7604e848547-9f2ec.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 56.30769230769231%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABUUlEQVQoz52SzW7DIBCE/f7v12sPkXpoYwcbg83PwnQWx46jRq1UpBFml/2YBXciAmMMrJ0QQoD3HvM8I6XU1s65Ni+May7n3HIja1puXdvsnG/xTgPDcMNwM62g7weqb4BxnFrcWov+OsAwF/yCyYy4sWaeLNzsYHUf8856dEpVlyFVrMuKIgm1CGLMdMOZcdQKoTNJjIXU4jpSFDhCwS2lVMSQN6C2EYJgvF7pyuPjKyAzXgiabcLn5QJrJlSpbJEGFKgQKYQm6GL2rJ/iBlTtI3HvMAbGNodaVHig8xlv7wtSeADPqnSYzg51qG0dIupYr6I8FUW2GE8OFaI6gDE/O6x1A+r9nYFHEdf/Amq7r4CSXwN3HcC95b+A5XBYftyh6peW0wZk4dmBOlNg5oGFL94e7CR9sE7/wc2lHNpfuInPLne1bx6S799Pojs98BvE+19sTIzofgAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="chrome模拟mobile"
        title=""
        src="/static/chrome-mobile-5db0d932e1842531cf9cf7604e848547-acf85.png"
        srcset="/static/chrome-mobile-5db0d932e1842531cf9cf7604e848547-c1418.png 210w,
/static/chrome-mobile-5db0d932e1842531cf9cf7604e848547-5d5d8.png 420w,
/static/chrome-mobile-5db0d932e1842531cf9cf7604e848547-acf85.png 840w,
/static/chrome-mobile-5db0d932e1842531cf9cf7604e848547-de0cd.png 1260w,
/static/chrome-mobile-5db0d932e1842531cf9cf7604e848547-9f2ec.png 1300w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<h4 id="设备像素比"><a href="#%E8%AE%BE%E5%A4%87%E5%83%8F%E7%B4%A0%E6%AF%94" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>设备像素比</h4>
<p>设备像素比<code class="gatsby-code-text">device pixek ratio</code>简称dpr,即物理像素和设备独立像素的比值。</p>
<p>在<code class="gatsby-code-text">web</code>中，浏览器为我们提供了<code class="gatsby-code-text">window.devicePixelRatio</code>来帮助我们获取<code class="gatsby-code-text">dpr</code>。</p>
<p>在<code class="gatsby-code-text">css</code>中，可以使用媒体查询<code class="gatsby-code-text">min-device-pixel-ratio</code>，区分<code class="gatsby-code-text">dpr</code>：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-css"><code class="gatsby-code-css"><span class="token atrule"><span class="token rule">@media</span> <span class="token punctuation">(</span><span class="token property">-webkit-min-device-pixel-ratio</span><span class="token punctuation">:</span>2<span class="token punctuation">)</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre>
      </div>
<p>在<code class="gatsby-code-text">React Native</code>中，我们也可以使用<code class="gatsby-code-text">PixelRatio.get()</code>来获取<code class="gatsby-code-text">dpr</code>。</p>
<p>当然，上面的规则也有例外，iPhone6、7、8 plus的实际物理像素是<code class="gatsby-code-text">1080 x 1920</code>,在开发者工具中我们可以看到：它的设备独立像素是<code class="gatsby-code-text">414 x 736</code>,设备像素比为3，设备独立像素和设别像素比的乘积不等于<code class="gatsby-code-text">1080 x 1920</code>,而是等于<code class="gatsby-code-text">1242 x 2208</code>。</p>
<p>实际上，手机会自动把<code class="gatsby-code-text">1242 x 2208</code>个像素点塞进<code class="gatsby-code-text">1080 x 1920</code>个物理像素点来渲染，我们不用关心这个过程，而<code class="gatsby-code-text">1242 x 2208</code>被成为屏幕的设计像素。我们开发的过程中也是以这个<code class="gatsby-code-text">设计像素</code>为准。</p>
<p>实际上，从苹果提出视网膜屏幕开始，才出现设备像素比这个概念，因为在这之前，移动设备都是直接使用物理像素来进行展示。</p>
<p>紧接着，Android同样使用了其他的技术方案来实现DPR大于1的屏幕，不过远离是类似的。由于Android屏幕尺寸非常多、分辨率高低宽度非常大，不像苹果只有它自己的几款固定设备、尺寸。所以，为了保证各种设备的显示效果，Android按照设备的像素密度将设备分成了几个区间：</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/android-dpr-2f6a68ec5978fe4ccfdc24d2bccf69da-b7101.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 56.705539358600575%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAACXklEQVQoz3WS20uTcRjH9/9EIER0Vd1EF9EJMiUzqku7EbrJKykGgsvUmkm40cVm5DscjqzZQcXDWGurmJvv3BYb1Q66o3OT1J0+ve9PXgOrBx54jt/n+zy/n45D0mw2hWp2o9EQqsW12L9Ezek04zDA/5o02d3dxWw2YzQaMRgM2O12EReAanO9Xv8LZGNjA1mW8fv9wrZYLPT396PX65mdnWVqakoASZKEw+HYB9TYaeJfWWF+YZFEKoXNZqO3t5euri6sVivRaBSXy4Xb7SYQCJDNZsnlcmxtbZFS6mu12j7DeDwuJqpFA0NDGAaHealMVtkVi0Xy+Tw+n49CoSCG7u3tsba2RiKRQNswHA7/AXQ6neIOEwp1WQ5Rr9YIKQUej4edXztkMhnBTAVQGaVSaeRVmVgsRjKZJJ1OiwHq2XTVapXvP3+Qy+f4phQsLC6xXdnms3K3T14v5UpFrLO87FIa16kqLErKisHgKkklLhg2G0SUcwiG6mttFooiod4osBIQdiQSwef17b9+vYHb5aZSLh/cOhKOUC6VDvx0MkVdBawp6OOTNvoGB5BeObj34D7dPT2YpQn0Aw+53NHBhbZ2RkwmhkdHuavk7nR3M26TGBkbE/rI+ISnpjFqKP9wbifDaZeVo9Y+LnkmOTNn4cgLAxc9ds65JFqkQVpsQ7SuznDWbaPFMcKx6VGuBJ2cmrdwYsbE8TfPOLk0zvNSHN30dpLzsXd0ht5yNfiadtnJ9fB7WgPTtIVm6Ih+EHpt/SOdWS+3il+Fqv6NnI+bhS/cVvy2jIfHhTC/Aci58dK3cfwrAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="安卓设备像素比"
        title=""
        src="/static/android-dpr-2f6a68ec5978fe4ccfdc24d2bccf69da-acf85.png"
        srcset="/static/android-dpr-2f6a68ec5978fe4ccfdc24d2bccf69da-c1418.png 210w,
/static/android-dpr-2f6a68ec5978fe4ccfdc24d2bccf69da-5d5d8.png 420w,
/static/android-dpr-2f6a68ec5978fe4ccfdc24d2bccf69da-acf85.png 840w,
/static/android-dpr-2f6a68ec5978fe4ccfdc24d2bccf69da-de0cd.png 1260w,
/static/android-dpr-2f6a68ec5978fe4ccfdc24d2bccf69da-b7101.png 1372w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>当然，所有的Android设备不一定严格按照上面的分辨率，每个类型可能对应几种不同分辨率，所以，每个Android手机都能根据给定的区间范围，确定自己的DPR,从而拥有类似的显示。当然，仅仅是类似，由于各个设备的尺寸、分辨率上的差异，设别独立像素也不会完全相等，所以各种Android设备仍然不能做到在展示上完全相等。</p>
<h4 id="原生移动端开发"><a href="#%E5%8E%9F%E7%94%9F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%BC%80%E5%8F%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>原生移动端开发</h4>
<p>在IOS,Android和React Native开发中样式单位其实都使用的是设备独立像素。</p>
<p>ios的尺寸单位是<code class="gatsby-code-text">pt</code>,Android的尺寸单位是<code class="gatsby-code-text">dp</code>,React-Native中没有指定明确的单位，他们其实都是设别独立像素<code class="gatsby-code-text">dp</code>。</p>
<p>在使用React Native开发App时，UI给我们的圆形如一般时基于iPhone6的像素给定的。</p>
<p>为了适配所有机型，我们在写样式时需要把物理像素转换为设备独立像素：例如：如果给定一个元素的高度为200px(这里的px指物理像素，非css像素)，iPhone6的设备像素比为2，我们给定的height应为<code class="gatsby-code-text">200px/2 = 100dp</code>。</p>
<p>当然，最好的是，你可以和设计沟通好，所有的UI图都按照设备独立像素来出。</p>
<p>我们还可以在代码(RN)中进行<code class="gatsby-code-text">px</code>和<code class="gatsby-code-text">dp</code>的转换：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">import</span> <span class="token punctuation">{</span> PixelRatio <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'react-native'</span>

<span class="token keyword">const</span> dpr <span class="token operator">=</span> PixelRatio<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// px 转换为 dp</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">pxToDp</span><span class="token punctuation">(</span>px<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> px <span class="token operator">/</span> dpr
<span class="token punctuation">}</span>

<span class="token comment">// dp 转换为 px</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">dpToPx</span><span class="token punctuation">(</span>dp<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> dp <span class="token operator">*</span> dpr
<span class="token punctuation">}</span></code></pre>
      </div>
<h4 id="web端开发"><a href="#web%E7%AB%AF%E5%BC%80%E5%8F%91" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>web端开发</h4>
<p>在写CSS时，我们用到最多的单位是px,即CSS像素，当页面缩放比例为100%时，一个CSS像素等于一个设备独立像素。</p>
<p>但是CSS像素是很容易被改变的，当用户对浏览器进行了放大，CSS像素会被放大，这时一个CSS像素会跨越更多的物理像素。</p>
<p><code class="gatsby-code-text">页面缩放系数 = CSS像素 / 设备独立像素</code></p>
<h4 id="关于屏幕"><a href="#%E5%85%B3%E4%BA%8E%E5%B1%8F%E5%B9%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>关于屏幕</h4>
<p>这里多说两句<code class="gatsby-code-text">Retina屏幕</code>，因为我在很多文章中看到对<code class="gatsby-code-text">Retina屏幕</code>的误解。</p>
<p>Retina只是苹果提出的一个营销术语：</p>
<blockquote>
<p>在普通的使用距离下，人的肉眼无法分辨单个的像素点</p>
</blockquote>
<p>为什么强调<code class="gatsby-code-text">普通的使用距离下</code>呢？我们来看看它的计算公式：</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/2k-4k-b811ba1a6f4d1565f3d510185b79490c-cabe3.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 46.64586583463338%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABA0lEQVQoz62RzU6EMBRGSym0MNNCoeMIA1EEXczGnT8LdWGMK41mYlyY6Ev4/p8tajITJhGNi5Ob3qSn370lhBD8M8Om7/tgjIFz3uPOru+t8SuhlBJKKVRVhbIoQL+Ef07ohGmaItO6FwtKsRNyLITAvojQxDFqwSG2PzQUKiucTKcw8zkCWzX1cWHrqijx1na4ywzOIgEVsHFCB/MojlSCpU15mhvcZDme2xbvl1e4z2c4jyeQY4TMjndsLzw0B3jZa/DaHWJVLvBU1bhOEjyaGW5TjZOxCUO7l6VN00mFOor7ve1ygSLgMLZqu8s8CHtC+v373s8jD/HW6idORAnd4AM8Z8PmFNZEZAAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="4k屏幕"
        title=""
        src="/static/2k-4k-b811ba1a6f4d1565f3d510185b79490c-acf85.png"
        srcset="/static/2k-4k-b811ba1a6f4d1565f3d510185b79490c-c1418.png 210w,
/static/2k-4k-b811ba1a6f4d1565f3d510185b79490c-5d5d8.png 420w,
/static/2k-4k-b811ba1a6f4d1565f3d510185b79490c-acf85.png 840w,
/static/2k-4k-b811ba1a6f4d1565f3d510185b79490c-de0cd.png 1260w,
/static/2k-4k-b811ba1a6f4d1565f3d510185b79490c-cabe3.png 1282w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>a代表人眼视角，h代表像素间距，d代表肉眼与屏幕的距离，符合以上条件的屏幕可以使肉眼看不见单个物理像素点。</p>
<p>它不能单纯的表达分辨率和PPI,只是一种视觉表达的效果。</p>
<p>让多个物理像素渲染一个独立像素只是<code class="gatsby-code-text">Retina屏幕</code>为了达到效果而使用的一种技术。而不是所有<code class="gatsby-code-text">DPR &gt; 1</code>的屏幕就是<code class="gatsby-code-text">Retina屏幕</code>。</p>
<p>比如：给你一块超大尺寸的屏幕，即使它的PPI很高，DPR很高，但是在因为屏幕太大了，所以近距离还是可以看到它的物理像素点，这就不算Retina屏。</p>
<p><img src=""></p>
<p>我们经常使用K和P这两个单位来描述屏幕。</p>
<p>P代表的就是屏幕纵向的像素点数，比如：<code class="gatsby-code-text">1080P</code>即纵向有<code class="gatsby-code-text">1080</code>个像素，分辨率为<code class="gatsby-code-text">1920 x 1080</code>的屏幕就属于1080P屏幕。</p>
<p>我们平常所说的高清屏其实就是屏幕的物理分辨率达到或者超过<code class="gatsby-code-text">1920 x 1080</code>的屏幕。</p>
<p>K代表屏幕的横向有几个1024个像素，一般来讲横向像素超过<code class="gatsby-code-text">2048</code>就术语<code class="gatsby-code-text">2K</code>屏，横向像素超过<code class="gatsby-code-text">4096</code>就属于<code class="gatsby-code-text">4K</code>屏。</p>
<h3 id="视口"><a href="#%E8%A7%86%E5%8F%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>视口</h3>
<p>视口(viewport)代表当前可见的计算机图形区域。在WEB浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的UI,菜单栏—即指你正在浏览文档的那一部分。</p>
<h4 id="布局视口"><a href="#%E5%B8%83%E5%B1%80%E8%A7%86%E5%8F%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>布局视口</h4>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/layout-viewport-ec5a1f624481179047403a2a8ed4dddf-fc236.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 80.99041533546325%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACWklEQVQ4y41Uy27TQBT1D4HEgvIosKGlgiWIPwFWILGqKJ8BYVF+gkWRECVS1VZukrZpm8R5+BE/Er/j8eHecRxctRW50vF4Zu499zUzihACrutiMpkgCAKEYQjHcTAajeScJc/zpaGwsa7rkvT05BT1+h7ssQvTGKOvDaTSTcJ7tu3AMi3MZjO5ppimiU6ng36/j263h/OzHoZDE449wYjGMAgRRzGiG8BZBD5nFkEIipAjY1Lf9xebPKZpKr1HUYQkSZDEBeK4+h8XewR2yuVTPM+TRtel47qeJK7WqFrTy/ooCDnCavF5kR0UEbpyPU1nco3T4kw4Ip6zbtVOEnJ3ubOlZJmQBiyWZePrl5okKaXdbsuRm5Bl2WKd63ctIS9ybVj+7NZx+9YdbH36DFU9ws7Oz0VESZIuR1i2X1VVbG5uYePZC9xbeYDVh4+xcvc+tre/L8rwX0L2zEqc9ts37/Dh/Ue8evkaa0/Xifg51tc28Gj1CWq1b1K3dF5mJgmn0+k/QvLC8Ki7zUaTDnpbjiVazRYaR00c7B9KnZybIts7b0rOhBxhMCesgGUahFhWBFkJKoMkjH4cALvUvf0OFU9D3qIr19bhqRdIL3SkXVNidq4jOzeQHQ8hGhrEYQdi7wzi9wmyX8fIwwSKPbZhD3SEtgeP7q9rWPDp/PmOB0s3kAZ0JnUXqeEhI4Mspu5GjKSYhzGyoEBOtZd3eUSPg+O5GNIL09M0jG1yQo+G1teQzQ/voiT5HLgK/ih8I5jUsiy6GTa9Mob8HwwG8hmrNusyU34F3Pm/GLm63ZsWbVgAAAAASUVORK5CYII='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="布局视口"
        title=""
        src="/static/layout-viewport-ec5a1f624481179047403a2a8ed4dddf-acf85.png"
        srcset="/static/layout-viewport-ec5a1f624481179047403a2a8ed4dddf-c1418.png 210w,
/static/layout-viewport-ec5a1f624481179047403a2a8ed4dddf-5d5d8.png 420w,
/static/layout-viewport-ec5a1f624481179047403a2a8ed4dddf-acf85.png 840w,
/static/layout-viewport-ec5a1f624481179047403a2a8ed4dddf-fc236.png 1252w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    
布局视口(<code class="gatsby-code-text">layout viewport</code>):当我们以百分比来指定一个元素的大小时，它的计算值是有这个元素的包含块计算而来的。当这个元素是最顶级的元素时，他就是基于布局视口来计算的。</p>
<p>布局视口是网页布局的基准窗口</p>
<p>在PC浏览器上，布局视口就等于当前浏览器的窗口大小(不包括borders,margins,滚动条)。</p>
<p>在移动端，布局视口被赋予一个默认值，大部分为<code class="gatsby-code-text">980px</code>,这保证PC的网页可以在手机浏览器上呈现，但是非常小，用户可以手动对网页进行放大。</p>
<p>我们可以通过调用<code class="gatsby-code-text">document.documentElement.clientWidth / clientHeight</code>来获取布局视口的宽高。</p>
<h4 id="视觉视口"><a href="#%E8%A7%86%E8%A7%89%E8%A7%86%E5%8F%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>视觉视口</h4>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/visual-viewport-7d7ccf6b7263d5f9b7f32e4d05ecba1f-64f22.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 78.91472868217055%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAQCAYAAAAWGF8bAAAACXBIWXMAABYlAAAWJQFJUiTwAAACHUlEQVQ4y41UW2oUQRTt3YiIYsQNKC5AGfKjJL5wBWr8VyTgHoIoLiD+RuICgmvQMTM9mUe/qt/POt57O9Uz02EYL9yuorrq9LnnnmoLFEmSwPd9xHEs8yiKMJvN4LoumqbhLdBaox+8xsl7zHurqipMJhN4nof5fI6zs184/ztB4McYjy4EfBMgRxiGdG6BLMuWgMPhEOPxGKPRCMM/5wRo0wcUFnOXgBXyvECWZnKon2maIk3arOsaFj+4PC6XN+R5LmNVlcQuJgYR+KNlUaIsSxSXo5kX3XrRAvJmLvdqaNIzFVCtG9FpVU8zXw1eE0DHcdZ0YpZVWSFUEZWay5phHwSBzJkRs+s3R0o2DA1gQZqZ+dcv33By8qNjMZ1OhbXsI9DVjneAbJlVwCxrWakgxJPHe7h/7wFOT3/i6OgzlArlXUkVsHZbATnruhEPHh5+wssXr3Dr5m3c2bmL69duyAds2+6k2QpoxD4+/o43rw/w4f1HDAa72N97hqf7z/Ho4QAHb9+JTHzWVLUOSEKvaUhiK6Xgej6chSvmVYGSZKNzE30/EMCrDOkRzBzour0+utFLLVXSdXlbLAHJY/7Qhg4SNGmJ2otoJJA4Q/L7QrxoPGY03pQNkbK4Uywyl8Vasi1YnzAK6eotEIWtRbg8PrAp68sKxdh8j1kXTpvmfBUZlNeN5zb9HPphmfYzOxZcGkANYcC+nf4n/wHkl8I//8zhtgAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="视觉视口"
        title=""
        src="/static/visual-viewport-7d7ccf6b7263d5f9b7f32e4d05ecba1f-acf85.png"
        srcset="/static/visual-viewport-7d7ccf6b7263d5f9b7f32e4d05ecba1f-c1418.png 210w,
/static/visual-viewport-7d7ccf6b7263d5f9b7f32e4d05ecba1f-5d5d8.png 420w,
/static/visual-viewport-7d7ccf6b7263d5f9b7f32e4d05ecba1f-acf85.png 840w,
/static/visual-viewport-7d7ccf6b7263d5f9b7f32e4d05ecba1f-de0cd.png 1260w,
/static/visual-viewport-7d7ccf6b7263d5f9b7f32e4d05ecba1f-64f22.png 1290w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    
视觉视口(visual viewport):用户通过屏幕真实看到的区域。</p>
<p>视觉视口默认等于当前浏览器的窗口大小，(包含滚动条宽度)。</p>
<p>当用户对浏览器进行缩放时，不会改变布局窗口的大小，所以页面布局是不变的，但是缩放会改变视觉视口的大小。</p>
<p>例如：用户将浏览器窗口放大了200%，这时浏览器窗口中的CSS像素会随着数据额的放大而放大，这时一个CSS像素会跨越更多的物理像素。</p>
<p>所以，布局视口会限制你的CSS布局而视觉视口决定用户具体能看到什么。</p>
<p>我们可以通过调用<code class="gatsby-code-text">window.innerWidth / innerHeight</code>来获取视觉视口大小。</p>
<h4 id="理想视口"><a href="#%E7%90%86%E6%83%B3%E8%A7%86%E5%8F%A3" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>理想视口</h4>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/chrome-mobile-5db0d932e1842531cf9cf7604e848547-9f2ec.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 56.30769230769231%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAABUUlEQVQoz52SzW7DIBCE/f7v12sPkXpoYwcbg83PwnQWx46jRq1UpBFml/2YBXciAmMMrJ0QQoD3HvM8I6XU1s65Ni+May7n3HIja1puXdvsnG/xTgPDcMNwM62g7weqb4BxnFrcWov+OsAwF/yCyYy4sWaeLNzsYHUf8856dEpVlyFVrMuKIgm1CGLMdMOZcdQKoTNJjIXU4jpSFDhCwS2lVMSQN6C2EYJgvF7pyuPjKyAzXgiabcLn5QJrJlSpbJEGFKgQKYQm6GL2rJ/iBlTtI3HvMAbGNodaVHig8xlv7wtSeADPqnSYzg51qG0dIupYr6I8FUW2GE8OFaI6gDE/O6x1A+r9nYFHEdf/Amq7r4CSXwN3HcC95b+A5XBYftyh6peW0wZk4dmBOlNg5oGFL94e7CR9sE7/wc2lHNpfuInPLne1bx6S799Pojs98BvE+19sTIzofgAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="理想视口"
        title=""
        src="/static/chrome-mobile-5db0d932e1842531cf9cf7604e848547-acf85.png"
        srcset="/static/chrome-mobile-5db0d932e1842531cf9cf7604e848547-c1418.png 210w,
/static/chrome-mobile-5db0d932e1842531cf9cf7604e848547-5d5d8.png 420w,
/static/chrome-mobile-5db0d932e1842531cf9cf7604e848547-acf85.png 840w,
/static/chrome-mobile-5db0d932e1842531cf9cf7604e848547-de0cd.png 1260w,
/static/chrome-mobile-5db0d932e1842531cf9cf7604e848547-9f2ec.png 1300w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>布局视口在移动端展示的效果并不是一个理想的效果，所以理想视口(ideal viewport)就诞生了：网站页面在移动端展示的理想大小。</p>
<p>如上图，我们在描述设备独立像素时曾使用过这张图，在浏览器调试移动端页面上给定的元素大小就是理想视口大小，它的单位正是设备独立像素。</p>
<p>在上面介绍CSS像素时，曾提到<code class="gatsby-code-text">页面的缩放系数 = CSS像素 / 设备独立像素</code>，实际上说<code class="gatsby-code-text">页面的缩放系数 = 理想视口宽度 / 视觉视口宽度</code>更为准确。</p>
<p>所以，当页面缩放比例为100%时，<code class="gatsby-code-text">CSS像素 = 设备独立像素</code>，<code class="gatsby-code-text">理想视口 = 视觉视口</code>。</p>
<p>我们可以通过调用<code class="gatsby-code-text">screen.width / height</code>来获取理想视口大小。</p>
<h4 id="meta-viewport"><a href="#meta-viewport" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Meta viewport</h4>
<p>我们可以借助<code class="gatsby-code-text">&lt;meta&gt;</code>元素viewport来帮助我们设置视口、缩放等，从而让移动端得到更好的展示效果。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-html"><code class="gatsby-code-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1.0<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre>
      </div>
<p>上面<code class="gatsby-code-text">viewport</code>的一个配置，我们来看看他们的具体含义：</p>
<ul>
<li>
<p>width(正整数或device-width) — 以pixels(整数)为单位，定义布局视口的宽度。</p>
</li>
<li>
<p>height(正整数或device-height) — 以pixels(整数)为单位，定义布局视口的高度。</p>
</li>
<li>
<p>initial-scale(0.0 - 10.0) — 定义页面初始缩放比例。</p>
</li>
<li>
<p>minimun-scale(0.0 - 10.0) — 定义页面可缩放的最小值；必须小于或者等于<code class="gatsby-code-text">maximun-scale</code>的值。</p>
</li>
<li>
<p>maximun-scale(0.0 -10.0) — 定义页面可放大的最大值；必须大于或者等于<code class="gatsby-code-text">minimun-scale</code>的值。</p>
</li>
<li>
<p>user-scalable(yes or no) — 如果设置为no,用户将不能放大或缩小网页。默认值为yes(IOS10以后，该属性被Safari浏览器全部重置为yes)</p>
</li>
</ul>
<h4 id="移动端适配"><a href="#%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>移动端适配</h4>
<p>为了在移动端让页面获得更好的显示效果，我们必须让布局视口、视觉视口都尽可能等于理想视口。</p>
<p><code class="gatsby-code-text">deive-width</code>就等于理想视口的宽度，所以设置<code class="gatsby-code-text">width=device-width</code>就相当于让布局视口等于理想视口。</p>
<p>由于<code class="gatsby-code-text">initial-scale = 理想视口宽度 / 视觉视口宽度</code>，所以我们设置<code class="gatsby-code-text">initial-scale=1</code>,就相当于让视觉视口等于理想视口。</p>
<p>这时，1个CSS像素就等于1个设备独立像素，而且我们也是基于理想视口来进行布局的，所以呈现出来的页面布局在各种设备上都能大致相似。</p>
<h4 id="缩放"><a href="#%E7%BC%A9%E6%94%BE" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缩放</h4>
<p>上面提到的width可以决定布局适口的宽度，实际上它并不是布局适口的唯一决定性因素，设置initial-scale也有可能影响到布局视口，因为布局视口宽度取 的是width和视觉视口宽度的最大值。</p>
<p>例如：若手机的理想视口宽度为<code class="gatsby-code-text">400px</code>,设置<code class="gatsby-code-text">width=device-width,initial-scale=2</code>,此时<code class="gatsby-code-text">视觉视口宽度 = 理想适口宽度 / initial-scale</code>即<code class="gatsby-code-text">200px</code>,布局视口取两者最大值即<code class="gatsby-code-text">device-width 400px</code>。</p>
<p>若设置<code class="gatsby-code-text">width=device-width,initial-scale=0.5</code>,此时<code class="gatsby-code-text">视觉视口宽度 = 理想视口宽度 / initial-scale</code>即<code class="gatsby-code-text">800px</code>,布局视口取两者最大值<code class="gatsby-code-text">800px</code>。</p>]]></description><link>https://reactjs.org/blog/2019/05/24/mobile.html</link><guid isPermaLink="false">https://reactjs.org/blog/2019/05/24/mobile.html</guid><pubDate>Thu, 23 May 2019 16:00:00 GMT</pubDate></item><item><title><![CDATA[How JavaScript Work: 内存管理/垃圾收集/内存泄漏]]></title><description><![CDATA[<h3 id="javascript-是如何工作的：内存管理--处理常见的-4-种内存泄漏"><a href="#javascript-%E6%98%AF%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%E7%9A%84%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86--%E5%A4%84%E7%90%86%E5%B8%B8%E8%A7%81%E7%9A%84-4-%E7%A7%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 是如何工作的：内存管理 + 处理常见的 4 种内存泄漏</h3>
<p>我们将讨论另外一个越来越被开发人员忽视的主题，原因是应用于日常基础内存管理的程序语言越来越成熟和复杂。我们也将会在 <a href="https://www.sessionstack.com/?utm_source=medium&#x26;utm_medium=blog&#x26;utm_content=Post-3-v8-intro">SessionStack</a> 提供一些关于如何处理 JavaScript 内存泄漏的建议，我们需要确认 SessionStack 不会导致内存泄漏，或者不会增加我们集成的 web 应用程序的消耗。</p>
<h4 id="概览"><a href="#%E6%A6%82%E8%A7%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>概览</h4>
<p>例如，像 C 这样的编程语言，有 <code class="gatsby-code-text">malloc()</code> 和 <code class="gatsby-code-text">free()</code> 这样的基础内存管理函数。开发人员可以使用这些函数来显式分配和释放操作系统的内存。</p>
<p>与此同时，JavaScrip 在对象被创建时分配内存，并在对象不再使用时“自动”释放内存，这个过程被称为垃圾回收。这种看似“自动”释放资源的特性是导致混乱的来源，它给了 JavaScript（和其他高级语言）开发者们一种错觉，他们可以选择不去关心内存管理。<strong>这是一种错误的观念</strong></p>
<p>即使使用高级语言，开发者也应该对内存管理有一些理解（至少关于基本的内存管理）。有时，自动内存管理存在的问题（比如垃圾回收器的错误或内存限制等）要求开发者需要理解内存管理，才能处理的更合适（或找到代价最少的替代方案）。</p>
<h4 id="内存生命周期"><a href="#%E5%86%85%E5%AD%98%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>内存生命周期</h4>
<p>无论你使用哪种程序语言，内存生命周期总是大致相同的：</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*slxXgq_TO38TgtoKpWa_jQ.png"></p>
<p>以下是对循环中每一步具体情况的概述：</p>
<ul>
<li>
<p> <strong>内存分配</strong> — 内存由操作系统分配，它允许你的应用程序使用。在基础语言中 (比如 C 语言)，这是一个开发人员应该处理的显式操作。然而在高级系统中，语言已经帮你完成了这些工作。</p>
</li>
<li>
<p> <strong>内存使用</strong> — 这是你的程序真正使用之前分配的内存的时候，<strong>读写</strong>操作在你使用代码中已分配的变量时发生。</p>
</li>
<li>
<p> <strong>内存释放</strong> — 释放你明确不需要的内存，让其再次空闲和可用。和<strong>内存分配</strong>一样，在基础语言中这是显式操作。
关于调用栈和内存堆的概念的快速概览，可以阅读我们的<a href="https://blog.sessionstack.com/how-does-javascript-actually-work-part-1-b0bacc073cf">关于主题的第一篇文章</a>。</p>
</li>
</ul>
<h4 id="内存是什么"><a href="#%E5%86%85%E5%AD%98%E6%98%AF%E4%BB%80%E4%B9%88" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>内存是什么?</h4>
<p>在直接跳到有关 JavaScript 中的内存部分之前，我们将简要地讨论一下内存的概况以及它是如何工作的：</p>
<p>在硬件层面上，内存包含大量的<a href="https://en.wikipedia.org/wiki/Flip-flop_%28electronics%29">触发器</a>。每一个触发器包含一些晶体管并能够存储一位。单独的触发器可通过<strong>唯一标识符</strong>寻址, 所以我们可以读取和覆盖它们。因此，从概念上讲，我们可以把整个计算机内存看作是我们可以读写的一个大的位组。</p>
<p>作为人类，我们并不擅长在位操作中实现我们所有的思路和算法，我们把它们组装成更大的组，它可以用来表示数字。8 位称为 1 个字节。除字节外，还有单词（有时是 16，有时是 32 位）。</p>
<p>很多东西存储在内存中:</p>
<ol>
<li>所有程序使用的所有变量和其他数据。</li>
<li>程序的代码，包括操作系统的代码。</li>
</ol>
<p>编译器和操作系统一起为您处理了大部分的内存管理，但是我们建议您看看底层发生了什么。</p>
<p>当你编译代码时，编译器可以检查原始数据类型，并提前计算它们需要多少内存。然后所需的数量被分配给<strong>栈空间</strong>中的程序。分配这些变量的空间称为栈空间，因为随着函数被调用，它们的内存被添加到现有的内存之上。当它们终止时，它们以 LIFO（后进先出）顺序被移除。 例如，请考虑以下声明：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">int n<span class="token punctuation">;</span> <span class="token comment">// 4 bytes</span>
int x<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// array of 4 elements, each 4 bytes</span>
double m<span class="token punctuation">;</span> <span class="token comment">// 8 bytes</span></code></pre>
      </div>
<p>编译器可以立即计算到代码需要</p>
<p>4 + 4 × 4 + 8 = 28 bytes</p>
<blockquote>
<p>这是它处理 integers 和 doubles 类型当前大小的方式。大约 20 年前，integers 通常是 2 个字节，doubles 通常是 4 个字节。您的代码不应该依赖于某一时刻基本数据类型的大小。</p>
</blockquote>
<p>编译器将插入与操作系统交互的代码，为堆栈中的变量请求存储所需的字节数。</p>
<p>在上面的例子中，编译器知道每个变量的具体内存地址。 事实上，只要我们写入变量 <code class="gatsby-code-text">n</code>，它就会在内部被翻译成类似“内存地址 4127963”的内容。</p>
<p>注意，如果我们试图在这里访问 <code class="gatsby-code-text">x[4]</code>，我们将访问与 m 关联的数据。这是因为我们正在访问数组中不存在的一个元素 - 它比数组中最后一个实际分配的元素 <code class="gatsby-code-text">x[3]</code> 深了 4 个字节，并且最终可能会读取（或覆盖）一些 <code class="gatsby-code-text">m</code> 的位。这对项目的其余部分有预料之外的影响。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*5aBou4onl1B8xlgwoGTDOg.png"></p>
<p>当函数调用其他函数时，每个其他函数调用时都会产生自己的栈块。栈块保留了它所有的局部变量和一个记录了执行地点程序计数器。当函数调用完成时，其内存块可再次用于其他方面。</p>
<h4 id="动态分配"><a href="#%E5%8A%A8%E6%80%81%E5%88%86%E9%85%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>动态分配</h4>
<p>遗憾的是，当我们不知道编译时变量需要多少内存时，事情变得不再简单。假设我们想要做如下的事情：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">int n <span class="token operator">=</span> <span class="token function">readInput</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// reads input from the user</span>
<span class="token operator">...</span>
<span class="token comment">// create an array with "n" elements</span></code></pre>
      </div>
<p>这里，在编译时，编译器不知道数组需要多少内存，因为它是由用户提供的值决定的。</p>
<p>因此，它不能为堆栈上的变量分配空间。相反，我们的程序需要在运行时明确地向操作系统请求正确的内存量。这个内存是从<strong>堆空间</strong>分配的。下表总结了静态和动态内存分配之间的区别：</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*qY-yRQWGI-DLS3zRHYHm9A.png"></p>
<p>静态和动态内存分配的区别</p>
<p>为了充分理解动态内存分配是如何工作的，我们需要在<strong>指针</strong>上花费更多的时间，这可能与本文的主题略有偏差。如果您有兴趣了解更多信息，请在评论中告诉我们，我们可以在以后的文章中详细介绍指针。</p>
<h4 id="javascript-中的内存分配"><a href="#javascript-%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 中的内存分配</h4>
<p>现在我们将解释第一步（<strong>分配内存</strong>）是如何在JavaScript中工作的。</p>
<p>JavaScript 减轻了开发人员处理内存分配的责任 - JavaScript自己执行了内存分配，同时声明了值。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> n <span class="token operator">=</span> <span class="token number">374</span><span class="token punctuation">;</span> <span class="token comment">// allocates memory for a number</span>
<span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token string">'sessionstack'</span><span class="token punctuation">;</span> <span class="token comment">// allocates memory for a string </span>
<span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  b<span class="token punctuation">:</span> <span class="token keyword">null</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">// allocates memory for an object and its contained values</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token string">'str'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// (like object) allocates memory for the</span>
                           <span class="token comment">// array and its contained values</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token comment">// allocates a function (which is a callable object)</span>
<span class="token comment">// function expressions also allocate an object</span>
someElement<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  someElement<span class="token punctuation">.</span>style<span class="token punctuation">.</span>backgroundColor <span class="token operator">=</span> <span class="token string">'blue'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>一些函数调用也会导致对象分配：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// allocates a Date object</span>

<span class="token keyword">var</span> e <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// allocates a DOM element</span></code></pre>
      </div>
<p>方法可以分配新的值或对象：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token string">'sessionstack'</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> s2 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">substr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// s2 is a new string</span>
<span class="token comment">// Since strings are immutable, </span>
<span class="token comment">// JavaScript may decide to not allocate memory, </span>
<span class="token comment">// but just store the [0, 3] range.</span>
<span class="token keyword">var</span> a1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'str1'</span><span class="token punctuation">,</span> <span class="token string">'str2'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a2 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'str3'</span><span class="token punctuation">,</span> <span class="token string">'str4'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> a3 <span class="token operator">=</span> a1<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>a2<span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment">// new array with 4 elements being</span>
<span class="token comment">// the concatenation of a1 and a2 elements</span></code></pre>
      </div>
<h4 id="在-javascript-中使用内存"><a href="#%E5%9C%A8-javascript-%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%86%85%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>在 JavaScript 中使用内存</h4>
<p>基本上在 JavaScript 中使用分配的内存，意味着在其中读写。</p>
<p>这可以通过读取或写入变量或对象属性的值，甚至传递一个变量给函数来完成。</p>
<h4 id="在内存不再需要时释放内存"><a href="#%E5%9C%A8%E5%86%85%E5%AD%98%E4%B8%8D%E5%86%8D%E9%9C%80%E8%A6%81%E6%97%B6%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>在内存不再需要时释放内存</h4>
<p>绝大部分内存管理问题都处于这个阶段。</p>
<p>这里最困难的任务是确定何时不再需要这些分配了的内存。它通常需要开发人员确定程序中的哪个部分不再需要这些内存，并将其释放。</p>
<p>高级语言嵌入了一个称为<strong>垃圾回收器</strong>的软件，其工作是跟踪内存分配和使用情况，以便找到何时何种情况下不再需要这些分配了的内存，它将自动释放内存。</p>
<p>不幸的是，这个过程是一个近似值，因为预估是否需要某些内存的问题通常是<a href="http://en.wikipedia.org/wiki/Decidability_%28logic%29">不可判定的</a>（无法通过算法解决）。</p>
<p>大多数垃圾回收器通过收集不能再访问的内存来工作，例如，所有指向它的变量都超出了作用域。然而，这是可以收集的一组内存空间的近似值，因为在某种情况下内存位置可能仍然有一个指向它的变量，但它将不会被再次访问。</p>
<h4 id="垃圾回收机制"><a href="#%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>垃圾回收机制</h4>
<p>由于发现一些内存是否“不再需要”事实上是不可判定的，所以垃圾收集在实施一般问题解决方案时具有局限性。本节将解释主要垃圾收集算法及其局限性的基本概念。</p>
<h4 id="内存引用"><a href="#%E5%86%85%E5%AD%98%E5%BC%95%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>内存引用</h4>
<p>垃圾收集算法所依赖的主要概念来源于<strong>附录参考资料</strong>。</p>
<p>在内存管理的上下文中，如果一个对象可以访问另一个对象（可以是隐式的或显式的），则称该对象引用另一个对象。例如, 一个 JavaScript 引用了它的 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain">prototype</a> (<strong>隐式引用</strong>)和它的属性值(<strong>显式引用</strong>)。</p>
<p>在这种情况下，“对象”的概念扩展到比普通JavaScript对象更广泛的范围，并包含函数作用域（或全局<strong>词法范围</strong>）。</p>
<blockquote>
<p>词法作用域定义了变量名如何在嵌套函数中解析：即使父函数已经返回，内部函数仍包含父函数的作用域。</p>
</blockquote>
<h4 id="引用计数垃圾收集"><a href="#%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>引用计数垃圾收集</h4>
<p>这是最简单的垃圾收集算法。 如果有<strong>零个指向它</strong>的引用，则该对象被认为是“可垃圾回收的”。</p>
<p>请看下面的代码:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span>
  o2<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">:</span> <span class="token number">1</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">// 2 objects are created. </span>
<span class="token comment">// 'o2' is referenced by 'o1' object as one of its properties.</span>
<span class="token comment">// None can be garbage-collected</span>

<span class="token keyword">var</span> o3 <span class="token operator">=</span> o1<span class="token punctuation">;</span> <span class="token comment">// the 'o3' variable is the second thing that </span>
            <span class="token comment">// has a reference to the object pointed by 'o1'. </span>
                                                       
o1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">// now, the object that was originally in 'o1' has a         </span>
            <span class="token comment">// single reference, embodied by the 'o3' variable</span>

<span class="token keyword">var</span> o4 <span class="token operator">=</span> o3<span class="token punctuation">.</span>o2<span class="token punctuation">;</span> <span class="token comment">// reference to 'o2' property of the object.</span>
                <span class="token comment">// This object has now 2 references: one as</span>
                <span class="token comment">// a property. </span>
                <span class="token comment">// The other as the 'o4' variable</span>

o3 <span class="token operator">=</span> <span class="token string">'374'</span><span class="token punctuation">;</span> <span class="token comment">// The object that was originally in 'o1' has now zero</span>
            <span class="token comment">// references to it. </span>
            <span class="token comment">// It can be garbage-collected.</span>
            <span class="token comment">// However, what was its 'o2' property is still</span>
            <span class="token comment">// referenced by the 'o4' variable, so it cannot be</span>
            <span class="token comment">// freed.</span>

o4 <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// what was the 'o2' property of the object originally in</span>
           <span class="token comment">// 'o1' has zero references to it. </span>
           <span class="token comment">// It can be garbage collected.</span></code></pre>
      </div>
<h4 id="周期产生问题"><a href="#%E5%91%A8%E6%9C%9F%E4%BA%A7%E7%94%9F%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>周期产生问题</h4>
<p>在周期循环中有一个限制。在下面的例子中，两个对象被创建并相互引用，这就创建了一个循环。在函数调用之后，它们会超出界限，所以它们实际上是无用的，并且可以被释放。然而，引用计数算法认为，由于两个对象中的每一个都被至少引用了一次，所以两者都不能被垃圾收集。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> o1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> o2 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
  o1<span class="token punctuation">.</span>p <span class="token operator">=</span> o2<span class="token punctuation">;</span> <span class="token comment">// o1 references o2</span>
  o2<span class="token punctuation">.</span>p <span class="token operator">=</span> o1<span class="token punctuation">;</span> <span class="token comment">// o2 references o1. This creates a cycle.</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p><img src="https://cdn-images-1.medium.com/max/800/1*GF3p99CQPZkX3UkgyVKSHw.png"></p>
<h4 id="标记和扫描算法"><a href="#%E6%A0%87%E8%AE%B0%E5%92%8C%E6%89%AB%E6%8F%8F%E7%AE%97%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>标记和扫描算法</h4>
<p>为了确定是否需要某个对象，本算法判断该对象是否可访问。</p>
<p>标记和扫描算法经过这 3 个步骤：</p>
<p>1.根节点：一般来说，根是代码中引用的全局变量。例如，在 JavaScript 中，可以充当根节点的全局变量是“window”对象。Node.js 中的全局对象被称为“global”。完整的根节点列表由垃圾收集器构建。
2.然后算法检查所有根节点和他们的子节点并且把他们标记为活跃的（意思是他们不是垃圾）。任何根节点不能访问的变量将被标记为垃圾。
3.最后，垃圾收集器释放所有未被标记为活跃的内存块，并将这些内存返回给操作系统。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*WVtok3BV0NgU95mpxk9CNg.gif"></p>
<p>标记和扫描算法行为的可视化。</p>
<p>因为“一个对象有零引用”导致该对象不可达，所以这个算法比前一个算法更好。我们在周期中看到的情形恰巧相反，是不正确的。</p>
<p>截至 2012 年，所有现代浏览器都内置了标记扫描式的垃圾回收器。去年在 JavaScript 垃圾收集（通用/增量/并发/并行垃圾收集）领域中所做的所有改进都是基于这种算法（标记和扫描）的实现改进，但这不是对垃圾收集算法本身的改进，也不是对判断一个对象是否可达这个目标的改进。</p>
<p><a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection">在本文中</a>, 您可以阅读有关垃圾回收跟踪的更详细的信息，文章也包括标记和扫描算法以及其优化。</p>
<h4 id="周期不再是问题"><a href="#%E5%91%A8%E6%9C%9F%E4%B8%8D%E5%86%8D%E6%98%AF%E9%97%AE%E9%A2%98" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>周期不再是问题</h4>
<p>在上面的第一个例子中，函数调用返回后，两个对象不再被全局对象中的某个变量引用。因此，垃圾收集器会认为它们不可访问。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*FbbOG9mcqWZtNajjDO6SaA.png"></p>
<p>即使两个对象之间有引用，从根节点它们也不再可达。</p>
<h4 id="统计垃圾收集器的直观行为"><a href="#%E7%BB%9F%E8%AE%A1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E7%9A%84%E7%9B%B4%E8%A7%82%E8%A1%8C%E4%B8%BA" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>统计垃圾收集器的直观行为</h4>
<p>尽管垃圾收集器很方便，但他们也有自己的一套权衡策略。其中之一是不确定性。换句话说，GCs（垃圾收集器）们是不可预测的。你不能确定一个垃圾收集器何时会执行收集。这意味着在某些情况下，程序其实需要使用更多的内存。其他情况下，在特别敏感的应用程序中，短暂暂停可能是显而易见的。尽管不确定性意味着不能确定一个垃圾收集器何时执行收集，大多数 GC 共享分配中的垃圾收集通用模式。如果没有执行分配，大多数 GC 保持空闲状态。考虑如下场景：</p>
<ol>
<li>大量的分配被执行。</li>
<li>大多数这些元素（或全部）被标记为不可访问（假设我们废除一个指向我们不再需要的缓存的引用）。</li>
<li>没有执行更深的内存分配。</li>
</ol>
<p>在这种情况下，大多数 GC 不会运行任何更深层次的收集。换句话说，即使存在不可用的引用可用于收集，收集器也不会声明这些引用。这些并不是严格的泄漏，但仍会导致高于日常的内存使用率。</p>
<h4 id="什么是内存泄漏"><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是内存泄漏?</h4>
<p>就像内存描述的那样，内存泄漏是应用程序过去使用但不再需要的尚未返回到操作系统或可用内存池的内存片段。</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*0B-dAUOH7NrcCDP6GhKHQw.jpeg"></p>
<p>编程语言偏好不同的内存管理方式。但是，某段内存是否被使用实际上是一个<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Memory_Management#Release_when_the_memory_is_not_needed_anymore">不可判定问题</a>。换句话说，只有开发人员可以明确某块内存是否可以返回给操作系统。</p>
<p>某些编程语言提供了帮助开发人员执行上述操作的功能。其他人则希望开发人员能够完全明确某段内存何时处于未使用状态。维基百科在如何<a href="https://en.wikipedia.org/wiki/Manual_memory_management">手工</a>和<a href="https://en.wikipedia.org/wiki/Garbage_collection_%28computer_science%29">自动</a>内存管理方面有很好的文章。</p>
<h4 id="javascript-常见的四种内存泄漏"><a href="#javascript-%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9B%9B%E7%A7%8D%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 常见的四种内存泄漏</h4>
<h4 id="1：全局变量"><a href="#1%EF%BC%9A%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>1：全局变量</h4>
<p>JavaScript 用一种有趣的方式处理未声明的变量：当引用一个未声明的变量时，在 <em>global</em> 对象中创建一个新变量。在浏览器中，全局对象将是 <code class="gatsby-code-text">window</code>，这意味着</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    bar <span class="token operator">=</span> <span class="token string">"some text"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>等同于:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span>arg<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    window<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">"some text"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>我们假设 <code class="gatsby-code-text">bar</code> 的目的只是引用 foo 函数中的一个变量。然而，如果你不使用 <code class="gatsby-code-text">var</code> 来声明它，就会创建一个冗余的全局变量。在上面的情况中，这不会造成很严重的后果。你可以想象一个更具破坏性的场景。</p>
<p>你也可以用 <code class="gatsby-code-text">this</code> 意外地创建一个全局变量：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>var1 <span class="token operator">=</span> <span class="token string">"potential accidental global"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// Foo called on its own, this points to the global object (window)</span>
<span class="token comment">// rather than being undefined.</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<blockquote>
<p>你可以通过在 JavaScript 文件的开头添加 <code class="gatsby-code-text">&#39;use strict&#39;;</code> 来避免这些后果，这将开启一种更严格的 JavaScript 解析模式，从而防止意外创建全局变量。</p>
</blockquote>
<p>意外的全局变量当然是个问题，然而更常出现的情况是，你的代码会受到显式的全局变量的影响，而这些全局变量无法通过垃圾收集器收集。需要特别注意用于临时存储和处理大量信息的全局变量。如果你必须使用全局变量来存储数据，当你这样做的时候，要保证一旦完成使用就把他们<strong>赋值为 null 或重新赋值</strong> 。</p>
<h4 id="2：被忘记的定时器或者回调函数"><a href="#2%EF%BC%9A%E8%A2%AB%E5%BF%98%E8%AE%B0%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8%E6%88%96%E8%80%85%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>2：被忘记的定时器或者回调函数</h4>
<p>我们以经常在 JavaScript 中使用的 <code class="gatsby-code-text">setInterval</code> 为例。</p>
<p>提供观察者和其他接受回调的工具库通常确保所有对回调的引用在其实例无法访问时也变得无法访问。然而，下面的代码并不鲜见：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> serverData <span class="token operator">=</span> <span class="token function">loadData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">var</span> renderer <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'renderer'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>renderer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        renderer<span class="token punctuation">.</span>innerHTML <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>serverData<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">5000</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//This will be executed every ~5 seconds.</span></code></pre>
      </div>
<p>上面的代码片段显示了使用定时器引用节点或无用数据的后果。</p>
<p><code class="gatsby-code-text">renderer</code> 对象可能会在某些时候被替换或删除，这会使得间隔处理程序封装的块变得冗余。如果发生这种情况，处理程序及其依赖项都不会被收集，因为间隔处理需要先备停止（请记住，它仍然是活动的）。这一切都归结为一个事实，即事实存储和处理负载数据的 <code class="gatsby-code-text">serverData</code> 也不会被收集。</p>
<p>当使用观察者时，你需要确保一旦依赖于它们的事务已经处理完成，你编写了明确的调用来删除它们（不再需要观察者，或者对象将变得不可用时）。</p>
<p>幸运的是，大多数现代浏览器都会为你做这件事：即使你忘记删除监听器，当观察对象变得无法访问时，它们也会自动收集观察者处理程序。过去一些浏览器无法处理这些情况（旧的 IE6）。</p>
<p>但是，尽管如此，一旦对象变得过时，移除观察者才是符合最佳实践的。看下面的例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'launch-button'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">onClick</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>
   counter<span class="token operator">++</span><span class="token punctuation">;</span>
   element<span class="token punctuation">.</span>innerHtml <span class="token operator">=</span> <span class="token string">'text '</span> <span class="token operator">+</span> counter<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
element<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Do stuff</span>
element<span class="token punctuation">.</span><span class="token function">removeEventListener</span><span class="token punctuation">(</span><span class="token string">'click'</span><span class="token punctuation">,</span> onClick<span class="token punctuation">)</span><span class="token punctuation">;</span>
element<span class="token punctuation">.</span>parentNode<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Now when element goes out of scope,</span>
<span class="token comment">// both element and onClick will be collected even in old browsers // that don't handle cycles well.</span></code></pre>
      </div>
<p>现在的浏览器支持检测这些循环并适当地处理它们的垃圾收集器，因此在制造一个无法访问的节点之前，你不再需要调用 <code class="gatsby-code-text">removeEventListener</code>。</p>
<p>如果您利用 <code class="gatsby-code-text">jQuery</code> API（其他库和框架也支持这个），您也可以在节点废弃之前删除监听器。即使应用程序在较旧的浏览器版本下运行，这些库也会确保没有内存泄漏。</p>
<p>3：闭包</p>
<p>JavaScript开发的一个关键方面是闭包：一个内部函数可以访问外部（封闭）函数的变量。由于JavaScript运行时的实现细节，可能以如下方式泄漏内存：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> theThing <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">replaceThing</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> originalThing <span class="token operator">=</span> theThing<span class="token punctuation">;</span>
  <span class="token keyword">var</span> <span class="token function-variable function">unused</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>originalThing<span class="token punctuation">)</span> <span class="token comment">// a reference to 'originalThing'</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"hi"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
  theThing <span class="token operator">=</span> <span class="token punctuation">{</span>
    longStr<span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'*'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    someMethod<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"message"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">setInterval</span><span class="token punctuation">(</span>replaceThing<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>一旦调用了 <code class="gatsby-code-text">replaceThing</code> 函数，<code class="gatsby-code-text">theThing</code> 就得到一个新的对象，它由一个大数组和一个新的闭包（<code class="gatsby-code-text">someMethod</code>）组成。然而 <code class="gatsby-code-text">originalThing</code> 被一个由 <code class="gatsby-code-text">unused</code> 变量（这是从前一次调用 <code class="gatsby-code-text">replaceThing</code> 变量的 <code class="gatsby-code-text">Thing</code> 变量）所持有的闭包所引用。需要记住的是<strong>一旦为同一个父作用域内的闭包创建作用域，作用域将被共享。</strong></p>
<p>在个例子中，<code class="gatsby-code-text">someMethod</code> 创建的作用域与 <code class="gatsby-code-text">unused</code> 共享。<code class="gatsby-code-text">unused</code> 包含一个关于 <code class="gatsby-code-text">originalThing</code> 的引用。即使 <code class="gatsby-code-text">unused</code> 从未被引用过，<code class="gatsby-code-text">someMethod</code> 也可以通过 <code class="gatsby-code-text">replaceThing</code> 作用域之外的 <code class="gatsby-code-text">theThing</code> 来使用它（例如全局的某个地方）。由于 <code class="gatsby-code-text">someMethod</code> 与 <code class="gatsby-code-text">unused</code> 共享闭包范围，<code class="gatsby-code-text">unused</code> 指向 <code class="gatsby-code-text">originalThing</code> 的引用强制它保持活动状态（两个闭包之间的整个共享范围）。这阻止了它们的垃圾收集。</p>
<p>在上面的例子中，为闭包 <code class="gatsby-code-text">someMethod</code> 创建的作用域与 <code class="gatsby-code-text">unused</code> 共享，而 <code class="gatsby-code-text">unused</code> 又引用 <code class="gatsby-code-text">originalThing</code>。<code class="gatsby-code-text">someMethod</code> 可以通过 <code class="gatsby-code-text">replaceThing</code> 范围之外的 <code class="gatsby-code-text">theThing</code> 来引用，尽管 <code class="gatsby-code-text">unused</code> 从来没有被引用过。事实上，unused 对 <code class="gatsby-code-text">originalThing</code> 的引用要求它保持活跃，因为 <code class="gatsby-code-text">someMethod</code> 与 unused 的共享封闭范围。</p>
<p>所有这些都可能导致大量的内存泄漏。当上面的代码片段一遍又一遍地运行时，您可以预期到内存使用率的上升。当垃圾收集器运行时，其大小不会缩小。一个闭包链被创建（在例子中它的根就是 <code class="gatsby-code-text">theThing</code> 变量），并且每个闭包作用域都包含对大数组的间接引用。</p>
<p>Meteor 团队发现了这个问题，<a href="https://blog.meteor.com/an-interesting-kind-of-javascript-memory-leak-8b47d2e7f156">它们有一篇很棒的文章</a>详细地描述了这个问题。</p>
<h4 id="4：超出-dom-的引用"><a href="#4%EF%BC%9A%E8%B6%85%E5%87%BA-dom-%E7%9A%84%E5%BC%95%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>4：超出 DOM 的引用</h4>
<p>有些情况下开发人员在数据结构中存储 DOM 节点。假设你想快速更新表格中几行的内容。如果在字典或数组中存储对每个 DOM 行的引用，就会产生两个对同一个 DOM 元素的引用：一个在 DOM 树中，另一个在字典中。如果你决定删除这些行，你需要记住让两个引用都无法访问。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> elements <span class="token operator">=</span> <span class="token punctuation">{</span>
    button<span class="token punctuation">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'button'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    image<span class="token punctuation">:</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'image'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">doStuff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    elements<span class="token punctuation">.</span>image<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://example.com/image_name.png'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">removeImage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// The image is a direct child of the body element.</span>
    document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'image'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// At this point, we still have a reference to #button in the</span>
    <span class="token comment">//global elements object. In other words, the button element is</span>
    <span class="token comment">//still in memory and cannot be collected by the GC.</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>在涉及 DOM 树内的内部节点或叶节点时，还有一个额外的因素需要考虑。如果你在代码中保留对表格单元格（<code class="gatsby-code-text">td</code> 标记）的引用，并决定从 DOM 中删除该表格但保留对该特定单元格的引用，则可以预见到严重的内存泄漏。你可能会认为垃圾收集器会释放除了那个单元格之外的所有东西。但情况并非如此。由于单元格是表格的子节点，并且子节点保持对父节点的引用，所以<strong>对表格单元格的这种单引用会把整个表格保存在内存中</strong>。</p>]]></description><link>https://reactjs.org/blog/2019/02/05/menory-management.html</link><guid isPermaLink="false">https://reactjs.org/blog/2019/02/05/menory-management.html</guid><pubDate>Mon, 04 Feb 2019 16:00:00 GMT</pubDate></item><item><title><![CDATA[前端资源加载优先级]]></title><description><![CDATA[<p>浏览器里并不是每一个资源加载都很重要。 </p>
<p>为了达到重要的资源先加载，浏览器有试探法，尝试对资源进行权重分配，例如CSS会在脚本和图片之前先加载。 因为浏览器在试探权重分配，所以并不总是分配的很正确，通常因为没有足够的信息，浏览器可能做出错误的决定。</p>
<p>下面介绍如何在现代浏览器中以代码的形式来调整资源加载的优先级。</p>
<h3 id="默认优先级"><a href="#%E9%BB%98%E8%AE%A4%E4%BC%98%E5%85%88%E7%BA%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>默认优先级</h3>
<p>如前所述，浏览器根据它们的重要程度为不同类型的资源分配不同的相对优先级。 像页面的<code class="gatsby-code-text">&lt;head&gt;</code>中的<code class="gatsby-code-text">&lt;script&gt;</code>标记将以”高优先级(High priority)“(CSS是”最高优先级(Highest priority)“)加载到Chrome中，但如果它具有<code class="gatsby-code-text">async</code>属性，则该优先级将更改为”低(Low priority)“（意味着它可以加载并异步运行）。在查看站点的加载性能时，优先级变得很重要。 除了测量和分析关键渲染路径的常用技术之外，了解Chrome对每种资源的优先级分配也很有用。您可以在Chrome开发者工具的”网络”面板中找到它。 这是它的样子：</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/network-priority-3ab504487833ef302dc01c0e95f4c45b-82ec2.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 33.58885017421603%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABVklEQVQozz1R2bKQMBTj/39MP8AHde5FoCzd91IWZ+JpHX3I9JDkkAaGkhOCdxD8wLFvkIJDEPZt7fNOnFaywzuLGBzB045H5Cs8GxGtQ02xv2f49rHixywxcY9fh+/nIiPNFqtK9OzAVMT3iXee+wvjprGZjHFkEKvA123CF0aXchXDx7yjYd7JpDxcvuHLAx1Knw8dIX2BdBmx/u4a44b0E/M4wRwCW4iYKDScL4bPcQRjDM45lJzxPjee+8JZCq6rdj7GSNV30p7Oe6p21Qoxj8iK4yE+p7+7w8/PBfPKIU2ATxUhX/00PsO2W8YTyiXyiK413z/vsTBYuqGjWRr6F+nCMM0LpFIolHxTUku77xtaGyRKde3jxwQpFd737ZrSGpn8YplQnUGlRoZ8bXfYqIoQgpYTKtU4z7NDUYgnU0MIAdba/3qbW5imymVfcBJvyde0P7UoEcF1kFZkAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="network priority"
        title=""
        src="/static/network-priority-3ab504487833ef302dc01c0e95f4c45b-acf85.png"
        srcset="/static/network-priority-3ab504487833ef302dc01c0e95f4c45b-c1418.png 210w,
/static/network-priority-3ab504487833ef302dc01c0e95f4c45b-5d5d8.png 420w,
/static/network-priority-3ab504487833ef302dc01c0e95f4c45b-acf85.png 840w,
/static/network-priority-3ab504487833ef302dc01c0e95f4c45b-de0cd.png 1260w,
/static/network-priority-3ab504487833ef302dc01c0e95f4c45b-bd6c2.png 1680w,
/static/network-priority-3ab504487833ef302dc01c0e95f4c45b-70dc4.png 2520w,
/static/network-priority-3ab504487833ef302dc01c0e95f4c45b-82ec2.png 2870w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<blockquote>
<p>Chrome开发者工具中网络面板中的优先级,如果没有看到该列，您可以通过右键单击列标题来启用“优先级”列 </p>
</blockquote>
<p>优先级使您了解浏览器处理每个资源的相对重要性。 请记住，微妙的差异足以让浏览器分配不同的优先级; 例如，作为初始渲染的一部分的图像优先于高于从屏幕外开始的图像。</p>
<p>如果您发现资源加载的优先级与您想要的不同，您会怎么做？本文展示了三种不同的声明性解决方案，它们都是相对较新的<code class="gatsby-code-text">&lt;link&gt;</code>类型。 如果您的资源对用户体验至关重要，但加载的优先级过低，则可以尝试通过以下两种方式之一进行修复：<code class="gatsby-code-text">预加载(Preload)</code>或<code class="gatsby-code-text">预链接(Preconnect)</code>。 另一方面，如果您希望浏览器在完成处理其他内容时获取某些资源，请尝试<code class="gatsby-code-text">预获取(Prefetch)</code>。</p>
<h3 id="预加载preload"><a href="#%E9%A2%84%E5%8A%A0%E8%BD%BDpreload" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>预加载(Preload)</h3>
<p><code class="gatsby-code-text">&lt;link rel=&quot;preload&quot;&gt;</code>通知浏览器接下来可能用到的资源，并尽快开始加载资源。 你可以像这样使用：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-html"><code class="gatsby-code-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>script<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>super-important.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>style<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>critical.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre>
      </div>
<p>如你期望，“as”告诉浏览器资源类型。你要通过<code class="gatsby-code-text">as</code>设置正确的类型，否则浏览器不会使用预加载的资源。 </p>
<p>浏览器在空闲的时候会去加载相应的资源，并在合适的时候使用它们。</p>
<p><code class="gatsby-code-text">&lt;link rel=&quot;preload&quot;&gt;</code>是浏览器的强制性指令，preload后浏览器就必定去预加载相应的资源。使用时需要仔细测试，确保您不会因为使用它而意外导致任何资源加载2次。使用<code class="gatsby-code-text">&lt;link rel=&quot;preload&quot;&gt;</code>获取但在3秒内未被当前页面使用的资源将在Chrome开发者工具的控制台中触发警告，因此请务必留意这些！</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/preload-warn-f48470be88108b285548d14b675ad70d-bfb40.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 18.72015281757402%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA6UlEQVQY0z2O626CQBCFef8HqoltjGmT/jBtgnJRKMplKewS0ICXRFn8CrR2kpM5M2fOzBhKKZJEkGc5YRixC0Oqak/TNNR1/Zd/MfAHjsfjPx+0oVaqwGiamtP5xBBaa+73juv1yuVy7heXtO1t7Gvd0nV6PCJlPmqHw6Gfv/OIon/OqKSLSpdU0qHI12TCQWZr0thCRCv8zQIRr0gTi1J5lLmNFCZit6BSLvLbJQw+e5/NuUkwAntK4Dwjgjd26xmb5YQva0rozYn81157YevOENt3NuYEz3wi9ucjBq8UHyP2hUV3S/kBYHMnYhMdaAAAAAAASUVORK5CYII='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="preload warn"
        title=""
        src="/static/preload-warn-f48470be88108b285548d14b675ad70d-acf85.png"
        srcset="/static/preload-warn-f48470be88108b285548d14b675ad70d-c1418.png 210w,
/static/preload-warn-f48470be88108b285548d14b675ad70d-5d5d8.png 420w,
/static/preload-warn-f48470be88108b285548d14b675ad70d-acf85.png 840w,
/static/preload-warn-f48470be88108b285548d14b675ad70d-de0cd.png 1260w,
/static/preload-warn-f48470be88108b285548d14b675ad70d-bd6c2.png 1680w,
/static/preload-warn-f48470be88108b285548d14b675ad70d-bfb40.png 2094w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>图中显示unused.js通过预加载进行了资源加载，但是接下来并没有使用，如果用不到的资源最好不要使用预加载。</p>
<h4 id="preload使用场景"><a href="#preload%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>preload使用场景</h4>
<h5 id="字体"><a href="#%E5%AD%97%E4%BD%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>字体</h5>
<p>字体资源是预获取的一个很好的例子</p>
<p>为了减少用户等待站点文本内容的时间，以及避免系统字体与样式中定义的字体之间应用时的闪烁，您可以在HTML中使用<code class="gatsby-code-text">&lt;link rel =&quot;preload&quot;&gt;</code>让浏览器知道样式文件中需要加载的字体资源。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-html"><code class="gatsby-code-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>font<span class="token punctuation">"</span></span> <span class="token attr-name">crossorigin</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>crossorigin<span class="token punctuation">"</span></span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>font/woff2<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>myfont.woff2<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre>
      </div>
<p>请注意，使用<code class="gatsby-code-text">crossorigin</code>很重要; 如果没有此属性，浏览器将忽略预加载的字体，并发起一个新的请求。 这是因为浏览器使用匿名请求加载字体，也只有使用<code class="gatsby-code-text">crossorigin</code>属性使预加载请求匿名。</p>
<blockquote>
<p>如果您使用的是CDN，例如Google字体，请确保您预加载的字体文件与CSS中的字体文件匹配，由于unicode范围，权重和字体变体，这可能很棘手。 字体也可以定期更新，如果你预加载了一个旧版本的字体，但在样式文件中使用了新版本的字符，则最终可能会下载相同字体的两个版本并浪费用户的带宽。 这种情况请考虑使用<code class="gatsby-code-text">&lt;link rel =&quot;preconnect&quot;&gt;</code>。</p>
</blockquote>
<h4 id="关键路径css和javascript"><a href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84css%E5%92%8Cjavascript" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>关键路径CSS和JavaScript</h4>
<p>在谈论页面性能时，一个有用的概念是“关键路径”。 关键路径是指在初始渲染之前必须加载的资源。 这些资源(如CSS)对于获取用户屏幕上的第一个像素至关重要。以前，建议将此内容内嵌到您的HTML中。</p>
<p>但是，在多页，服务器端呈现的场景中，这很快就会变成大量浪费的字节。 它还使版本控制变得更加困难，因为关键代码中的任何更改都会使任何内联页面无效。<code class="gatsby-code-text">&lt;link rel =&quot;preload&quot;&gt;</code>允许您保留单个文件版本控制和缓存的好处，同时为您提供尽快请求资源的机制。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-html"><code class="gatsby-code-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>script<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>super-important.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preload<span class="token punctuation">"</span></span> <span class="token attr-name">as</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>style<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>critical.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre>
      </div>
<p>预加载缺点：需要额外的往返。 这个额外的往返来自于浏览器先获取HTML，然后它才能从HTML中找出要加载的下一个资源。</p>
<p>解决额外往返的一种方法是使用<code class="gatsby-code-text">HTTP/2推送</code>，在这种情况下，您可以将关键资源附加到和发送HTML的同一连接。 这可以保证用户浏览器检索HTML和开始下载关键资源之间没有停顿时间。 但是，在使用HTTP/2推送时要小心，因为这是控制用户带宽使用的一种非常有力的方式，并且留给浏览器做决定的空间很小，例如不检索已经在缓存中的文件！</p>
<h3 id="预连接preconnect"><a href="#%E9%A2%84%E8%BF%9E%E6%8E%A5preconnect" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>预连接(Preconnect)</h3>
<p><code class="gatsby-code-text">&lt;link rel =&quot;preconnect&quot;&gt;</code>通知浏览器您的页面打算与另一个来源建立连接，并且您希望该过程尽快启动。</p>
<p>建立连接通常需要在慢速网络中占用大量时间，特别是在涉及安全连接时，因为它可能涉及DNS查找，重定向以及到处理用户请求的最终服务器的多次往返。 提前处理所有这些可以使您的应用程序对用户感觉更加快捷，而不会对带宽的使用产生负面影响。 建立连接的大部分时间都花在等待上，而不是交换数据。</p>
<p>告知浏览器您的意图就像在页面中添加链接标记一样简单：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-html"><code class="gatsby-code-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>preconnect<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://example.com<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre>
      </div>
<p>在这种情况下，我们让浏览器知道我们打算连接到”example.com”并从那里检索内容。请记住，虽然<code class="gatsby-code-text">&lt;link rel =&quot;preconnect&quot;&gt;</code>轻量，但它仍然占用宝贵的CPU时间，特别是在安全连接上。 如果在10秒内没有使用连接，这会特别糟糕，因为浏览器会关闭它，浪费所有早期的连接工作。</p>
<p>一般情况下，尝试使用<link rel ="preload">，因为它是一个更全面的性能优化方案，其它更复杂的情况，你需要使用<link rel ="preconnect">。</p>
<blockquote>
<p>注意：</p>
<p>实际上还有另一个与连接相关的<code class="gatsby-code-text">&lt;link&gt;</code>类型：<code class="gatsby-code-text">&lt;link rel =&quot;dns-prefetch&quot;&gt;</code>。 这仅处理DNS查找，它是<code class="gatsby-code-text">&lt;link rel =&quot;preconnect&quot;&gt;</code>的一小部分。<code class="gatsby-code-text">&lt;link rel =&quot;dns-prefetch&quot;&gt;</code>具有更广泛的浏览器支持，因此它可以作为一个很好的后备。 您可以用相同的方式使用它：<code class="gatsby-code-text">&lt;link rel =&quot;dns-prefetch&quot; href =&quot;https://example.com&quot;&gt;</code></p>
</blockquote>
<h4 id="preconnect用例cdn"><a href="#preconnect%E7%94%A8%E4%BE%8Bcdn" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preconnect用例CDN</h4>
<p>知道资源会从哪里来，但不知道最终获取什么资源。有时您知道将从给定的CDN中检索资源，但并不知道完整路径。 根据用户的使用情况或其它运行时特征，从CDN上获取一个或多个资源。</p>
<p>在这种情况下，如果您要获取的资源很重要，您可能希望通过预连接到服务器来节省尽可能多的时间。 浏览器不会在需要之前开始提取文件（也就是说，一旦请求以某种方式从您的页面发出），但至少它可以提前处理连接，从而使用户无需等待几次往返。</p>
<h4 id="preconnect-流媒体"><a href="#preconnect-%E6%B5%81%E5%AA%92%E4%BD%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Preconnect 流媒体</h4>
<p>流媒体不同来源的流媒体，您可能希望在连接阶段节省一些时间但不一定立即开始获取内容。根据页面处理流内容的方式，您可能需要等到脚本加载完毕并做好准备后才处理流。 一旦准备加载资源，预连接可帮助您缩短单次往返的等待时间。</p>
<h3 id="预获取prefetch"><a href="#%E9%A2%84%E8%8E%B7%E5%8F%96prefetch" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>预获取(Prefetch)</h3>
<p>它通过向浏览器通知将来需要的资源来加速页面的后续展现，例如，如果用户采取了我们期望的操作，则我们可以提前加载稍后可能需要的东西。 </p>
<p>当前页面加载并且有可用带宽时，这些资源在Chrome中以最低优先级获取。这意味着预获取最适合提前做好用户下一步可能做的事情的准备，例如检索结果列表中的第一个产品详细信息页面，或检索分页内容中的下一页。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prefetch<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>page-2.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre>
      </div>
<p>但请记住，预取不会递归地起作用。 在上面的示例中, 除非您明确预获取page-2.html中的内容，否则浏览器不会提前下载page-2.html所需的任何资源。</p>
<h3 id="预获取prefetch不会覆盖"><a href="#%E9%A2%84%E8%8E%B7%E5%8F%96prefetch%E4%B8%8D%E4%BC%9A%E8%A6%86%E7%9B%96" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>预获取(Prefetch)不会覆盖</h3>
<p>请务必注意，不能使用<code class="gatsby-code-text">&lt;link rel =&quot;prefetch&quot;&gt;</code>作为降低现有资源优先级的方法。 在下面的HTML中，您可能认为在预取中声明<code class="gatsby-code-text">optional.css</code>会降低后续<code class="gatsby-code-text">&lt;link rel =&quot;stylesheet&quot;&gt;</code>的优先级：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-html"><code class="gatsby-code-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>prefetch<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>optional.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>optional.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
    Hello!
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre>
      </div>
<p>事情上，这会导致样式表被加载两次（尽管第二个可能命中缓存），一次是默认的最高优先级，一次是最低优先级：</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/prefetch-warn-259ac63e9dc81f1988d3c134da0eb2e0-6fd6f.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 15.087719298245613%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAt0lEQVQI1x2N0U6EMBRE+f/f8S98MsboanTjQoFCS+G2TbvALse6DyeZnMlkqlZbJK7kDeL1TtoOnCTawTG6gPOZ3swPF9KOtlJcwsyRcRLUMNP0luAj1/WgqjvD88uJWi9IOih71Cg0w8JvO/FdD5x+FO3oKb9cesdZmYLl9ePM29eFT7Py9J5pTKbyImitEVm47WthI8ZACL68CpO1dF2HL/39thfnH/l/Z61hcRM5Z5SLtDbwB6bg4qsLSnVMAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="prefetch不会覆盖"
        title=""
        src="/static/prefetch-warn-259ac63e9dc81f1988d3c134da0eb2e0-acf85.png"
        srcset="/static/prefetch-warn-259ac63e9dc81f1988d3c134da0eb2e0-c1418.png 210w,
/static/prefetch-warn-259ac63e9dc81f1988d3c134da0eb2e0-5d5d8.png 420w,
/static/prefetch-warn-259ac63e9dc81f1988d3c134da0eb2e0-acf85.png 840w,
/static/prefetch-warn-259ac63e9dc81f1988d3c134da0eb2e0-de0cd.png 1260w,
/static/prefetch-warn-259ac63e9dc81f1988d3c134da0eb2e0-bd6c2.png 1680w,
/static/prefetch-warn-259ac63e9dc81f1988d3c134da0eb2e0-6fd6f.png 1710w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>资源多次加载对用户来说是不好的。 在这种情况下，他们不仅要等待渲染阻止CSS，而且还可能通过两次下载文件来浪费他们的带宽。务必彻底分析您的网络请求，并留意任何相同资源的多次加载！</p>
<p><strong>什么时候该用<code class="gatsby-code-text">&lt;link rel=”preload”&gt;</code>？什么时候又该用<code class="gatsby-code-text">&lt;link rel=”prefetch”&gt;</code> ?</strong></p>
<p><strong>建议：对于当前页面很有必要的资源使用<code class="gatsby-code-text">preload</code>，对于可能在将来的页面中使用的资源使用<code class="gatsby-code-text">prefetch</code>。</strong></p>]]></description><link>https://reactjs.org/blog/2019/01/12/load-priority.html</link><guid isPermaLink="false">https://reactjs.org/blog/2019/01/12/load-priority.html</guid><pubDate>Fri, 11 Jan 2019 16:00:00 GMT</pubDate></item><item><title><![CDATA[FP18：Semigroup]]></title><description><![CDATA[<p>所谓<code class="gatsby-code-text">Semigroup</code>(半群)，其实就是含有concat方法的数据类型，典型的如字符串和数组，看代码：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> resStr <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span> 
<span class="token comment">// => 'abc'</span>

<span class="token keyword">const</span> resArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// => [1,2,3,4,5,6]</span></code></pre>
      </div>
<p>实际上，我们还可以发现一个规律<code class="gatsby-code-text">Semigroup</code>是可以随意的合并操作的，什么意思呢？</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> resStr <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// => 'abc'</span>

<span class="token keyword">const</span> resArr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment">// => [1,2,3,4,5,6]</span></code></pre>
      </div>
<p>无论前后的顺序如何，或者无论怎么组合，得到的结果是一致的。
完全类似于数据的加法运算：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span> 
<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span>
<span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>但是我们却不能直接使用<code class="gatsby-code-text">1.concat(2).concat(3)</code>这样的代码，因为number并没有实现<code class="gatsby-code-text">concat</code>方法，但是我们可以自己简单实现一个Sum的<code class="gatsby-code-text">Semigroup</code>。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Sum</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> y <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token function">Sum</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token template-string"><span class="token string">`Sum(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
Sum<span class="token punctuation">.</span><span class="token function-variable function">empty</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>现在就可以直接这样使用Sum了：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> res1 <span class="token operator">=</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>Sum<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// => Sum(6)</span>
<span class="token keyword">const</span> res2 <span class="token operator">=</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// => Sum(6)</span></code></pre>
      </div>
<p>Sum的使用场景不是很多，仅仅是为了学习而建立的，下面看几个使用场景比较多的<code class="gatsby-code-text">Semigroup</code></p>
<ul>
<li>
<p>All:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span>  <span class="token comment">// true</span>
<span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">false</span> <span class="token comment">// false</span>
<span class="token punctuation">{</span>
<span class="token keyword">const</span> <span class="token function-variable function">All</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> y <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token function">All</span><span class="token punctuation">(</span>x <span class="token operator">&amp;&amp;</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token template-string"><span class="token string">`All(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

All<span class="token punctuation">.</span><span class="token function-variable function">empty</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">All</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">All</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">All</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>All<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
      </div>
</li>
<li>
<p>First:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token punctuation">{</span>
<span class="token keyword">const</span> <span class="token function-variable function">First</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> _ <span class="token operator">=></span>
        <span class="token function">First</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token template-string"><span class="token string">`First(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">First</span><span class="token punctuation">(</span><span class="token string">'bob'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">First</span><span class="token punctuation">(</span><span class="token string">'smith'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
      </div>
</li>
<li>
<p>Max &#x26; Min</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token punctuation">{</span>
<span class="token keyword">const</span> <span class="token function-variable function">Max</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> y <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token function">Max</span><span class="token punctuation">(</span>x <span class="token operator">></span> y <span class="token operator">?</span> x <span class="token punctuation">:</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token template-string"><span class="token string">`Max(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

Max<span class="token punctuation">.</span><span class="token function-variable function">empty</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Max</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> <span class="token function-variable function">Min</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> y <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token function">Min</span><span class="token punctuation">(</span>x <span class="token operator">&lt;</span> y <span class="token operator">?</span> x <span class="token punctuation">:</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token template-string"><span class="token string">`Min(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

Min<span class="token punctuation">.</span><span class="token function-variable function">empty</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Min</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span></code></pre>
      </div>
</li>
<li>
<p>Either</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Right</span> <span class="token operator">=</span> x <span class="token operator">=></span>
<span class="token punctuation">(</span><span class="token punctuation">{</span>
    chain<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    ap<span class="token punctuation">:</span> other <span class="token operator">=></span> other<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    traverse<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token keyword">of</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Right<span class="token punctuation">)</span><span class="token punctuation">,</span>
    map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Right</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    fold<span class="token punctuation">:</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> o <span class="token operator">=></span>
        o<span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>_ <span class="token operator">=></span> <span class="token function">Right</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
            y <span class="token operator">=></span> <span class="token function">Right</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Right(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token function-variable function">Left</span> <span class="token operator">=</span> x <span class="token operator">=></span>
<span class="token punctuation">(</span><span class="token punctuation">{</span>
    chain<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Left</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    ap<span class="token punctuation">:</span> other <span class="token operator">=></span> <span class="token function">Left</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    traverse<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token keyword">of</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">of</span><span class="token punctuation">(</span><span class="token function">Left</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Left</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    fold<span class="token punctuation">:</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> o <span class="token operator">=></span>
        o<span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>_ <span class="token operator">=></span> <span class="token function">Left</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
            y <span class="token operator">=></span> o<span class="token punctuation">)</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Left(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token function-variable function">fromNullable</span> <span class="token operator">=</span> x <span class="token operator">=></span>
x <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token function">Right</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">Left</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> <span class="token function-variable function">tryCatch</span> <span class="token operator">=</span> f <span class="token operator">=></span> <span class="token punctuation">{</span>
<span class="token keyword">try</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">Right</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">Left</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// List from https://github.com/DrBoolean/immutable-ext</span>
<span class="token keyword">const</span> stats <span class="token operator">=</span> List<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token punctuation">{</span>page<span class="token punctuation">:</span><span class="token string">'home'</span><span class="token punctuation">,</span> view<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token punctuation">{</span>page<span class="token punctuation">:</span><span class="token string">'about'</span><span class="token punctuation">,</span> view<span class="token punctuation">:</span> <span class="token number">40</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token punctuation">{</span>page<span class="token punctuation">:</span><span class="token string">'blog'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
state<span class="token punctuation">.</span><span class="token function">foldMap</span><span class="token punctuation">(</span>x <span class="token operator">=></span> 
    <span class="token function">fromNullable</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>views<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Sum<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">Right</span><span class="token punctuation">(</span>Sum<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
      </div>
</li>
</ul>]]></description><link>https://reactjs.org/blog/2018/12/13/FP18-Semigroup.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/12/13/FP18-Semigroup.html</guid><pubDate>Wed, 12 Dec 2018 16:00:00 GMT</pubDate></item><item><title><![CDATA[FP17：Transform Naturally]]></title><description><![CDATA[<h3 id="令人生厌的嵌套"><a href="#%E4%BB%A4%E4%BA%BA%E7%94%9F%E5%8E%8C%E7%9A%84%E5%B5%8C%E5%A5%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>令人生厌的嵌套</h3>
<p>我想要提出一个关于嵌套的问题。但不是那种马上会唤起老母亲整理打扫天性的那种问题，而是我们马上会在之后的章节中遇到的问题。在任何情况下，我所谓的<em>嵌套</em>是将不同的两个类型套在同一个值上，某种意义上，看上去就像一个全新的类型。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token function">Right</span><span class="token punctuation">(</span><span class="token function">Maybe</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token constant">IO</span><span class="token punctuation">(</span><span class="token function">Task</span><span class="token punctuation">(</span><span class="token constant">IO</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">[</span><span class="token function">Identity</span><span class="token punctuation">(</span><span class="token string">'bee thousand'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>现在，我们用一些精心制作的例证来说明仿佛我们已经能够摆脱这些常见的嵌套情形。但是实际上我们编码的时候，不同的类型就像耳机线一样乱成一团，仿佛一种恶魔召唤的邪恶产物。如果我们编码的时候不是一丝不苟地组织正在使用的类型，最后代码会比猫咪咖啡厅的披头族更加难以理解。</p>
<h3 id="一场情景喜剧"><a href="#%E4%B8%80%E5%9C%BA%E6%83%85%E6%99%AF%E5%96%9C%E5%89%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>一场情景喜剧</h3>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// getValue :: Selector -> Task Error (Maybe String)</span>
<span class="token comment">// postComment :: String -> Task Error Comment</span>
<span class="token comment">// validate :: String -> Either ValidationError String</span>

<span class="token comment">// saveComment :: () -> Task Error (Maybe (Either ValidationError (Task Error Comment)))</span>
<span class="token keyword">const</span> saveComment <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>postComment<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>validate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token string">'#comment'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>让类型声明形同虚设的坏家伙们都在这里了。容我稍微解释一下这一段代码。一开始，用<code class="gatsby-code-text">getValue(&#39;#comment&#39;)</code>获取用户输入，这是一个<code class="gatsby-code-text">action</code>，从一个<code class="gatsby-code-text">element</code>中获取文本。但是可能会因为字符串值不存在而获取失败，从而返回<code class="gatsby-code-text">Task Error(Maybe String)</code>。在这之后，我们需要<code class="gatsby-code-text">map</code>所有<code class="gatsby-code-text">Task</code>和<code class="gatsby-code-text">Maybe</code>传递文本到<code class="gatsby-code-text">validate</code>。最后，我们不是得到<code class="gatsby-code-text">ValiadtionError</code>或者想要的<code class="gatsby-code-text">String</code>。然后，从过层层 map，把当前<code class="gatsby-code-text">Task Error(Maybe(Either ValidationError String))</code>中的<code class="gatsby-code-text">String</code>传入<code class="gatsby-code-text">postComment</code>，最后返回<code class="gatsby-code-text">Task</code>的结果。
简直乱得骇人。一大堆抽象类型乱得像一幅业余表现主义的烂作，还混杂着波洛克式的多态，蒙德里安风的大统一。对于这种常见的情况，有许多解决方法。把这些类型编好弄成一个巨大的容器，分类后再<code class="gatsby-code-text">join</code>，将其同化，解构，等等。而重点，就在于通过 <em>Natural Transformations</em> 将他们同化。</p>
<h3 id="全都很自然"><a href="#%E5%85%A8%E9%83%BD%E5%BE%88%E8%87%AA%E7%84%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>全都很自然</h3>
<p><em>Natural Transformations</em>是“functor 之间的态射”，就是，一个操作容器本身的函数。类型上来说，它是个函数<code class="gatsby-code-text">(Functor f, Functor g) =&gt; f a -&gt; g a</code>。让这个函数特殊的是，在任何情况下，都不能得知 functor 中的内容。就像两个党派交换机密文件，都会把东西封在马尼拉纸信封里，戳上“最高机密”。这是一个结构上的操作。functor 外壳的变化。形式上，<em>Natural Transformations</em> 作用于如下功能：</p>
<img width=600 src="images/natural_transformation.png" alt="natural transformation diagram" />
<p>或者代码:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// nt :: (Functor f, Functor g) => f a -> g a</span>
<span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> nt<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">compose</span><span class="token punctuation">(</span>nt<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>两者都体现了同样的东西：我们可以先自然变换再<code class="gatsby-code-text">map</code>，或者先<code class="gatsby-code-text">map</code>再自然变换，结果都是一样的。顺便，在 <a href="ch7.md#free-as-in-theorem">free theorem</a> 中，也提到，自然变换不仅局限于函数和类型（以及 functor）。</p>
<h3 id="有原则的类型转换"><a href="#%E6%9C%89%E5%8E%9F%E5%88%99%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>有原则的类型转换</h3>
<p>作为程序员，我们对类型转换十分熟悉。我们经常把<code class="gatsby-code-text">String</code>转换成<code class="gatsby-code-text">Boolean</code>，或者<code class="gatsby-code-text">Integer</code> 转换成<code class="gatsby-code-text">Float</code>（虽然<code class="gatsby-code-text">JavaScript</code>只有<code class="gatsby-code-text">Number</code>）。这些类型之间的区别很简单，这些类型都是一些代数容器，我们手头有一些可以运用的理论。</p>
<p>以下是一些例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// idToMaybe :: Identity a -> Maybe a</span>
<span class="token keyword">const</span> <span class="token function-variable function">idToMaybe</span> <span class="token operator">=</span> x <span class="token operator">=></span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>$value<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// idToIO :: Identity a -> IO a</span>
<span class="token keyword">const</span> <span class="token function-variable function">idToIO</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>$value<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// eitherToTask :: Either a b -> Task a b</span>
<span class="token keyword">const</span> eitherToTask <span class="token operator">=</span> <span class="token function">either</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span>rejected<span class="token punctuation">,</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// ioToTask :: IO a -> Task () a</span>
<span class="token keyword">const</span> <span class="token function-variable function">ioToTask</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">unsafePerform</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// maybeToTask :: Maybe a -> Task () a</span>
<span class="token keyword">const</span> <span class="token function-variable function">maybeToTask</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>isNothing <span class="token operator">?</span> Task<span class="token punctuation">.</span><span class="token function">rejected</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>$value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// arrayToMaybe :: [a] -> Maybe a</span>
<span class="token keyword">const</span> <span class="token function-variable function">arrayToMaybe</span> <span class="token operator">=</span> x <span class="token operator">=></span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>看到了吗？这些只是从一个 functor 换到了另一个。在转换过程中的数据丢失是被允许的，只要要被<code class="gatsby-code-text">map</code>的数据在转换（shape shift shuffle）中不会消失即可。这就是重点，<code class="gatsby-code-text">map</code>必须以定义执行，就算在转换之后。</p>
<p>从另一个角度来看，转换的是某个作用（effects）。由此可以认为，<code class="gatsby-code-text">ioToTask</code>就是从同步到异步的转换，和<code class="gatsby-code-text">arrayToMaybe</code>是从非确定性到可能失败。要注意的是，在<code class="gatsby-code-text">JavaScript</code> 里，并不能把异步变到同步，无法实现<code class="gatsby-code-text">taskToIO</code>方法，那是个”超自然”变换。</p>
<h3 id="方法狂-feature-envy"><a href="#%E6%96%B9%E6%B3%95%E7%8B%82-feature-envy" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>方法狂 Feature Envy</h3>
<p>假设要使用一些其他类型的方法（feature），比如对一个<code class="gatsby-code-text">List</code>进行<code class="gatsby-code-text">sortBy</code>。<em>Natural Transformations</em> 提供了变换为目标类型的巧妙方式，只要该类型支持<code class="gatsby-code-text">map</code>操作。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// arrayToList :: [a] -> List a</span>
<span class="token keyword">const</span> arrayToList <span class="token operator">=</span> List<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> doListyThings <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">sortBy</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">filter</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">,</span> arrayToList<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> doListyThings_ <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">sortBy</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">filter</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> arrayToList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// law applied</span></code></pre>
      </div>
<p>捏一把鼻子，颠三下魔杖，放进<code class="gatsby-code-text">arrayToList</code>，当当当当，<code class="gatsby-code-text">[a]</code>变成了<code class="gatsby-code-text">List a</code>，甚至还可以对其<code class="gatsby-code-text">sortBy</code>。</p>
<p>此外，如<code class="gatsby-code-text">doListyThings_</code>所示，将映射操作<code class="gatsby-code-text">map(f)</code>移到 <em>Natural Transformations</em> 的左边，更加容易实现函数的优化或者复合。</p>
<h3 id="同构的-javascript-isomorphic-javascript"><a href="#%E5%90%8C%E6%9E%84%E7%9A%84-javascript-isomorphic-javascript" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同构的 JavaScript Isomorphic JavaScript</h3>
<p>当把一个值前后怎么转换都不会丢失任何数据时，可称之为 <em>同构 Isomorphic</em> 。看上去挺高大上，不过就是“保持相同的数据”而已。如果两个类型在 <em>Natural Transformations</em> 中既可以<code class="gatsby-code-text">to</code>也可以<code class="gatsby-code-text">from</code> ，就被称之为是 <em>同构 Isomorphic</em> ，证明如下：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// promiseToTask :: Promise a b -> Task a b</span>
<span class="token keyword">const</span> <span class="token function-variable function">promiseToTask</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span> <span class="token operator">=></span> x<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>reject<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// taskToPromise :: Task a b -> Promise a b</span>
<span class="token keyword">const</span> <span class="token function-variable function">taskToPromise</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span> x<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> x <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'ring'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">taskToPromise</span><span class="token punctuation">(</span><span class="token function">promiseToTask</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> x<span class="token punctuation">;</span>

<span class="token keyword">const</span> y <span class="token operator">=</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">'rabbit'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">promiseToTask</span><span class="token punctuation">(</span><span class="token function">taskToPromise</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> y<span class="token punctuation">;</span></code></pre>
      </div>
<p>证毕。</p>
<p><code class="gatsby-code-text">Promise</code>与<code class="gatsby-code-text">Task</code>是 <em>同构 Isomorphic</em> 。也可以实现方法<code class="gatsby-code-text">listToArray</code>使之与<code class="gatsby-code-text">arrayToList</code>构成  <em>同构Isomorphism</em>。反之，与 <code class="gatsby-code-text">arrayToMaybe</code>无法 <em>同构 Isomorphism</em>，因为转换时有数据丢失。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// maybeToArray :: Maybe a -> [a]</span>
<span class="token keyword">const</span> <span class="token function-variable function">maybeToArray</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>isNothing <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">[</span>x<span class="token punctuation">.</span>$value<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// arrayToMaybe :: [a] -> Maybe a</span>
<span class="token keyword">const</span> <span class="token function-variable function">arrayToMaybe</span> <span class="token operator">=</span> x <span class="token operator">=></span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'elvis costello'</span><span class="token punctuation">,</span> <span class="token string">'the attractions'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment">// 不 isomorphic</span>
<span class="token function">maybeToArray</span><span class="token punctuation">(</span><span class="token function">arrayToMaybe</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// ['elvis costello']</span>

<span class="token comment">// 但是是一个 natural transformation</span>
<span class="token function">compose</span><span class="token punctuation">(</span>arrayToMaybe<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'elvis'</span><span class="token punctuation">,</span> <span class="token string">'lou'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Just('lou costello')</span>
<span class="token comment">// ==</span>
<span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'elvis'</span><span class="token punctuation">,</span> <span class="token string">'lou'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arrayToMaybe<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Just('lou costello')</span></code></pre>
      </div>
<p>这就是 <em>Natural Transformations</em>，然而，因为两边的<code class="gatsby-code-text">map</code>都得到相同的结果。行文到本章的一半，似乎已经将 <em>Isomorphic</em> 说的差不多了，但是可别被这些表象所迷惑，真正的 <em>Isomorphic</em> 比我们想象的要广泛，有用的多。话不多说，让我们继续。</p>
<h3 id="更加宽泛的定义"><a href="#%E6%9B%B4%E5%8A%A0%E5%AE%BD%E6%B3%9B%E7%9A%84%E5%AE%9A%E4%B9%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>更加宽泛的定义</h3>
<p>这些结构函数绝不仅仅局限于类型转换。
以下是一些不同的例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">reverse <span class="token punctuation">:</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span>

join <span class="token punctuation">:</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>Monad m<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">m</span> <span class="token punctuation">(</span>m a<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> m a

head <span class="token punctuation">:</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">></span> a

<span class="token keyword">of</span> <span class="token punctuation">:</span><span class="token punctuation">:</span> a <span class="token operator">-</span><span class="token operator">></span> f a</code></pre>
      </div>
<p>Natural Transformations 的法则同样适用于上述方法。其中可能让你有点疑惑的是，<code class="gatsby-code-text">head :: [a] -&gt; a</code>可以被看做成<code class="gatsby-code-text">head :: [a] -&gt; Identity a</code>。在其中的任何地方，都可以插入<code class="gatsby-code-text">Identity</code>，因为<code class="gatsby-code-text">a</code>与<code class="gatsby-code-text">Identity a</code>为 Isomorphic。（看，我说过 <em>Isomorphic</em> 用途很广泛吧）</p>
<h3 id="实现单层嵌套的方法"><a href="#%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%B1%82%E5%B5%8C%E5%A5%97%E7%9A%84%E6%96%B9%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实现单层嵌套的方法</h3>
<p>回到之前的场景。在其中试试 <em>Natural Transformations</em>，使调用中的各个类型统一化，从而可以将函数<code class="gatsby-code-text">join</code>起来。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// getValue :: Selector -> Task Error (Maybe String)</span>
<span class="token comment">// postComment :: String -> Task Error Comment</span>
<span class="token comment">// validate :: String -> Either ValidationError String</span>

<span class="token comment">// saveComment :: () -> Task Error Comment</span>
<span class="token keyword">const</span> saveComment <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token function">chain</span><span class="token punctuation">(</span>postComment<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">chain</span><span class="token punctuation">(</span>eitherToTask<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span>validate<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">chain</span><span class="token punctuation">(</span>maybeToTask<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token string">'#comment'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>这里具体的操作仅仅加入了<code class="gatsby-code-text">chain(maybeToTask)</code>和<code class="gatsby-code-text">chain(eigherToTack)</code>。都是同样的效果。在<code class="gatsby-code-text">join</code>时很自然的将<code class="gatsby-code-text">Task</code>的 functor 转换到另一个<code class="gatsby-code-text">Task</code>的 functor。就像窗边的尖刺驱鸟器，从源头扼杀了嵌套。就像他们巴黎（city of the light）人说的：“Mieux vaut prévenir que guérir” - 花一英镑去治疗不如花一盎司用于预防。</p>
<h3 id="小结"><a href="#%E5%B0%8F%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结</h3>
<p><em>Natural Transformations</em>是操作 functor 的方法。在范畴学中是非常重要的概念，特别是采用多种抽象化机制时，就会用的更多。上述例子，仅仅局限于几个具体的应用中。如上文所言，只要转换类型时,确保可组合性，即可以实现所需要的不同作用 effects。同时可以解决嵌套问题，虽然会将类型同化到最低的共同母类（lowest common denominator），在实际应用中，一般是作用最易变的函子（通常是<code class="gatsby-code-text">Task</code> ）（functor with most volatile effects）。</p>
<p>这种连续而冗长的类型是实现的代价 - 从以太中召唤而来。当然，隐式作用（implicit effects）更有潜在风险，所以也算是合理的方案。不过,如果想归并大量类型，还需要更多的工具。之后，我们将通过 <em>Traverable</em> 讨论重组类型。</p>]]></description><link>https://reactjs.org/blog/2018/12/11/FP17-Transform-Naturally.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/12/11/FP17-Transform-Naturally.html</guid><pubDate>Mon, 10 Dec 2018 16:00:00 GMT</pubDate></item><item><title><![CDATA[How JavaScript Work: 引擎、运行时、调用栈概述]]></title><description><![CDATA[<ul>
<li>
<p><a href="https://juejin.im/post/5c090bd9e51d45242973cad2">JavaScript 如何工作系列: 引擎、运行时、调用栈概述</a></p>
</li>
<li>
<p><a href="https://juejin.im/post/5a102e656fb9a044fd1158c6">JavaScript 如何工作：在 V8 引擎里 5 个优化代码的技巧</a></p>
</li>
<li>
<p><a href="https://juejin.im/post/5a2559ae6fb9a044fe4634ba">JavaScript 工作原理：内存管理 + 处理常见的4种内存泄漏</a></p>
</li>
<li>
<p><a href="https://juejin.im/post/5a221d35f265da43356291cc">JavaScript 如何工作的: 事件循环和异步编程的崛起 + 5 个关于如何使用 async/await 编写更好的技巧</a></p>
</li>
<li>
<p><a href="https://juejin.im/entry/5a731a955188257a6d634f3e">Event Loop</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/55511602?utm_source=wechat_session&#x26;utm_medium=social&#x26;utm_oi=880452006622420992">Event Loop in Node</a></p>
</li>
<li>
<p><a href="https://github.com/xitu/gold-miner/blob/master/TODO/how-javascript-works-deep-dive-into-websockets-and-http-2-with-sse-how-to-pick-the-right-path.md">JavaScript 是如何工作的：深入剖析 WebSockets 和拥有 SSE 技术 的 HTTP/2，以及如何在二者中做出正确的选择</a></p>
</li>
<li>
<p><a href="https://github.com/xitu/gold-miner/blob/master/TODO1/how-javascript-works-the-rendering-engine-and-tips-to-optimize-its-performance.md">JavaScript 是如何工作的：渲染引擎和性能优化技巧</a></p>
</li>
</ul>
<p>JavaScript 越来越流行，在前端、后端、hybrid apps、嵌入式设备开发等方向上都有它活跃的身影。
这篇文章是 How JavaScript Works 系列的开篇，该系列的文章旨在深入挖掘 JavaScript 及其实际的工作原理。我们认为了解 JavaScript 的构建块及其共同作用，可以帮助我们写出更优雅、更高效的代码和应用。
正如 GitHut stats 所展示的一样，JavaScript 各方面的统计数据都是棒棒哒，顶多也就在个别统计项上落后了其他语言那么一丢丢。</p>
<p>如果项目深度依赖 JavaScript，这意味着开发者需要对底层有极其深入的了解，并利用语言和生态提供的一切东西来构建出色的应用。</p>
<p>然而，事实上，很多开发者虽然每天都在使用 JavaScript，却对其背后发生的事情一无所知。</p>
<h3 id="概述"><a href="#%E6%A6%82%E8%BF%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>概述</h3>
<p>几乎每个人都听说过 V8 引擎的概念，大多数人也都知道 JavaScript 是一门单线程语言或者知道它是基于回调队列的。</p>
<p>在这篇文章中，我们将详细的介绍这些概念并且解释 JavaScript 实际的运行方式，通过对这些细节的了解，你可以写出更好、无阻塞的应用。</p>
<p>如果你是一名 JavaScript 新手，这篇文章将帮助你理解为什么 JavaScript 和其它语言对比起来显得那么”奇怪”。</p>
<p>如果你是一名老司机，希望能够为你带来一些对 JavaScript 运行时的新思考。</p>
<h3 id="javascript-引擎"><a href="#javascript-%E5%BC%95%E6%93%8E" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JavaScript 引擎</h3>
<p>说起 JavaScript 引擎，不得不提的就是 Google 的 V8 引擎，Chrome 和 Nodejs 内部也是使用的 V8。这里有一个简单的视图：</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/V8-4d5a7011a294a4858925defb02b2579c-e663a.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 75.22211253701876%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABrklEQVQ4y5WSS0/CQBDH/Uwe/ARe/Goe8eTVeJILSqxNxVewkdDaIKU2aqKGVmwLEW0oLH3wd3fRimh5bDLZ2Z2Z38zuzApmrNFoNN6/ZPIua63Mg0XkBaOBChAVcdhObVngGcCYVxV396Adb+Byfx3hR+nHNg84mZXrScT1wN3FTm4N25urIF1xbKe2Sd9M4G+H8U78Kt6tLfh2DsOekdqmC/j3yd+GMAwxGBAQQqie/Kqg3+9zQUaT/lQYxzEuzs8gCgdURBwdCgiCHvpUJEmCIAgoFAool8uIoii7wu/Ltufi9ELGgwN0B28w7g2YtyZarRYUReE+SZJA0zQ0m830PBNYrijwPoCztoSSKeHx7hGvzivq9Xrq22g0FgO6joPrhg5Yz4BWg93pwKDBnufxZ7LdoT6VSgW2bS8AdF0oqjru8pDAsl9gGAYHybKMDk3A9KWAev0GJ1d0Bof0H9/aKVCliYIggO/7/A8ty5oPZIGieIQb3cbTk0UbUeVAliifz3MQa06xWOSNmgtko8AApqnTv9N5I9jcsZlkMHau1Wq8KWzEFhrsZdZ0zCfxunmcDBbmwQAAAABJRU5ErkJggg=='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="V8"
        title=""
        src="/static/V8-4d5a7011a294a4858925defb02b2579c-acf85.png"
        srcset="/static/V8-4d5a7011a294a4858925defb02b2579c-c1418.png 210w,
/static/V8-4d5a7011a294a4858925defb02b2579c-5d5d8.png 420w,
/static/V8-4d5a7011a294a4858925defb02b2579c-acf85.png 840w,
/static/V8-4d5a7011a294a4858925defb02b2579c-e663a.png 1013w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>就如JVM虚拟机一样，JS引擎中也有堆(Memory Heap)和栈(Call Stack)的概念。</p>
<ul>
<li>
<p>栈-用来存储方法调用的地方，以及基础数据类型(如var a = 1)也是存储在栈里面的，会随着方法调用结束而自动销毁掉(入栈—>方法调用后—>出栈)。</p>
</li>
<li>
<p>堆-JS引擎中给对象分配的内存空间是放在堆中的。如var foo = {name: ‘foo’} 那么这个foo所指向的对象是存储在堆中的。</p>
</li>
</ul>
<p>此外，JS中存在闭包的概念，对于基本类型变量如果存在与闭包当中，那么也将存储在堆中。详细可见此处1,3</p>
<p>关于闭包的情况，就涉及到Captured Variables。我们知道Local Variables是最简单的情形，是直接存储在栈中的。而Captured Variables是对于存在闭包情况和with,try catch情况的变量。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">foo</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> x<span class="token punctuation">;</span> <span class="token comment">// local variables</span>
  <span class="token keyword">var</span> y<span class="token punctuation">;</span> <span class="token comment">// captured variable, bar中引用了y</span>

  <span class="token keyword">function</span> <span class="token function">bar</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// bar 中的context会capture变量y</span>
    <span class="token function">use</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>

  <span class="token keyword">return</span> bar<span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>复制代码如上述情况，变量y存在与bar()的闭包中，因此y是captured variable，是存储在堆中的。</p>
<h3 id="runtime"><a href="#runtime" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>RunTime</h3>
<p>JS在浏览器中可以调用浏览器提供的API，如window对象，DOM相关API等。这些接口并不是由V8引擎提供的，是存在与浏览器当中的。因此简单来说，对于这些相关的外部接口，可以在运行时供JS调用，以及JS的事件循环(Event Loop)和事件队列(Callback Queue)，把这些称为RunTime。有些地方也把JS所用到的core lib核心库也看作RunTime的一部分。</p>
<p>
  <a
    class="gatsby-resp-image-link"
    href="/static/RunTime-b8b9d51ed2ef32832a63c4430eb8a323-18f60.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
  
  <span
    class="gatsby-resp-image-wrapper"
    style="position: relative; display: block; ; max-width: 840px; margin-left: auto; margin-right: auto;"
  >
    <span
      class="gatsby-resp-image-background-image"
      style="padding-bottom: 74.7534516765286%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAAA7DAAAOwwHHb6hkAAACnElEQVQ4y5VTTW8SURSdf+KPcuEPcNFEV2o0ummbGjdqdOfGjXGh0USMGhMoFmgpXwPD90dLFRAsAsMwhWEoMAzHex8dShM16U1O3ps7M+eed+95Ei4R8/n8wt555MW25yInjcdjaJqGXq93Bp2edbE6OX4/mUxWiBxim4jGtFrLQtLu7i7C4TCSySQSioJEIoZMOgZFkWmvIJVKIRQKIRKJLChsW2hSNRuFgz6U1DHyJQ2VnxY0fQZJluULx7L116goNzDpuS4cT6Fiq/Hi1QmurbVw84GGtXsqrl7/jXefDEixWAyjkXlW2UYleQvPN67gMPFwUWA2g2EYQikfPZPJQe008MV7itsbHaw/6WLrmYb7j7r4FjQhRaNRTKfTZeWx7kf/+CWmg+h5jvrMCi3LwnA4oswM7z8buLOpYv2xhs2nGu5uqfD4iZA/7HQ6qFR+4Oj7EfQTU5CY5hSFQgGlUkkMhhWuRlQ5xRvXAK6vBj4Q3n4cIFscQ+KGB/f3ISdSKKTzkKkF/b4OWY4hm80il8uBBxePx52OCov8KySv14NgKIq6AcRNBeFkCPVaXShzgosyzr24ILUswuwcnJO829uIp9NAqw3tMIHUQQG/Go3lEBh+v39pm7+ZfDVHCr2IUx/nBhnUnCBfLKJBhOxLVVXR7Xbh8/mEV9kJDjhm5AAeFMPJSR7PNpJk4giJPCXDF4s51Go1QajrusDOzg72qc+stt1uL28Nv+OBcuHhcLgg3NvbAyOfKxLy4mj8MhgMgi3FPnW73aJAvV4nH2bItyNUq1XR53K5LMCOaDabC0L+OczTppUJuH9MzNPlXCAQAN+owWAgFHKv2Eq8Z3WMVqtF7uhDYvl8E1gVg/f8I6+maQrwftX8/4s/8K9LoLGupMYAAAAASUVORK5CYII='); background-size: cover; display: block;"
    >
      <img
        class="gatsby-resp-image-image"
        style="width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;"
        alt="V8"
        title=""
        src="/static/RunTime-b8b9d51ed2ef32832a63c4430eb8a323-acf85.png"
        srcset="/static/RunTime-b8b9d51ed2ef32832a63c4430eb8a323-c1418.png 210w,
/static/RunTime-b8b9d51ed2ef32832a63c4430eb8a323-5d5d8.png 420w,
/static/RunTime-b8b9d51ed2ef32832a63c4430eb8a323-acf85.png 840w,
/static/RunTime-b8b9d51ed2ef32832a63c4430eb8a323-18f60.png 1014w"
        sizes="(max-width: 840px) 100vw, 840px"
      />
    </span>
  </span>
  
  </a>
    </p>
<p>同样，在Node.js中，可以把Node的各种库提供的API称为RunTime。所以可以这么理解，Chrome和Node.js都采用相同的V8引擎，但拥有不同的运行环境(RunTime Environments)</p>
<h3 id="call-stack"><a href="#call-stack" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Call Stack</h3>
<p>JS被设计为单线程运行的，这是因为JS主要用来实现很多交互相关的操作，如DOM相关操作，如果是多线程会造成复杂的同步问题(例如当两个线程同时操作同一个DOM元素的时候该如何处理)。因此JS自诞生以来就是单线程的，而且主线程都是用来进行界面相关的渲染操作 (为什么说是主线程，因为HTML5 提供了Web Worker，独立的一个后台JS，用来处理一些耗时数据操作。因为不会修改相关DOM及页面元素，因此不影响页面性能)，如果有阻塞产生会导致浏览器卡死。</p>
<p>如果一个递归调用没有终止条件，是一个死循环的话，会导致调用栈内存不够而溢出，如：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>例子中foo函数循环调用其本身，且没有终止条件，浏览器控制台输出调用栈达到最大调用次数。</p>
<p>JS线程如果遇到比较耗时操作，如读取文件，AJAX请求操作怎么办？这里JS用到了Callback回调函数来处理。
对于Call Stack中的每个方法调用，都会形成它自己的一个执行上下文Execution Context，关于执行上下文的详细阐述请看<a href="https://juejin.im/post/5a5ee28f6fb9a01cbe655860">这篇文章</a></p>]]></description><link>https://reactjs.org/blog/2018/11/12/overview-of-the-engine-the-runtime-the-call-stack.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/11/12/overview-of-the-engine-the-runtime-the-call-stack.html</guid><pubDate>Sun, 11 Nov 2018 16:00:00 GMT</pubDate></item><item><title><![CDATA[FP16：Applicative Functor]]></title><description><![CDATA[<h3 id="applicative-functor"><a href="#applicative-functor" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Applicative Functor</h3>
<h4 id="应用-applicative-functor"><a href="#%E5%BA%94%E7%94%A8-applicative-functor" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>应用 applicative functor</h4>
<p>考虑到其函数式的出身，<strong>applicative functor</strong> 这个名称堪称简单明了。函数式程序员最为人诟病的一点就是，总喜欢搞一些稀奇古怪的命名，比如 <code class="gatsby-code-text">mappend</code> 或者 <code class="gatsby-code-text">liftA4</code>。诚然，此类名称出现在数学实验室是再自然不过的，但是放在其他任何语境下，这些概念就都像是扮作达斯维达去汽车餐馆搞怪的人。</p>
<p>无论如何，applicative 这个名字应该能够向我们表明一些事实，告诉我们作为一个接口，它能为我们带来什么：那就是让不同 functor 可以相互应用（apply）的能力。</p>
<p>然而，你可能会问了，为何一个正常的、理性的人，比如你自己，会做这种“让不同 functor 相互应用”的事？而且，“相互应用”到底<em>是什么意思</em>？</p>
<p>要回答这些问题，我们可以从下面这个场景讲起，可能你已经碰到过这种场景了。假设有两个同类型的 functor，我们想把这两者作为一个函数的两个参数传递过去来调用这个函数。简单的例子比如让两个 <code class="gatsby-code-text">Container</code> 的值相加：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 这样是行不通的，因为 2 和 3 都藏在瓶子里。</span>
<span class="token function">add</span><span class="token punctuation">(</span>Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//NaN</span>

<span class="token comment">// 使用可靠的 map 函数试试</span>
<span class="token keyword">const</span> container_of_add_2 <span class="token operator">=</span> <span class="token function">map</span><span class="token punctuation">(</span>add<span class="token punctuation">,</span> Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Container(add(2))</span></code></pre>
      </div>
<p>这时候我们创建了一个 <code class="gatsby-code-text">Container</code>，它内部的值是一个局部调用的（partially applied）的函数。确切点讲就是，我们想让 <code class="gatsby-code-text">Container(add(2))</code> 中的 <code class="gatsby-code-text">add(2)</code> 应用到 <code class="gatsby-code-text">Container(3)</code> 中的 <code class="gatsby-code-text">3</code> 上来完成调用。也就是说，我们想把一个 functor 应用到另一个上。</p>
<p>巧的是，完成这种任务的工具已经存在了，即 <code class="gatsby-code-text">chain</code> 函数。我们可以先 <code class="gatsby-code-text">chain</code> 然后再 <code class="gatsby-code-text">map</code> 那个局部调用的 <code class="gatsby-code-text">add(2)</code>，就像这样：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>只不过，这种方式有一个问题，那就是 monad 的顺序执行问题：所有的代码都只会在前一个 monad 执行完毕之后才执行。想想看，我们的这两个值足够强健且相互独立，如果仅仅为了满足 monad 的顺序要求而延迟 <code class="gatsby-code-text">Container(3)</code> 的创建，我觉得是非常没有必要的。</p>
<p>事实上，当遇到这种问题的时候，要是能够无需借助这些不必要的函数和变量，以一种简明扼要的方式把一个 functor 的值应用到另一个上去就好了。</p>
<h3 id="瓶中之船"><a href="#%E7%93%B6%E4%B8%AD%E4%B9%8B%E8%88%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>瓶中之船</h3>
<img src="images/ship_in_a_bottle.jpg" alt="http://hollycarden.deviantart.com" />
<p><code class="gatsby-code-text">ap</code> 就是这样一种函数，能够把一个 functor 的函数值应用到另一个 functor 的值上。把这句话快速地说上 5 遍。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Container(5)</span>

<span class="token comment">// all together now</span>
Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Container(5)</span></code></pre>
      </div>
<p>这样就大功告成了，而且代码干净整洁。可以看到，<code class="gatsby-code-text">Container(3)</code> 从嵌套的 monad 函数的牢笼中释放了出来。需要再次强调的是，本例中的 <code class="gatsby-code-text">add</code> 是被 <code class="gatsby-code-text">map</code> 所局部调用（partially apply）的，所以 <code class="gatsby-code-text">add</code> 必须是一个 curry 函数。</p>
<p>可以这样定义一个 <code class="gatsby-code-text">ap</code> 函数：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Container<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">ap</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>other_container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> other_container<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>__value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>记住，<code class="gatsby-code-text">this.__value</code> 是一个函数，将会接收另一个 functor 作为参数，所以我们只需 <code class="gatsby-code-text">map</code> 它。由此我们可以得出 applicative functor 的定义：</p>
<blockquote>
<p>applicative functor 是实现了 <code class="gatsby-code-text">ap</code> 方法的 pointed functor</p>
</blockquote>
<p>注意 <code class="gatsby-code-text">pointed</code> 这个前提，这是非常重要的一个前提，下面的例子会说明这一点。</p>
<p>讲到这里，我已经感受到你的疑虑了（也或者是困惑和恐惧）；心态开放点嘛，<code class="gatsby-code-text">ap</code> 还是很有用的。在深入理解这个概念之前，我们先来探索一个特性。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token constant">F</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">F</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token constant">F</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>这行代码翻译成人类语言就是，map 一个 <code class="gatsby-code-text">f</code> 等价于 <code class="gatsby-code-text">ap</code> 一个值为 <code class="gatsby-code-text">f</code> 的 functor。或者更好的译法是，你既可以把 <code class="gatsby-code-text">x</code> 放到容器里然后调用 <code class="gatsby-code-text">map(f)</code>，也可以同时让 <code class="gatsby-code-text">f</code> 和 <code class="gatsby-code-text">x</code> 发生 lift（参看第 8 章），然后对他们调用 <code class="gatsby-code-text">ap</code>。这让我们能够以一种从左到右的方式编写代码：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Maybe(5)</span>

Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Task(5)</span></code></pre>
      </div>
<p>细心的读者可能发现了，上述代码中隐约有普通函数调用的影子。没关系，我们稍后会学习 <code class="gatsby-code-text">ap</code> 的 pointfree 版本；暂时先把这当作此类代码的推荐写法。通过使用 <code class="gatsby-code-text">of</code>，每一个值都被输送到了各个容器里的奇幻之地，就像是在另一个平行世界里，每个程序都可以是异步的或者是 null 或者随便什么值，而且不管是什么，<code class="gatsby-code-text">ap</code> 都能在这个平行世界里针对这些值应用各种各样的函数。这就像是在一个瓶子中造船。</p>
<p>你注意到没？上例中我们使用了 <code class="gatsby-code-text">Task</code>，这是 applicative functor 主要的用武之地。现在我们来看一个更深入的例子。</p>
<h3 id="协调与激励"><a href="#%E5%8D%8F%E8%B0%83%E4%B8%8E%E6%BF%80%E5%8A%B1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>协调与激励</h3>
<p>假设我们要创建一个旅游网站，既需要获取游客目的地的列表，还需要获取地方事件的列表。这两个请求就是相互独立的 api 调用。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// Http.get :: String -> Task Error HTML</span>

<span class="token keyword">var</span> renderPage <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>destinations<span class="token punctuation">,</span> events<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* render page */</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>renderPage<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/destinations'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/events'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// Task("&lt;div>some page with dest and events&lt;/div>")</span></code></pre>
      </div>
<p>两个请求将会同时立即执行，当两者的响应都返回之后，<code class="gatsby-code-text">renderPage</code> 就会被调用。这与 monad 版本的那种必须等待前一个任务完成才能继续执行后面的操作完全不同。本来我们就无需根据目的地来获取事件，因此也就不需要依赖顺序执行。</p>
<p>再次强调，因为我们是使用局部调用的函数来达成上述结果的，所以必须要保证 <code class="gatsby-code-text">renderpage</code> 是 curry 函数，否则它就不会一直等到两个 <code class="gatsby-code-text">Task</code> 都完成。而且如果你碰巧自己做过类似的事，那你一定会感激 <code class="gatsby-code-text">applicative functor</code> 这个异常简洁的接口的。这就是那种能够让我们离“奇点”（singularity）更近一步的优美代码。</p>
<p>再来看另外一个例子。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 帮助函数：</span>
<span class="token comment">// ==============</span>
<span class="token comment">//  $ :: String -> IO DOM</span>
<span class="token keyword">var</span> <span class="token function-variable function">$</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//  getVal :: String -> IO String</span>
<span class="token keyword">var</span> getVal <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">prop</span><span class="token punctuation">(</span><span class="token string">'value'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> $<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Example:</span>
<span class="token comment">// ===============</span>
<span class="token comment">//  signIn :: String -> String -> Bool -> User</span>
<span class="token keyword">var</span> signIn <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">,</span> remember_me<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">/* signing in */</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>signIn<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">getVal</span><span class="token punctuation">(</span><span class="token string">'#email'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">getVal</span><span class="token punctuation">(</span><span class="token string">'#password'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// IO({id: 3, email: "gg@allin.com"})</span></code></pre>
      </div>
<p><code class="gatsby-code-text">signIn</code> 是一个接收 3 个参数的 curry 函数，因此我们需要调用 <code class="gatsby-code-text">ap</code> 3 次。在每一次的 <code class="gatsby-code-text">ap</code> 调用中，<code class="gatsby-code-text">signIn</code> 就收到一个参数然后运行，直到所有的参数都传进来，它也就执行完毕了。我们可以继续扩展这种模式，处理任意多的参数。另外，左边两个参数在使用 <code class="gatsby-code-text">getVal</code> 调用后自然而然地成为了一个 <code class="gatsby-code-text">IO</code>，但是最右边的那个却需要手动 <code class="gatsby-code-text">lift</code>，然后变成一个 <code class="gatsby-code-text">IO</code>，这是因为 <code class="gatsby-code-text">ap</code> 需要调用者及其参数都属于同一类型。</p>
<h3 id="lift"><a href="#lift" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>lift</h3>
<p>我们来试试以一种 pointfree 的方式调用 applicative functor。因为 <code class="gatsby-code-text">map</code> 等价于 <code class="gatsby-code-text">of/ap</code>，那么我们就可以定义无数个能够 <code class="gatsby-code-text">ap</code> 通用函数。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> liftA2 <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> functor1<span class="token punctuation">,</span> functor2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> functor1<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> liftA3 <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> functor1<span class="token punctuation">,</span> functor2<span class="token punctuation">,</span> functor3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> functor1<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//liftA4, etc</span></code></pre>
      </div>
<p><code class="gatsby-code-text">liftA2</code> 是个奇怪的名字，听起来像是破败工厂里挑剔的货运电梯，或者伪豪华汽车公司的个性车牌。不过你要是真正理解了，那么它的含义也就不证自明了：让那些小代码块发生 lift，成为 applicative functor 中的一员。</p>
<p>刚开始我也觉得这种 2-3-4 的写法没什么意义，看起来又丑又没有必要，毕竟我们可以在 JavaScript 中检查函数的参数数量然后再动态地构造这样的函数。不过，局部调用（partially apply）<code class="gatsby-code-text">liftA(N)</code> 本身，有时也能发挥它的用处，这样的话，参数数量就固定了。</p>
<p>来看看实际用例：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// checkEmail :: User -> Either String Email</span>
<span class="token comment">// checkName :: User -> Either String String</span>

<span class="token comment">//  createUser :: Email -> String -> IO User</span>
<span class="token keyword">var</span> createUser <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>email<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* creating... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Either<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>createUser<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">checkEmail</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">checkName</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Left("invalid email")</span>

<span class="token function">liftA2</span><span class="token punctuation">(</span>createUser<span class="token punctuation">,</span> <span class="token function">checkEmail</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">checkName</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Left("invalid email")</span></code></pre>
      </div>
<p><code class="gatsby-code-text">createUser</code> 接收两个参数，因此我们使用的是 <code class="gatsby-code-text">liftA2</code>。上述两个语句是等价的，但是使用了 <code class="gatsby-code-text">liftA2</code> 的版本没有提到 <code class="gatsby-code-text">Either</code>，这就使得它更加通用灵活，因为不必与特定的数据类型耦合在一起。</p>
<p>我们试试以这种方式重写前一个例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token function">liftA2</span><span class="token punctuation">(</span>add<span class="token punctuation">,</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Maybe(5)</span>

<span class="token function">liftA2</span><span class="token punctuation">(</span>renderPage<span class="token punctuation">,</span> Http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/destinations'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/events'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// Task("&lt;div>some page with dest and events&lt;/div>")</span>

<span class="token function">liftA3</span><span class="token punctuation">(</span>signIn<span class="token punctuation">,</span> <span class="token function">getVal</span><span class="token punctuation">(</span><span class="token string">'#email'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getVal</span><span class="token punctuation">(</span><span class="token string">'#password'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// IO({id: 3, email: "gg@allin.com"})</span></code></pre>
      </div>
<h3 id="操作符"><a href="#%E6%93%8D%E4%BD%9C%E7%AC%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>操作符</h3>
<p>在 haskell、scala、PureScript 以及 swift 等语言中，开发者可以创建自定义的中缀操作符（infix operators），所以你能看到到这样的语法：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-hs"><code class="gatsby-code-hs">-- haskell
add &lt;$&gt; Right 2 &lt;*&gt; Right 3</code></pre>
      </div>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// JavaScript</span>
<span class="token function">map</span><span class="token punctuation">(</span>add<span class="token punctuation">,</span> <span class="token function">Right</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">Right</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
      </div>
<p><code class="gatsby-code-text">&lt;$&gt;</code> 就是 <code class="gatsby-code-text">map</code>（亦即 <code class="gatsby-code-text">fmap</code>），<code class="gatsby-code-text">&lt;*&gt;</code> 不过就是 <code class="gatsby-code-text">ap</code>。这样的语法使得开发者可以以一种更自然的风格来书写函数式应用，而且也能减少一些括号。</p>
<h3 id="免费开瓶器"><a href="#%E5%85%8D%E8%B4%B9%E5%BC%80%E7%93%B6%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>免费开瓶器</h3>
<img src="images/canopener.jpg" alt="http://breannabeckmeyer.com/drawing.html" />
<p>我们尚未对衍生函数（derived function）着墨过多。不过看到本书介绍的所有这些接口都互相依赖并遵守一些定律，那么我们就可以根据一些强接口来定义一些弱接口了。</p>
<p>比如，我们知道一个 applicative 首先是一个 functor，所以如果已经有一个 applicative 实例的话，毫无疑问可以依此定义一个 functor。</p>
<p>这种完美的计算上的大和谐（computational harmony）之所以存在，是因为我们在跟一个数学“框架”打交道。哪怕是莫扎特在小时候就下载了 ableton（译者注：一款专业的音乐制作软件），他的钢琴也不可能弹得更好。</p>
<p>前面提到过，<code class="gatsby-code-text">of/ap</code> 等价于 <code class="gatsby-code-text">map</code>，那么我们就可以利用这点来定义 <code class="gatsby-code-text">map</code>：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 从 of/ap 衍生出的 map</span>
<span class="token constant">X</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">map</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>constructor<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>monad 可以说是处在食物链的顶端，因此如果已经有了一个 <code class="gatsby-code-text">chain</code> 函数，那么就可以免费得到 functor 和 applicative：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 从 chain 衍生出的 map</span>
<span class="token constant">X</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">map</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> m<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">// 从 chain/map 衍生出的 ap</span>
<span class="token constant">X</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">ap</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> other<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>定义一个 monad，就既能得到 applicative 也能得到 functor。这一点非常强大，相当于这些“开瓶器”全都是免费的！我们甚至可以审查一个数据类型，然后自动化这个过程。</p>
<p>应该要指出来的一点是，<code class="gatsby-code-text">ap</code> 的魅力有一部分就来自于并行的能力，所以通过 <code class="gatsby-code-text">chain</code> 来定义它就失去了这种优化。即便如此，开发者在设计出最佳实现的过程中就能有一个立即可用的接口，也是很好的。</p>
<p>为啥不直接使用 monad？因为最好用合适的力量来解决合适的问题，一分不多，一分不少。这样就能通过排除可能的功能性来做到最小化认知负荷。因为这个原因，相比 monad，我们更倾向于使用 applicative。</p>
<p>向下的嵌套结构使得 monad 拥有串行计算、变量赋值和暂缓后续执行等独特的能力。不过见识到 applicative 的实际用例之后，你就不必再考虑上面这些问题了。</p>
<p>下面，来看看理论知识。</p>
<h3 id="定律"><a href="#%E5%AE%9A%E5%BE%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>定律</h3>
<p>就像我们探索过的其他数学结构一样，我们在日常编码中也依赖 applicative functor 一些有用的特性。首先，你应该知道 applicative functor 是“组合关闭”（closed under composition）的，意味着 <code class="gatsby-code-text">ap</code> 永远不会改变容器类型（另一个胜过 monad 的原因）。这并不是说我们无法拥有多种不同的作用——我们还是可以把不同的类型压栈的，只不过我们知道它们将会在整个应用的过程中保持不变。</p>
<p>下面的例子可以说明这一点：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">  <span class="token keyword">var</span> tOfM <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">,</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">liftA2</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>concat<span class="token punctuation">,</span> <span class="token function">tOfM</span><span class="token punctuation">(</span><span class="token string">'Rainy Days and Mondays'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">tOfM</span><span class="token punctuation">(</span><span class="token string">' always get me down'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment">// Task(Maybe(Rainy Days and Mondays always get me down))</span></code></pre>
      </div>
<p>你看，不必担心不同的类型会混合在一起。</p>
<p>该去看看我们最喜欢的范畴学定律了：<em>同一律</em>（identity）。</p>
<h3 id="同一律（identity）"><a href="#%E5%90%8C%E4%B8%80%E5%BE%8B%EF%BC%88identity%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同一律（identity）</h3>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 同一律</span>
<span class="token constant">A</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">==</span> v</code></pre>
      </div>
<p>是的，对一个 functor 应用 <code class="gatsby-code-text">id</code> 函数不会改变 <code class="gatsby-code-text">v</code> 里的值。比如：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> v <span class="token operator">=</span> Identity<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"Pillow Pets"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Identity<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">==</span> v</code></pre>
      </div>
<p><code class="gatsby-code-text">Identity.of(id)</code> 的“无用性”让我不禁莞尔。这里有意思的一点是，就像我们之前证明了的，<code class="gatsby-code-text">of/ap</code> 等价于 <code class="gatsby-code-text">map</code>，因此这个同一律遵循的是 functor 的同一律：<code class="gatsby-code-text">map(id) == id</code>。</p>
<p>使用这些定律的优美之处在于，就像一个富有激情的幼儿园健身教练让所有的小朋友都能愉快地一块玩耍一样，它们能够强迫所有的接口都能完美结合。</p>
<h3 id="同态（homomorphism）"><a href="#%E5%90%8C%E6%80%81%EF%BC%88homomorphism%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同态（homomorphism）</h3>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 同态</span>
<span class="token constant">A</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">A</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
      </div>
<p><em>同态</em>就是一个能够保持结构的映射（structure preserving map）。实际上，functor 就是一个在不同范畴间的同态，因为 functor 在经过映射之后保持了原始范畴的结构。</p>
<p>事实上，我们不过是把普通的函数和值放进了一个容器，然后在里面进行各种计算。所以，不管是把所有的计算都放在容器里（等式左边），还是先在外面进行计算然后再放到容器里（等式右边），其结果都是一样的。</p>
<p>一个简单例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Either<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>toUpper<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Either<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"oreos"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> Either<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">toUpper</span><span class="token punctuation">(</span><span class="token string">"oreos"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
      </div>
<h3 id="互换（interchange）"><a href="#%E4%BA%92%E6%8D%A2%EF%BC%88interchange%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>互换（interchange）</h3>
<p>互换（interchange）表明的是选择让函数在 <code class="gatsby-code-text">ap</code> 的左边还是右边发生 lift 是无关紧要的。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 互换</span>
v<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">A</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span></code></pre>
      </div>
<p>这里有个例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> v <span class="token operator">=</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>reverse<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">'Sparklehorse'</span><span class="token punctuation">;</span>

v<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span></code></pre>
      </div>
<h3 id="组合（composition）"><a href="#%E7%BB%84%E5%90%88%EF%BC%88composition%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>组合（composition）</h3>
<p>最后是组合。组合不过是在检查标准的函数组合是否适用于容器内部的函数调用。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 组合</span>
<span class="token constant">A</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>compose<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">==</span> u<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> u <span class="token operator">=</span> <span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>toUpper<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> v <span class="token operator">=</span> <span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"&amp; beyond"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> w <span class="token operator">=</span> <span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"blood bath "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>compose<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">==</span> u<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
      </div>
<h3 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>
<p>处理多个 functor 作为参数的情况，是 applicative functor 一个非常好的应用场景。借助 applicative functor，我们能够在 functor 的世界里调用函数。尽管已经可以通过 monad 达到这个目的，但在不需要 monad 的特定功能的时候，我们还是更倾向于使用 applicative functor。</p>
<p>至此我们已经基本介绍完容器的 api 了，我们学会了如何对函数调用 <code class="gatsby-code-text">map</code>、<code class="gatsby-code-text">chain</code> 和 <code class="gatsby-code-text">ap</code>。下一章，我们将学习如何更好地处理多个 functor，以及如何以一种原则性的方式拆解它们。</p>]]></description><link>https://reactjs.org/blog/2018/11/07/FB16-Applicative-Functor.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/11/07/FB16-Applicative-Functor.html</guid><pubDate>Tue, 06 Nov 2018 16:00:00 GMT</pubDate></item><item><title><![CDATA[FP15：Monad-2]]></title><description><![CDATA[<blockquote>
<p>“A monad is just a monoid in the category of endofunctors. What’s the problem?”</p>
</blockquote>
<p>Monad是非常简单的，但是它的概念却有点让人云里雾里，尤其是网上查询资料博客的时候，一般会从范畴论开始讲解，这是正确的道路，不过可惜的是大部分的JavaScript开发人员，并不懂范畴论，范畴不仅仅是一种数学语言，也是一种哲学观点，范畴论也绝不是一两篇文章就能讲清楚的，这里我们不过多的去说明范畴论，而仅仅是谈论一下在计算机编程中的Monad的概念</p>
<p>Monad是一种组合函数的方法，除了返回值之外，还需要上下文，比如计算，if/else分支，IO等等。Monad可以类型提升，并且扁平化的映射<code class="gatsby-code-text">a -&gt; M(b)</code>,使函数可组合，可以把类型a的数据映射成数据b的类型，并隐藏了实现的细节</p>
<blockquote>
<p>这里说的上下文不同于函数执行上下文，这里的上下文，仅仅是只数据的外部环境，或者是某种Wrapper、Box之类的概念，例如数组的仅仅是对数据的一种包裹，但是却可以提供很多的便捷的方法</p>
</blockquote>
<ul>
<li>Function map:<code class="gatsby-code-text">a=&gt;b</code></li>
<li>Functor map with context:<code class="gatsby-code-text">Functor(a) =&gt; Functor(b)</code></li>
<li>Monad flatten and map with context:<code class="gatsby-code-text">Monad(Monad(a)) =&gt; Monad(b)</code></li>
</ul>
<p>上面所说的：<code class="gatsby-code-text">map</code>，<code class="gatsby-code-text">flatten</code>,<code class="gatsby-code-text">context</code>又是什么意思呢？</p>
<ul>
<li>Map的意思是说，使用参数a调用一个函数，计算之后，函数返回值为b. Given some input, return some output.</li>
<li>Context是组合Monad的计算细节，这里和Functor类似，我们可以直接调用<code class="gatsby-code-text">fmap</code>之类的方法，却无需关心实现的细节，这样我们就可以放心的在上下文环境中，完成从数据a,到数据b的映射，并返回处于同样上下文中的b，eg:<code class="gatsby-code-text">Array(a) =&gt; Array(b)</code>,<code class="gatsby-code-text">Observable(a) =&gt; Observable(b)</code></li>
<li>Type lift意味着将数据提升到上下文中,这样可以方便的使用上下文的方法，<code class="gatsby-code-text">a =&gt; Functor(a)</code>,Monad只不过是更强大的Functor，eg:字符串’abc’,‘xyz’，把他们做个类型提升：<code class="gatsby-code-text">[&#39;abc&#39;,&#39;xyz&#39;]</code>,那么就可以方便快捷的，使用数据的map,filter等等方法了，借助Functor可以提升任何类型的数据</li>
<li>Flatten是从上下文中取出数据<code class="gatsby-code-text">Functor(a) =&gt; a</code>,去除包装，取出果实，有可能一个值是被层层包装的，那么就是层层的去除包装来扁平化，类似于拨洋葱一样一层一层的去除外衣</li>
</ul>
<p>Example:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>             <span class="token comment">// Some data of type `a`</span>
<span class="token keyword">const</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> n <span class="token operator">=></span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment">// A function from `a` to `b`</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// The type lift.</span>
<span class="token comment">// JS has type lift sugar for arrays: [x]</span>
<span class="token comment">// .map() applies the function f to the value x</span>
<span class="token comment">// in the context of the array.</span>
<span class="token keyword">const</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [40]</span></code></pre>
      </div>
<p>在这个例子中，Array就是<code class="gatsby-code-text">context</code>,<code class="gatsby-code-text">x</code>是被包裹的值。</p>
<p>这个例子中没有包含，数组中的数组，但是使用concat扁平化数组，绝不陌生：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>concat<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// [1, 2, 3, 4]</span></code></pre>
      </div>
<h3 id="youre-probably-already-using-monads"><a href="#youre-probably-already-using-monads" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>You’re probably already using monads</h3>
<p>函数组合创建数据流经的函数管道。您在管道的第一阶段输入了一些输入，并且一些数据从管道的最后一个阶段弹出，进行了转换。但要实现这一点，管道的每个阶段都必须期望前一阶段返回的数据类型。</p>
<p>编写简单的函数很容易，因为类型都很容易排列。只需将输出类型b的函数<code class="gatsby-code-text">g</code>与输入类型b的函数<code class="gatsby-code-text">f</code>匹配即可：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-text"><code class="gatsby-code-text">g: a =&gt; b
f: b =&gt; c
h = f(g(a)): a =&gt; c</code></pre>
      </div>
<p>如果是在<code class="gatsby-code-text">Functor</code>中进行组合或者连续调用，也非常简单，因为永远都是相同的Wrapper类型：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-text"><code class="gatsby-code-text">g: F(a) =&gt; F(b)
f: F(b) =&gt; F(c)
h = f(g(Fa)): F(a) =&gt; F(c)</code></pre>
      </div>
<p>但是如果你想组合的函数是<code class="gatsby-code-text">a =&gt; F(b)</code>,<code class="gatsby-code-text">b =&gt; F(c)</code>,这个时候就需要Monad了，使用<code class="gatsby-code-text">M</code>Functor替换一下<code class="gatsby-code-text">F</code>,让问题更清晰一些：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-text"><code class="gatsby-code-text">g: a =&gt; M(b)
f: b =&gt; M(c)
h = composeM(f, g): a =&gt; M(c)</code></pre>
      </div>
<p>Oops.这个时候发现类型对应不上，<code class="gatsby-code-text">f</code>函数的输入我们想要的是类型<code class="gatsby-code-text">b</code>,但是我们得到的却是类型<code class="gatsby-code-text">M(b)</code>,由于这中错位，在<code class="gatsby-code-text">composeM</code>中，我们需要从函数<code class="gatsby-code-text">g</code>的返回值<code class="gatsby-code-text">M(b)</code>中取出数据<code class="gatsby-code-text">b</code>。而这个过程正是<code class="gatsby-code-text">flaten</code>和<code class="gatsby-code-text">map</code>的过程</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-text"><code class="gatsby-code-text">g: a =&gt; M(b) flattens to =&gt; b
f: b maps to =&gt; M(c)
h composeM(f, g):a flatten(M(b)) =&gt; b =&gt; map(b =&gt; M(c)) =&gt; M(c)</code></pre>
      </div>
<p>在上面中<code class="gatsby-code-text">M(b) =&gt; b</code>的展平，以及<code class="gatsby-code-text">b =&gt; M(c)</code>的映射，实在<code class="gatsby-code-text">a =&gt; M(c)</code>的<code class="gatsby-code-text">chain</code>中完成的，在更高层级<code class="gatsby-code-text">composeM</code>中的完成的，稍后会讲解<code class="gatsby-code-text">composeM</code>如何实现。</p>
<p>现在我们只要知道我们借助Monad完成更高级的函数组合，有很多的函数不是简单的从<code class="gatsby-code-text">a =&gt; b</code>的映射，有些函数需要处理副作用，例如(promise)、分支处理(Either)、异常处理(Maybe)。。。</p>
<p>举一个更实际的例子，如果我们要从一个异步的API中获取某个用户的信息，然后把这个信息，传递给另一个异步的API,来查询别的数据，这个时候我们怎么办呢？</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-text"><code class="gatsby-code-text">getUserById(id) =&gt; Promise(User)
hasPermision(User) =&gt; Promise(Boolean)</code></pre>
      </div>
<p>首先写一些工具函数，帮助我们完成任务：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">compose</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>fns<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> fns<span class="token punctuation">.</span><span class="token function">reduceRight</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">trace</span> <span class="token operator">=</span> label <span class="token operator">=></span> value <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> label <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> value <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>然后可以这样使用代码：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> label <span class="token operator">=</span> <span class="token string">'API call composition'</span><span class="token punctuation">;</span>

<span class="token comment">// a => Promise(b)</span>
<span class="token keyword">const</span> <span class="token function-variable function">getUserById</span> <span class="token operator">=</span> id <span class="token operator">=></span> id <span class="token operator">===</span> <span class="token number">3</span> <span class="token operator">?</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Kurt'</span><span class="token punctuation">,</span> role<span class="token punctuation">:</span> <span class="token string">'Author'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>
    undefined

<span class="token comment">// b => Promise(c)</span>
<span class="token keyword">const</span> <span class="token function-variable function">hasPermission</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> role <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>role <span class="token operator">===</span> <span class="token string">'Author'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Try to compose them. Warning: this will fail.</span>
<span class="token keyword">const</span> authUser <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>hasPermission<span class="token punctuation">,</span> getUserById<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Oops! Always false!</span>
<span class="token function">authUser</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">trace</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>当我们组合<code class="gatsby-code-text">getUserById</code>，<code class="gatsby-code-text">hasPermission</code>函数的时候，我们发现了一个大问题，<code class="gatsby-code-text">hasPermission</code>函数期望得到一个<code class="gatsby-code-text">User</code>对象作为参数，而<code class="gatsby-code-text">getUserById</code>函数的返回值却是<code class="gatsby-code-text">Promise(User)</code>，为了解决这个问题，我们需要使用<code class="gatsby-code-text">then</code>方法从<code class="gatsby-code-text">Promise(User)</code>中把<code class="gatsby-code-text">User</code>对象取出来,为此我们做一个定制版的<code class="gatsby-code-text">composePromises</code>函数：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">composeM</span> <span class="token operator">=</span> chainMethod <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token operator">...</span>ms<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
    ms<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">[</span>chainMethod<span class="token punctuation">]</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> composePromises <span class="token operator">=</span> <span class="token function">composeM</span><span class="token punctuation">(</span><span class="token string">'then'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> label <span class="token operator">=</span> <span class="token string">'API call composition'</span><span class="token punctuation">;</span>

<span class="token comment">// a => Promise(b)</span>
<span class="token keyword">const</span> <span class="token function-variable function">getUserById</span> <span class="token operator">=</span> id <span class="token operator">=></span> id <span class="token operator">===</span> <span class="token number">3</span> <span class="token operator">?</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Kurt'</span><span class="token punctuation">,</span> role<span class="token punctuation">:</span> <span class="token string">'Author'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>
    undefined

<span class="token comment">// b => Promise(c)</span>
<span class="token keyword">const</span> <span class="token function-variable function">hasPermission</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> role <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>role <span class="token operator">===</span> <span class="token string">'Author'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// Compose the functions (this works!)</span>
<span class="token keyword">const</span> authUser <span class="token operator">=</span> <span class="token function">composePromises</span><span class="token punctuation">(</span>hasPermission<span class="token punctuation">,</span> getUserById<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">authUser</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">trace</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></code></pre>
      </div>
<p>Promise也是一种Monad。</p>
<h4 id="what-monads-are-made-of"><a href="#what-monads-are-made-of" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What Monads are Made of</h4>
<p>Monad遵循一个简单的对称，把一个值包装到context中，并且能够把值从context中取出来。</p>
<ul>
<li><strong>Lift/Unit</strong>:把一个值包装到Monad的context中，<code class="gatsby-code-text">a =&gt; M(a)</code></li>
<li><strong>Flatten/Join</strong>:把值从context中取出来，<code class="gatsby-code-text">M(a) =&gt; a</code></li>
</ul>
<p>Monad肯定也是一个Functor,那么很明显也有一个fmap方法：</p>
<ul>
<li><strong>Map</strong>:从一个Functor映射到另一个Functor,<code class="gatsby-code-text">M(a) =&gt; M(b)</code></li>
</ul>
<p>合并<code class="gatsby-code-text">Flatten</code>和<code class="gatsby-code-text">Map</code>,这个就是<code class="gatsby-code-text">Chain</code></p>
<ul>
<li><strong>FlatMap/Chain</strong>: Flatten + map: <code class="gatsby-code-text">M(M(a)) =&gt; M(b)</code></li>
</ul>
<blockquote>
<p>在Promise中<code class="gatsby-code-text">.then</code>方法实际上就是Monad中的<code class="gatsby-code-text">FlatMap/Chain</code>方法</p>
</blockquote>
<blockquote>
<p>Monad是一个抽象接口(类似于Java中的Interface)，定义了实现该接口必须定义的方法，而实现了Monad的具体类型被称为<strong>Monadic</strong>,Monadic才是根据方向，可以有不同的具体的实现,例如Promise，Array等等</p>
</blockquote>
<h4 id="扩展应用"><a href="#%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>扩展应用</h4>
<p>看一个具体的例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// The algebraic definition of function composition:</span>
<span class="token comment">// (f ∘ g)(x) = f(g(x))</span>
<span class="token keyword">const</span> <span class="token function-variable function">compose</span> <span class="token operator">=</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token comment">// The value</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// The container</span>
<span class="token comment">// Some functions to compose</span>
<span class="token keyword">const</span> <span class="token function-variable function">g</span> <span class="token operator">=</span> n <span class="token operator">=></span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> n <span class="token operator">=></span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment">// Proof that .map() accomplishes function composition.</span>
<span class="token comment">// Chaining calls to map is function composition.</span>
<span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">'map composes'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
    arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span>
    arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">compose</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// => [42], [42]</span></code></pre>
      </div>
<p>不仅仅是数组具有map方法，我们可以把任何包含<code class="gatsby-code-text">map</code>方法的Functor,都可以组合</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">composeMap</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>ms<span class="token punctuation">)</span> <span class="token operator">=></span> ms<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>
      </div>
<p>Promise的组合:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> label <span class="token operator">=</span> <span class="token string">'Promise composition'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">g</span> <span class="token operator">=</span> n <span class="token operator">=></span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> n <span class="token operator">=></span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> h <span class="token operator">=</span> <span class="token function">composePromises</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">h</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">trace</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// Promise composition: 42</span></code></pre>
      </div>
<p>其实规律非常简单，只要是这种结构的数据都可以自由的定义组合：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">composeM</span> <span class="token operator">=</span> method <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token operator">...</span>ms<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
  ms<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> composePromises <span class="token operator">=</span> <span class="token function">composeM</span><span class="token punctuation">(</span><span class="token string">'then'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> composeMap <span class="token operator">=</span> <span class="token function">composeM</span><span class="token punctuation">(</span><span class="token string">'map'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> composeFlatMap <span class="token operator">=</span> <span class="token function">composeM</span><span class="token punctuation">(</span><span class="token string">'flatMap'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>]]></description><link>https://reactjs.org/blog/2018/09/11/FB15-Monad-2.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/09/11/FB15-Monad-2.html</guid><pubDate>Mon, 10 Sep 2018 16:00:00 GMT</pubDate></item><item><title><![CDATA[FP14：Monad-1]]></title><description><![CDATA[<h3 id="pointed-functor"><a href="#pointed-functor" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>pointed functor</h3>
<p>在继续后面的内容之前，我得向你坦白一件事：关于我们先前创建的容器类型上的 of 方法，我并没有说出它的全部实情。真实情况是，of 方法不是用来避免使用 new 关键字的，而是用来把值放到默认最小化上下文（default minimal context）中的。是的，of 没有真正地取代构造器——它是一个我们称之为 pointed 的重要接口的一部分。</p>
<blockquote>
<p>pointed functor 是实现了 of 方法的 functor</p>
</blockquote>
<p>这里的关键是把任意值丢到容器里然后开始到处使用 map 的能力。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"tetris"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">" master"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// IO("tetris master")</span>

Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">1336</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Maybe(1337)</span>

Either<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"The past, present and future walk into a bar..."</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>
  <span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"it was tense."</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Right("The past, present and future walk into a bar...it was tense.")</span></code></pre>
      </div>
<p>如果你还记得，<code class="gatsby-code-text">IO</code>的构造器接受一个函数作为参数，而<code class="gatsby-code-text">Maybe</code>和<code class="gatsby-code-text">Either</code>的构造器可以接受任意值。实现这种接口的动机是，我们希望能有一种通用、一致的方式往<code class="gatsby-code-text">functor</code>里填值，而且中间不会涉及到复杂性，也不会涉及到对构造器的特定要求。“默认最小化上下文”这个术语可能不够精确，但是却很好地传达了这种理念：我们希望容器类型里的任意值都能发生<code class="gatsby-code-text">lift</code>，然后像所有的<code class="gatsby-code-text">functor</code>那样再<code class="gatsby-code-text">map</code>出去。</p>
<p>有件很重要的事我必须得在这里纠正，那就是，<code class="gatsby-code-text">Left.of</code>没有任何道理可言，包括它的双关语也是。每个<code class="gatsby-code-text">functor</code>都要有一种把值放进去的方式，对<code class="gatsby-code-text">Either</code>来说，它的方式就是<code class="gatsby-code-text">new Right(x)</code>。我们为<code class="gatsby-code-text">Right</code>定义<code class="gatsby-code-text">of</code>的原因是，如果一个类型容器可以<code class="gatsby-code-text">map</code>，那它就应该<code class="gatsby-code-text">map</code>。看上面的例子，你应该会对<code class="gatsby-code-text">of</code>通常的工作模式有一个直观的印象，而<code class="gatsby-code-text">Left</code>破坏了这种模式。</p>
<p>你可能已经听说过<code class="gatsby-code-text">pure</code>、<code class="gatsby-code-text">point</code>、<code class="gatsby-code-text">unit</code>和<code class="gatsby-code-text">return</code>之类的函数了，它们都是<code class="gatsby-code-text">of</code>这个史上最神秘函数的不同名称。<code class="gatsby-code-text">of</code>将在我们开始使用<code class="gatsby-code-text">monad</code>的时候显示其重要性，因为后面你会看到，手动把值放回容器是我们自己的责任。</p>
<p>要避免<code class="gatsby-code-text">new</code>关键字，可以借助一些标准的<code class="gatsby-code-text">JavaScript</code>技巧或者类库达到目的。所以从这里开始，我们就利用这些技巧或类库，像一个负责任的成年人那样使用<code class="gatsby-code-text">of</code>。我推荐使用<code class="gatsby-code-text">folktale</code>、<code class="gatsby-code-text">ramda</code>或<code class="gatsby-code-text">fantasy-land</code>里的<code class="gatsby-code-text">functor</code>实例，因为它们同时提供了正确的<code class="gatsby-code-text">of</code>方法和不依赖<code class="gatsby-code-text">new</code>的构造器。</p>
<h3 id="mixing-metaphors"><a href="#mixing-metaphors" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mixing Metaphors</h3>
<p><img src="../images/onion.png" alt="洋葱">
你看，除了太空墨西哥卷，monad 还被喻为洋葱。让我以一个常见的场景来说明这点：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// readFile :: String -> IO String</span>
<span class="token keyword">const</span> <span class="token function-variable function">readFile</span> <span class="token operator">=</span> filename <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// print :: String -> IO String</span>
<span class="token keyword">const</span> <span class="token function-variable function">print</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// cat :: String -> IO (IO String)</span>
<span class="token keyword">const</span> cat <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span><span class="token punctuation">,</span> readFile<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">cat</span><span class="token punctuation">(</span><span class="token string">'.git/config'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// IO(IO('[core]\nrepositoryformatversion = 0\n'))</span></code></pre>
      </div>
<p>这里我们得到的是一个<code class="gatsby-code-text">IO</code>，只不过它陷进了另一个<code class="gatsby-code-text">IO</code>。要想使用它，我们必须这样调用：<code class="gatsby-code-text">map(map(f))</code>；要想观察它的作用，必须这样：<code class="gatsby-code-text">unsafePerformIO().unsafePerformIO()</code>。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// cat :: String -> IO (IO String)</span>
<span class="token keyword">const</span> cat <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span><span class="token punctuation">,</span> readFile<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// catFirstChar :: String -> IO (IO String)</span>
<span class="token keyword">const</span> catFirstChar <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cat<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">catFirstChar</span><span class="token punctuation">(</span><span class="token string">'.git/config'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// IO(IO('['))</span></code></pre>
      </div>
<p>尽管在应用中把这两个作用打包在一起没什么不好的，但总感觉像是在穿着两套防护服工作，结果就形成一个稀奇古怪的<code class="gatsby-code-text">API</code>。再来看另一种情况：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// safeProp :: Key -> {Key: a} -> Maybe a</span>
<span class="token keyword">const</span> safeProp <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> obj<span class="token punctuation">)</span> <span class="token operator">=></span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// safeHead :: [a] -> Maybe a</span>
<span class="token keyword">const</span> safeHead <span class="token operator">=</span> <span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// firstAddressStreet :: User -> Maybe (Maybe (Maybe Street))</span>
<span class="token keyword">const</span> firstAddressStreet <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'street'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span>safeHead<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'addresses'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">firstAddressStreet</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  addresses<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> street<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Mulburry'</span><span class="token punctuation">,</span> number<span class="token punctuation">:</span> <span class="token number">8402</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> postcode<span class="token punctuation">:</span> <span class="token string">'WC2N'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Maybe(Maybe(Maybe({name: 'Mulburry', number: 8402})))</span></code></pre>
      </div>
<p>这里的<code class="gatsby-code-text">functor</code>同样是嵌套的，函数中三个可能的失败都用了<code class="gatsby-code-text">Maybe</code>做预防也很干净整洁，但是要让最后的调用者调用三次<code class="gatsby-code-text">map</code>才能取到值未免也太无礼了点——我们和它才刚刚见面而已。这种嵌套<code class="gatsby-code-text">functor</code>的模式会时不时地出现，而且是<code class="gatsby-code-text">monad</code>的主要使用场景。</p>
<p>我说过<code class="gatsby-code-text">monad</code>像洋葱，那是因为当我们用<code class="gatsby-code-text">map</code>剥开嵌套的<code class="gatsby-code-text">functor</code>以获取它里面的值的时候，就像剥洋葱一样让人忍不住想哭。不过，我们可以擦干眼泪，做个深呼吸，然后使用一个叫作<code class="gatsby-code-text">join</code>的方法。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> mmo <span class="token operator">=</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">'nunchucks'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Maybe(Maybe('nunchucks'))</span>

mmo<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Maybe('nunchucks')</span>

<span class="token keyword">const</span> ioio <span class="token operator">=</span> <span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">'pizza'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// IO(IO('pizza'))</span>

ioio<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// IO('pizza')</span>

<span class="token keyword">const</span> ttt <span class="token operator">=</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">'sewers'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Task(Task(Task('sewers')));</span>

ttt<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Task(Task('sewers'))</span></code></pre>
      </div>
<p>如果有两层相同类型的嵌套，那么就可以用 join 把它们压扁到一块去。这种结合的能力，functor 之间的联姻，就是 monad 之所以成为 monad 的原因。来看看它更精确的完整定义：</p>
<p><strong>monad是可以扁平化（flatten）的 pointed functor。</strong></p>
<p>一个 functor，只要它定义个了一个<code class="gatsby-code-text">join</code>方法和一个<code class="gatsby-code-text">of</code>方法，并遵守一些定律，那么它就是一个<code class="gatsby-code-text">monad</code>。<code class="gatsby-code-text">join</code>的实现并不太复杂，我们来为 <code class="gatsby-code-text">Maybe</code>定义一个：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Maybe<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">join</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>看，就像子宫里双胞胎中的一个吃掉另一个那么简单。如果有一个<code class="gatsby-code-text">Maybe(Maybe(x))</code>，那么 <code class="gatsby-code-text">.$value``将会移除多余的一层，然后我们就能安心地从那开始进行</code>map。要不然，我们就将会只有一个<code class="gatsby-code-text">Maybe</code>，因为从一开始就没有任何东西被<code class="gatsby-code-text">map</code>调用。</p>
<p>既然已经有了<code class="gatsby-code-text">join</code>方法，我们把<code class="gatsby-code-text">monad</code>魔法作用到<code class="gatsby-code-text">firstAddressStreet</code>例子上，看看它的实际作用：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// join :: Monad m => m (m a) -> m a</span>
<span class="token keyword">const</span> <span class="token function-variable function">join</span> <span class="token operator">=</span> mma <span class="token operator">=></span> mma<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// firstAddressStreet :: User -> Maybe Street</span>
<span class="token keyword">const</span> firstAddressStreet <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'street'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span>safeHead<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'addresses'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">firstAddressStreet</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  addresses<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> street<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Mulburry'</span><span class="token punctuation">,</span> number<span class="token punctuation">:</span> <span class="token number">8402</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> postcode<span class="token punctuation">:</span> <span class="token string">'WC2N'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Maybe({name: 'Mulburry', number: 8402})</span></code></pre>
      </div>
<p>只要遇到嵌套的 Maybe，就加一个 join，防止它们从手中溜走。我们对 IO 也这么做试试看，感受下这种感觉。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token constant">IO</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">join</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unsafePerformIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>同样是简单地移除了一层容器。注意，我们还没有提及纯粹性的问题，仅仅是移除过度紧缩的包裹中的一层而已。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// log :: a -> IO a</span>
<span class="token keyword">const</span> <span class="token function-variable function">log</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// setStyle :: Selector -> CSSProps -> IO DOM</span>
<span class="token keyword">const</span> setStyle <span class="token operator">=</span>
  <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sel<span class="token punctuation">,</span> props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">jQuery</span><span class="token punctuation">(</span>sel<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// getItem :: String -> IO String</span>
<span class="token keyword">const</span> <span class="token function-variable function">getItem</span> <span class="token operator">=</span> key <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// applyPreferences :: String -> IO DOM</span>
<span class="token keyword">const</span> applyPreferences <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">setStyle</span><span class="token punctuation">(</span><span class="token string">'#main'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span>parse<span class="token punctuation">)</span><span class="token punctuation">,</span>
  getItem<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">applyPreferences</span><span class="token punctuation">(</span><span class="token string">'preferences'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unsafePerformIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Object {backgroundColor: "green"}</span>
<span class="token comment">// &lt;div style="background-color: 'green'"/></span></code></pre>
      </div>
<p>getItem 返回了一个 IO String，所以可以直接用 map 来解析它。log 和 setStyle 返回的都是 IO，所以必须要使用 join 来保证这里边的嵌套处于控制之中。</p>
<h3 id="my-chain-hits-my-chest"><a href="#my-chain-hits-my-chest" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>My Chain Hits My Chest</h3>
<p><img src="../images/chain.jpg" alt="chain function">
你可能已经从上面的例子中注意到这种模式了：我们总是在紧跟着 map 的后面调用 join。让我们把这个行为抽象到一个叫做 chain 的函数里。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// chain :: Monad m => (a -> m b) -> m a -> m b</span>
<span class="token keyword">const</span> chain <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">=></span> m<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// or</span>

<span class="token comment">// chain :: Monad m => (a -> m b) -> m a -> m b</span>
<span class="token keyword">const</span> <span class="token function-variable function">chain</span> <span class="token operator">=</span> f <span class="token operator">=></span> <span class="token function">compose</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>这里仅仅是把 map/join 套餐打包到一个单独的函数中。如果你之前了解过 monad，那你可能已经看出来 chain 叫做 >>=（读作 bind）或者 flatMap；都是同一个概念的不同名称罢了。我个人认为 flatMap 是最准确的名称，但本书还是坚持使用 chain，因为它是 JS 里接受程度最高的一个。我们用 chain 重构下上面两个例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// map/join</span>
<span class="token keyword">const</span> firstAddressStreet <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'street'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span>safeHead<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'addresses'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// chain</span>
<span class="token keyword">const</span> firstAddressStreet <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'street'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">chain</span><span class="token punctuation">(</span>safeHead<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'addresses'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// map/join</span>
<span class="token keyword">const</span> applyPreferences <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">setStyle</span><span class="token punctuation">(</span><span class="token string">'#main'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span>parse<span class="token punctuation">)</span><span class="token punctuation">,</span>
  getItem<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// chain</span>
<span class="token keyword">const</span> applyPreferences <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">setStyle</span><span class="token punctuation">(</span><span class="token string">'#main'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">chain</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span>parse<span class="token punctuation">)</span><span class="token punctuation">,</span>
  getItem<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>我把所有的 map/join 都替换为了 chain，这样代码就显得整洁了些。整洁固然是好事，但 chain 的能力却不止于此——它更多的是龙卷风而不是吸尘器。因为 chain 可以轻松地嵌套多个作用，因此我们就能以一种纯函数式的方式来表示 序列（sequence） 和 变量赋值（variable assignment）。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// getJSON :: Url -> Params -> Task JSON</span>
<span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token string">'/authenticate'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> username<span class="token punctuation">:</span> <span class="token string">'stale'</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">'crackers'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>user <span class="token operator">=></span> <span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token string">'/friends'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> user_id<span class="token punctuation">:</span> user<span class="token punctuation">.</span>id <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Task([{name: 'Seimith', id: 14}, {name: 'Ric', id: 39}]);</span>

<span class="token comment">// querySelector :: Selector -> IO DOM</span>
<span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'input.username'</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> uname <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'input.email'</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> email <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Welcome </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>uname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> prepare for spam at </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>email<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// IO('Welcome Olivia prepare for spam at olivia@tremorcontrol.net');</span>

Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>three <span class="token operator">=></span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>three<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Maybe(5);</span>

Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'address'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'street'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// Maybe(null);</span></code></pre>
      </div>
<p>本来我们可以用 compose 写上面的例子，但这将需要几个帮助函数，而且这种风格怎么说都要通过闭包进行明确的变量赋值。相反，我们使用了插入式的 chain。顺便说一下，chain 可以自动从任意类型的 map 和 join 衍生出来，就像这样：t.prototype.chain = function(f) { return this.map(f).join(); }。如果手动定义 chain 能让你觉得性能会好点的话（实际上并不会），我们也可以手动定义它，尽管还必须要费力保证函数功能的正确性——也就是说，它必须与紧接着后面有 join 的 map 相等。如果 chain 是简单地通过结束调用 of 后把值放回容器这种方式定义的，那么就会造成一个有趣的后果，即可以从 chain 那里衍生出一个 map。同样地，我们还可以用 chain(id) 定义 join。听起来好像是在跟魔术师玩德州扑克，魔术师想要什么牌就有什么牌；但是就像大部分的数学理论一样，所有这些原则性的结构都是相互关联的。fantasyland 仓库中提到了许多上述衍生概念，这个仓库也是 JavaScript 官方的代数数据结构（algebraic data types）标准。</p>
<p>好了，我们来看上面的例子。第一个例子中，可以看到两个 Task 通过 chain 连接形成了一个异步操作的序列——它先获取 user，然后用 user.id 查找 user 的 friends。chain 避免了 Task(Task([Friend])) 这种情况。</p>
<p>第二个例子是用 querySelector 查找几个 input 然后创建一条欢迎信息。注意看我们是如何在最内层的函数里访问 uname 和 email 的——这是函数式变量赋值的绝佳表现。因为 IO 大方地把它的值借给了我们，我们也要负起以同样方式把值放回去的责任——不能辜负它的信任（还有整个程序的信任）。IO.of 非常适合做这件事，同时它也解释了为何 pointed 这一特性是 monad 接口得以存在的重要前提。不过，map 也能返回正确的类型：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'input.username'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> uname <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span>
  <span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'input.email'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> email <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span>
    <span class="token template-string"><span class="token string">`Welcome </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>uname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> prepare for spam at </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>email<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// IO('Welcome Olivia prepare for spam at olivia@tremorcontrol.net');</span></code></pre>
      </div>
<p>最后两个例子用了 Maybe。因为 chain 其实是在底层调用了 map，所以如果遇到 null，代码就会立刻停止运行。</p>
<p>如果觉得这些例子不太容易理解，你也不必担心。多跑跑代码，多琢磨琢磨，把代码拆开来研究研究，再把它们拼起来看看。总之记住，返回的如果是“普通”值就用 map，如果是 functor 就用 chain。</p>
<p>这里我得提醒一下，上述方式对两个不同类型的嵌套容器是不适用的。functor 组合，以及后面会讲到的 monad transformer 可以帮助我们应对这种情况。</p>
<h3 id="power-trip"><a href="#power-trip" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Power Trip</h3>
<p>这种容器编程风格有时也能造成困惑，我们不得不努力理解一个值到底嵌套了几层容器，或者需要用 map 还是 chain（很快我们就会认识更多的容器类型）。使用一些技巧，比如重写 inspect 方法之类，能够大幅提高 debug 的效率。后面我们也会学习如何创建一个“栈”，使之能够处理任何丢给它的作用（effects）。不过，有时候也需要权衡一下是否值得这样做。</p>
<p>我很乐意挥起 monad 之剑，向你展示这种编程风格的力量。就以读一个文件，然后就把它直接上传为例吧：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// readFile :: Filename -> Either String (Future Error String)</span>
<span class="token comment">// httpPost :: String -> Future Error JSON</span>

<span class="token comment">//  upload :: String -> Either String (Future Error JSON)</span>
<span class="token keyword">var</span> upload <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">httpPost</span><span class="token punctuation">(</span><span class="token string">'/uploads'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> readFile<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>这里，代码不止一次在不同的分支执行。从类型签名可以看出，我们预防了三个错误——readFile 使用 Either 来验证输入（或许还有确保文件名存在）；readFile 在读取文件的时候可能会出错，错误通过 readFile 的 Future 表示；文件上传可能会因为各种各样的原因出错，错误通过 httpPost 的 Future 表示。我们就这么随意地使用 chain 实现了两个嵌套的、有序的异步执行动作。</p>
<p>所有这些操作都是在一个从左到右的线性流中完成的，是完完全全纯的、声明式的代码，是可以等式推导（equational reasoning）并拥有可靠特性（reliable properties）的代码。我们没有被迫使用不必要甚至令人困惑的变量名，我们的 upload 函数符合通用接口而不是特定的一次性接口。这些都是在一行代码中完成的啊！</p>
<p>让我们来跟标准的命令式的实现对比一下：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">//  upload :: String -> (String -> a) -> Void</span>
<span class="token keyword">var</span> <span class="token function-variable function">upload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>filename<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token string">"You need a filename!"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">readFile</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> contents<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span>
      <span class="token function">httpPost</span><span class="token punctuation">(</span>contents<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> json<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span>
        <span class="token function">callback</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span></code></pre>
      </div>
<p>看看，这简直就是魔鬼的算术，我们就像一颗弹珠一样在变幻莫测的迷宫中穿梭。无法想象如果这是一个典型的应用，而且一直在改变变量会怎样——我们肯定会像陷入沥青坑那样无所适从。</p>
<h3 id="theory"><a href="#theory" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Theory</h3>
<p>我们要看的第一条定律是结合律，但可能不是你熟悉的那个结合律。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"> <span class="token comment">// 结合律</span>
  <span class="token function">compose</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>join<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">compose</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> join<span class="token punctuation">)</span></code></pre>
      </div>
<p>这些定律表明了 monad 的嵌套本质，所以结合律关心的是如何让内层或外层的容器类型 join，然后取得同样的结果。用一张图来表示可能效果会更好：
<img src="../images/monad_associativity.png" alt="monad结合律">
从左上角往下，先用 join 合并 M(M(M a)) 最外层的两个 M，然后往右，再调用一次 join，就得到了我们想要的 M a。或者，从左上角往右，先打开最外层的 M，用 map(join) 合并内层的两个 M，然后再向下调用一次 join，也能得到 M a。不管是先合并内层还是先合并外层的 M，最后都会得到相同的 M a，所以这就是结合律。值得注意的一点是 map(join) != join。两种方式的中间步骤可能会有不同的值，但最后一个 join 调用后最终结果是一样的。</p>
<p>第二个定律与结合律类似：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 同一律 (M a)</span>
  <span class="token function">compose</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> <span class="token keyword">of</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">compose</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">of</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> id</code></pre>
      </div>
<p>这表明，对任意的 monad M，of 和 join 相当于 id。也可以使用 map(of) 由内而外实现相同效果。我们把这个定律叫做“三角同一律”（triangle identity），因为把它图形化之后就像一个三角形：
<img src="../images/triangle_identity.png" alt="monad-同一律">
如果从左上角开始往右，可以看到 of 的确把 M a 丢到另一个 M 容器里去了。然后再往下 join，就得到了 M a，跟一开始就调用 id 的结果一样。从右上角往左，可以看到如果我们通过 map 进到了 M 里面，然后对普通值 a 调用 of，最后得到的还是 M (M a)；再调用一次 join 将会把我们带回原点，即 M a。</p>
<p>我要说明一点，尽管这里我写的是 of，实际上对任意的 monad 而言，都必须要使用明确的 M.of。</p>
<p>我已经见过这些定律了，同一律和结合律，以前就在哪儿见过…等一下，让我想想…是的！它们是范畴遵循的定律！不过这意味着我们需要一个组合函数来给出一个完整定义。见证吧：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">mcompose</span> <span class="token operator">=</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">chain</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// left identity</span>
<span class="token function">mcompose</span><span class="token punctuation">(</span><span class="token constant">M</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token operator">===</span> f<span class="token punctuation">;</span>

<span class="token comment">// right identity</span>
<span class="token function">mcompose</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token constant">M</span><span class="token punctuation">)</span> <span class="token operator">===</span> f<span class="token punctuation">;</span>

<span class="token comment">// associativity</span>
<span class="token function">mcompose</span><span class="token punctuation">(</span><span class="token function">mcompose</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">,</span> h<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">mcompose</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token function">mcompose</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>
      </div>
<p>毕竟它们是范畴学里的定律。monad 来自于一个叫 “Kleisli 范畴”的范畴，这个范畴里边所有的对象都是 monad，所有的态射都是联结函数（chained funtions）。我不是要在没有提供太多解释的情况下，拿范畴学里各式各样的概念来取笑你。我的目的是涉及足够多的表面知识，向你说明这中间的相关性，让你在关注日常实用特性之余，激发起对这些定律的兴趣。</p>
<h3 id="summary"><a href="#summary" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Summary</h3>
<p>monad 让我们深入到嵌套的运算当中，使我们能够在完全避免回调金字塔（pyramid of doom）情况下，为变量赋值，运行有序的作用，执行异步任务等等。当一个值被困在几层相同类型的容器中时，monad 能够拯救它。借助 “pointed” 这个可靠的帮手，monad 能够借给我们从盒子中取出的值，而且知道我们会在结束使用后还给它。</p>
<p>是的，monad 非常强大，但我们还需要一些额外的容器函数。比如，假设我们想同时运行一个列表里的 api 调用，然后再搜集返回的结果，怎么办？是可以使用 monad 实现这个任务，但必须要等每一个 api 完成后才能调用下一个。合并多个合法性验证呢？我们想要的肯定是持续验证以搜集错误列表，但是 monad 会在第一个 Left 登场的时候停掉整个演出。</p>
<p>下一章，我们将看到 applicative functor 如何融入这个容器世界，以及为何在很多情况下它比 monad 更好用。</p>]]></description><link>https://reactjs.org/blog/2018/09/02/FP14-Monad-1.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/09/02/FP14-Monad-1.html</guid><pubDate>Sat, 01 Sep 2018 16:00:00 GMT</pubDate></item></channel></rss>