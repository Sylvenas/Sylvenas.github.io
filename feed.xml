<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Little Forest]]></title><description><![CDATA[A JavaScript library for building user interfaces]]></description><link>https://reactjs.org</link><generator>RSS for Node</generator><lastBuildDate>Tue, 29 Jan 2019 03:17:12 GMT</lastBuildDate><item><title><![CDATA[FP18：Semigroup]]></title><description><![CDATA[<p>所谓<code>Semigroup</code>(半群)，其实就是含有concat方法的数据类型，典型的如字符串和数组，看代码：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> resStr <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span> 
<span class="token comment" spellcheck="true">// => 'abc'</span>

<span class="token keyword">const</span> resArr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// => [1,2,3,4,5,6]</span>
</code></pre>
      </div>
<p>实际上，我们还可以发现一个规律<code>Semigroup</code>是可以随意的合并操作的，什么意思呢？</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> resStr <span class="token operator">=</span> <span class="token string">'a'</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// => 'abc'</span>

<span class="token keyword">const</span> resArr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// => [1,2,3,4,5,6]</span>
</code></pre>
      </div>
<p>无论前后的顺序如何，或者无论怎么组合，得到的结果是一致的。
完全类似于数据的加法运算：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span> 
<span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">3</span>
<span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span>
</code></pre>
      </div>
<p>但是我们却不能直接使用<code>1.concat(2).concat(3)</code>这样的代码，因为number并没有实现<code>concat</code>方法，但是我们可以自己简单实现一个Sum的<code>Semigroup</code>。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> Sum <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> y <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token function">Sum</span><span class="token punctuation">(</span>x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token template-string"><span class="token string">`Sum(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
Sum<span class="token punctuation">.</span>empty <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>
</code></pre>
      </div>
<p>现在就可以直接这样使用Sum了：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> res1 <span class="token operator">=</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>Sum<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// => Sum(6)</span>
<span class="token keyword">const</span> res2 <span class="token operator">=</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// => Sum(6)</span>
</code></pre>
      </div>
<p>Sum的使用场景不是很多，仅仅是为了学习而建立的，下面看几个使用场景比较多的<code>Semigroup</code></p>
<ul>
<li>
<p>All:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span>  <span class="token comment" spellcheck="true">// true</span>
<span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">false</span> <span class="token comment" spellcheck="true">// false</span>
<span class="token punctuation">{</span>
<span class="token keyword">const</span> All <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> y <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token function">All</span><span class="token punctuation">(</span>x <span class="token operator">&amp;&amp;</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token template-string"><span class="token string">`All(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

All<span class="token punctuation">.</span>empty <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">All</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">All</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">All</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>All<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
</li>
<li>
<p>First:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token punctuation">{</span>
<span class="token keyword">const</span> First <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> _ <span class="token operator">=></span>
        <span class="token function">First</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token template-string"><span class="token string">`First(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token function">First</span><span class="token punctuation">(</span><span class="token string">'bob'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">First</span><span class="token punctuation">(</span><span class="token string">'smith'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
</li>
<li>
<p>Max &#x26; Min</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token punctuation">{</span>
<span class="token keyword">const</span> Max <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> y <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token function">Max</span><span class="token punctuation">(</span>x <span class="token operator">></span> y <span class="token operator">?</span> x <span class="token punctuation">:</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token template-string"><span class="token string">`Max(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

Max<span class="token punctuation">.</span>empty <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Max</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> Min <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    x<span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> x<span class="token punctuation">:</span> y <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token function">Min</span><span class="token punctuation">(</span>x <span class="token operator">&lt;</span> y <span class="token operator">?</span> x <span class="token punctuation">:</span> y<span class="token punctuation">)</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span>
        <span class="token template-string"><span class="token string">`Min(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

Min<span class="token punctuation">.</span>empty <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Min</span><span class="token punctuation">(</span><span class="token number">Infinity</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
</li>
<li>
<p>Either</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> Right <span class="token operator">=</span> x <span class="token operator">=></span>
<span class="token punctuation">(</span><span class="token punctuation">{</span>
    chain<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    ap<span class="token punctuation">:</span> other <span class="token operator">=></span> other<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    traverse<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token keyword">of</span><span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>Right<span class="token punctuation">)</span><span class="token punctuation">,</span>
    map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Right</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    fold<span class="token punctuation">:</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
    concat<span class="token punctuation">:</span> o <span class="token operator">=></span>
        o<span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>_ <span class="token operator">=></span> <span class="token function">Right</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>
            y <span class="token operator">=></span> <span class="token function">Right</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Right(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre>
      </div>
</li>
</ul>
<p>const Left = x =>
({
chain: f => Left(x),
ap: other => Left(x),
traverse: (of, f) => of(Left(x)),
map: f => Left(x),
fold: (f, g) => f(x),
concat: o =>
o.fold(_ => Left(x),
y => o),
inspect: () => <code>Left(${x})</code>
})</p>
<p>const fromNullable = x =>
x != null ? Right(x) : Left(null)</p>
<p>const tryCatch = f => {
try {
return Right(f())
} catch (e) {
return Left(e)
}
}</p>
<p>// List from <a href="https://github.com/DrBoolean/immutable-ext">https://github.com/DrBoolean/immutable-ext</a>
const stats = List.of({page:‘home’, view: 40},
{page:‘about’, view: 40},
{page:‘blog’})
state.foldMap(x =>
fromNullable(x.views).map(Sum),
Right(Sum.empty()))</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-none"><code></code></pre>
      </div>]]></description><link>https://reactjs.org/blog/2018/12/13/FP18-Semigroup.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/12/13/FP18-Semigroup.html</guid><pubDate>Wed, 12 Dec 2018 16:00:00 GMT</pubDate></item><item><title><![CDATA[FP17：Transform Naturally]]></title><description><![CDATA[<h3 id="令人生厌的嵌套"><a href="#%E4%BB%A4%E4%BA%BA%E7%94%9F%E5%8E%8C%E7%9A%84%E5%B5%8C%E5%A5%97" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>令人生厌的嵌套</h3>
<p>我想要提出一个关于嵌套的问题。但不是那种马上会唤起老母亲整理打扫天性的那种问题，而是我们马上会在之后的章节中遇到的问题。在任何情况下，我所谓的<em>嵌套</em>是将不同的两个类型套在同一个值上，某种意义上，看上去就像一个全新的类型。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token function">Right</span><span class="token punctuation">(</span><span class="token function">Maybe</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">IO</span><span class="token punctuation">(</span><span class="token function">Task</span><span class="token punctuation">(</span><span class="token function">IO</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token punctuation">[</span><span class="token function">Identity</span><span class="token punctuation">(</span><span class="token string">'bee thousand'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<p>现在，我们用一些精心制作的例证来说明仿佛我们已经能够摆脱这些常见的嵌套情形。但是实际上我们编码的时候，不同的类型就像耳机线一样乱成一团，仿佛一种恶魔召唤的邪恶产物。如果我们编码的时候不是一丝不苟地组织正在使用的类型，最后代码会比猫咪咖啡厅的披头族更加难以理解。</p>
<h3 id="一场情景喜剧"><a href="#%E4%B8%80%E5%9C%BA%E6%83%85%E6%99%AF%E5%96%9C%E5%89%A7" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>一场情景喜剧</h3>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// getValue :: Selector -> Task Error (Maybe String)</span>
<span class="token comment" spellcheck="true">// postComment :: String -> Task Error Comment</span>
<span class="token comment" spellcheck="true">// validate :: String -> Either ValidationError String</span>

<span class="token comment" spellcheck="true">// saveComment :: () -> Task Error (Maybe (Either ValidationError (Task Error Comment)))</span>
<span class="token keyword">const</span> saveComment <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>postComment<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>validate<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token string">'#comment'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<p>让类型声明形同虚设的坏家伙们都在这里了。容我稍微解释一下这一段代码。一开始，用<code>getValue('#comment')</code>获取用户输入，这是一个<code>action</code>，从一个<code>element</code>中获取文本。但是可能会因为字符串值不存在而获取失败，从而返回<code>Task Error(Maybe String)</code>。在这之后，我们需要<code>map</code>所有<code>Task</code>和<code>Maybe</code>传递文本到<code>validate</code>。最后，我们不是得到<code>ValiadtionError</code>或者想要的<code>String</code>。然后，从过层层 map，把当前<code>Task Error(Maybe(Either ValidationError String))</code>中的<code>String</code>传入<code>postComment</code>，最后返回<code>Task</code>的结果。
简直乱得骇人。一大堆抽象类型乱得像一幅业余表现主义的烂作，还混杂着波洛克式的多态，蒙德里安风的大统一。对于这种常见的情况，有许多解决方法。把这些类型编好弄成一个巨大的容器，分类后再<code>join</code>，将其同化，解构，等等。而重点，就在于通过 <em>Natural Transformations</em> 将他们同化。</p>
<h3 id="全都很自然"><a href="#%E5%85%A8%E9%83%BD%E5%BE%88%E8%87%AA%E7%84%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>全都很自然</h3>
<p><em>Natural Transformations</em>是“functor 之间的态射”，就是，一个操作容器本身的函数。类型上来说，它是个函数<code>(Functor f, Functor g) => f a -> g a</code>。让这个函数特殊的是，在任何情况下，都不能得知 functor 中的内容。就像两个党派交换机密文件，都会把东西封在马尼拉纸信封里，戳上“最高机密”。这是一个结构上的操作。functor 外壳的变化。形式上，<em>Natural Transformations</em> 作用于如下功能：</p>
<html><head></head><body></body></html>
<p>或者代码:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// nt :: (Functor f, Functor g) => f a -> g a</span>
<span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> nt<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">compose</span><span class="token punctuation">(</span>nt<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<p>两者都体现了同样的东西：我们可以先自然变换再<code>map</code>，或者先<code>map</code>再自然变换，结果都是一样的。顺便，在 <a href="ch7.md#free-as-in-theorem">free theorem</a> 中，也提到，自然变换不仅局限于函数和类型（以及 functor）。</p>
<h3 id="有原则的类型转换"><a href="#%E6%9C%89%E5%8E%9F%E5%88%99%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>有原则的类型转换</h3>
<p>作为程序员，我们对类型转换十分熟悉。我们经常把<code>String</code>转换成<code>Boolean</code>，或者<code>Integer</code> 转换成<code>Float</code>（虽然<code>JavaScript</code>只有<code>Number</code>）。这些类型之间的区别很简单，这些类型都是一些代数容器，我们手头有一些可以运用的理论。</p>
<p>以下是一些例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// idToMaybe :: Identity a -> Maybe a</span>
<span class="token keyword">const</span> idToMaybe <span class="token operator">=</span> x <span class="token operator">=></span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>$value<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// idToIO :: Identity a -> IO a</span>
<span class="token keyword">const</span> idToIO <span class="token operator">=</span> x <span class="token operator">=></span> IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>$value<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// eitherToTask :: Either a b -> Task a b</span>
<span class="token keyword">const</span> eitherToTask <span class="token operator">=</span> <span class="token function">either</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span>rejected<span class="token punctuation">,</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// ioToTask :: IO a -> Task () a</span>
<span class="token keyword">const</span> ioToTask <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">resolve</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span><span class="token function">unsafePerform</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// maybeToTask :: Maybe a -> Task () a</span>
<span class="token keyword">const</span> maybeToTask <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>isNothing <span class="token operator">?</span> Task<span class="token punctuation">.</span><span class="token function">rejected</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>$value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// arrayToMaybe :: [a] -> Maybe a</span>
<span class="token keyword">const</span> arrayToMaybe <span class="token operator">=</span> x <span class="token operator">=></span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<p>看到了吗？这些只是从一个 functor 换到了另一个。在转换过程中的数据丢失是被允许的，只要要被<code>map</code>的数据在转换（shape shift shuffle）中不会消失即可。这就是重点，<code>map</code>必须以定义执行，就算在转换之后。</p>
<p>从另一个角度来看，转换的是某个作用（effects）。由此可以认为，<code>ioToTask</code>就是从同步到异步的转换，和<code>arrayToMaybe</code>是从非确定性到可能失败。要注意的是，在<code>JavaScript</code> 里，并不能把异步变到同步，无法实现<code>taskToIO</code>方法，那是个”超自然”变换。</p>
<h3 id="方法狂-feature-envy"><a href="#%E6%96%B9%E6%B3%95%E7%8B%82-feature-envy" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>方法狂 Feature Envy</h3>
<p>假设要使用一些其他类型的方法（feature），比如对一个<code>List</code>进行<code>sortBy</code>。<em>Natural Transformations</em> 提供了变换为目标类型的巧妙方式，只要该类型支持<code>map</code>操作。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// arrayToList :: [a] -> List a</span>
<span class="token keyword">const</span> arrayToList <span class="token operator">=</span> List<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> doListyThings <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">sortBy</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">filter</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">,</span> arrayToList<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> doListyThings_ <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">sortBy</span><span class="token punctuation">(</span>h<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">filter</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> arrayToList<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// law applied</span>
</code></pre>
      </div>
<p>捏一把鼻子，颠三下魔杖，放进<code>arrayToList</code>，当当当当，<code>[a]</code>变成了<code>List a</code>，甚至还可以对其<code>sortBy</code>。</p>
<p>此外，如<code>doListyThings_</code>所示，将映射操作<code>map(f)</code>移到 <em>Natural Transformations</em> 的左边，更加容易实现函数的优化或者复合。</p>
<h3 id="同构的-javascript-isomorphic-javascript"><a href="#%E5%90%8C%E6%9E%84%E7%9A%84-javascript-isomorphic-javascript" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同构的 JavaScript Isomorphic JavaScript</h3>
<p>当把一个值前后怎么转换都不会丢失任何数据时，可称之为 <em>同构 Isomorphic</em> 。看上去挺高大上，不过就是“保持相同的数据”而已。如果两个类型在 <em>Natural Transformations</em> 中既可以<code>to</code>也可以<code>from</code> ，就被称之为是 <em>同构 Isomorphic</em> ，证明如下：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// promiseToTask :: Promise a b -> Task a b</span>
<span class="token keyword">const</span> promiseToTask <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span> <span class="token operator">=></span> x<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>reject<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// taskToPromise :: Task a b -> Promise a b</span>
<span class="token keyword">const</span> taskToPromise <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span> x<span class="token punctuation">.</span><span class="token function">fork</span><span class="token punctuation">(</span>reject<span class="token punctuation">,</span> resolve<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> x <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'ring'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">taskToPromise</span><span class="token punctuation">(</span><span class="token function">promiseToTask</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> x<span class="token punctuation">;</span>

<span class="token keyword">const</span> y <span class="token operator">=</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">'rabbit'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">promiseToTask</span><span class="token punctuation">(</span><span class="token function">taskToPromise</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">===</span> y<span class="token punctuation">;</span>
</code></pre>
      </div>
<p>证毕。</p>
<p><code>Promise</code>与<code>Task</code>是 <em>同构 Isomorphic</em> 。也可以实现方法<code>listToArray</code>使之与<code>arrayToList</code>构成  <em>同构Isomorphism</em>。反之，与 <code>arrayToMaybe</code>无法 <em>同构 Isomorphism</em>，因为转换时有数据丢失。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// maybeToArray :: Maybe a -> [a]</span>
<span class="token keyword">const</span> maybeToArray <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>isNothing <span class="token operator">?</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">:</span> <span class="token punctuation">[</span>x<span class="token punctuation">.</span>$value<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// arrayToMaybe :: [a] -> Maybe a</span>
<span class="token keyword">const</span> arrayToMaybe <span class="token operator">=</span> x <span class="token operator">=></span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'elvis costello'</span><span class="token punctuation">,</span> <span class="token string">'the attractions'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// 不 isomorphic</span>
<span class="token function">maybeToArray</span><span class="token punctuation">(</span><span class="token function">arrayToMaybe</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// ['elvis costello']</span>

<span class="token comment" spellcheck="true">// 但是是一个 natural transformation</span>
<span class="token function">compose</span><span class="token punctuation">(</span>arrayToMaybe<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'elvis'</span><span class="token punctuation">,</span> <span class="token string">'lou'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Just('lou costello')</span>
<span class="token comment" spellcheck="true">// ==</span>
<span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'elvis'</span><span class="token punctuation">,</span> <span class="token string">'lou'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> arrayToMaybe<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Just('lou costello')</span>
</code></pre>
      </div>
<p>这就是 <em>Natural Transformations</em>，然而，因为两边的<code>map</code>都得到相同的结果。行文到本章的一半，似乎已经将 <em>Isomorphic</em> 说的差不多了，但是可别被这些表象所迷惑，真正的 <em>Isomorphic</em> 比我们想象的要广泛，有用的多。话不多说，让我们继续。</p>
<h3 id="更加宽泛的定义"><a href="#%E6%9B%B4%E5%8A%A0%E5%AE%BD%E6%B3%9B%E7%9A%84%E5%AE%9A%E4%B9%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>更加宽泛的定义</h3>
<p>这些结构函数绝不仅仅局限于类型转换。
以下是一些不同的例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code>reverse <span class="token punctuation">:</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span>

join <span class="token punctuation">:</span><span class="token punctuation">:</span> <span class="token punctuation">(</span>Monad m<span class="token punctuation">)</span> <span class="token operator">=></span> m <span class="token punctuation">(</span>m a<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> m a

head <span class="token punctuation">:</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>a<span class="token punctuation">]</span> <span class="token operator">-</span><span class="token operator">></span> a

<span class="token keyword">of</span> <span class="token punctuation">:</span><span class="token punctuation">:</span> a <span class="token operator">-</span><span class="token operator">></span> f a
</code></pre>
      </div>
<p>Natural Transformations 的法则同样适用于上述方法。其中可能让你有点疑惑的是，<code>head :: [a] -> a</code>可以被看做成<code>head :: [a] -> Identity a</code>。在其中的任何地方，都可以插入<code>Identity</code>，因为<code>a</code>与<code>Identity a</code>为 Isomorphic。（看，我说过 <em>Isomorphic</em> 用途很广泛吧）</p>
<h3 id="实现单层嵌套的方法"><a href="#%E5%AE%9E%E7%8E%B0%E5%8D%95%E5%B1%82%E5%B5%8C%E5%A5%97%E7%9A%84%E6%96%B9%E6%B3%95" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>实现单层嵌套的方法</h3>
<p>回到之前的场景。在其中试试 <em>Natural Transformations</em>，使调用中的各个类型统一化，从而可以将函数<code>join</code>起来。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// getValue :: Selector -> Task Error (Maybe String)</span>
<span class="token comment" spellcheck="true">// postComment :: String -> Task Error Comment</span>
<span class="token comment" spellcheck="true">// validate :: String -> Either ValidationError String</span>

<span class="token comment" spellcheck="true">// saveComment :: () -> Task Error Comment</span>
<span class="token keyword">const</span> saveComment <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token function">chain</span><span class="token punctuation">(</span>postComment<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">chain</span><span class="token punctuation">(</span>eitherToTask<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span>validate<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">chain</span><span class="token punctuation">(</span>maybeToTask<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token string">'#comment'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<p>这里具体的操作仅仅加入了<code>chain(maybeToTask)</code>和<code>chain(eigherToTack)</code>。都是同样的效果。在<code>join</code>时很自然的将<code>Task</code>的 functor 转换到另一个<code>Task</code>的 functor。就像窗边的尖刺驱鸟器，从源头扼杀了嵌套。就像他们巴黎（city of the light）人说的：“Mieux vaut prévenir que guérir” - 花一英镑去治疗不如花一盎司用于预防。</p>
<h3 id="小结"><a href="#%E5%B0%8F%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>小结</h3>
<p><em>Natural Transformations</em>是操作 functor 的方法。在范畴学中是非常重要的概念，特别是采用多种抽象化机制时，就会用的更多。上述例子，仅仅局限于几个具体的应用中。如上文所言，只要转换类型时,确保可组合性，即可以实现所需要的不同作用 effects。同时可以解决嵌套问题，虽然会将类型同化到最低的共同母类（lowest common denominator），在实际应用中，一般是作用最易变的函子（通常是<code>Task</code> ）（functor with most volatile effects）。</p>
<p>这种连续而冗长的类型是实现的代价 - 从以太中召唤而来。当然，隐式作用（implicit effects）更有潜在风险，所以也算是合理的方案。不过,如果想归并大量类型，还需要更多的工具。之后，我们将通过 <em>Traverable</em> 讨论重组类型。</p>]]></description><link>https://reactjs.org/blog/2018/12/11/FP17-Transform-Naturally.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/12/11/FP17-Transform-Naturally.html</guid><pubDate>Mon, 10 Dec 2018 16:00:00 GMT</pubDate></item><item><title><![CDATA[FP16：Applicative Functor]]></title><description><![CDATA[<h3 id="applicative-functor"><a href="#applicative-functor" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Applicative Functor</h3>
<h4 id="应用-applicative-functor"><a href="#%E5%BA%94%E7%94%A8-applicative-functor" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>应用 applicative functor</h4>
<p>考虑到其函数式的出身，<strong>applicative functor</strong> 这个名称堪称简单明了。函数式程序员最为人诟病的一点就是，总喜欢搞一些稀奇古怪的命名，比如 <code>mappend</code> 或者 <code>liftA4</code>。诚然，此类名称出现在数学实验室是再自然不过的，但是放在其他任何语境下，这些概念就都像是扮作达斯维达去汽车餐馆搞怪的人。</p>
<p>无论如何，applicative 这个名字应该能够向我们表明一些事实，告诉我们作为一个接口，它能为我们带来什么：那就是让不同 functor 可以相互应用（apply）的能力。</p>
<p>然而，你可能会问了，为何一个正常的、理性的人，比如你自己，会做这种“让不同 functor 相互应用”的事？而且，“相互应用”到底<em>是什么意思</em>？</p>
<p>要回答这些问题，我们可以从下面这个场景讲起，可能你已经碰到过这种场景了。假设有两个同类型的 functor，我们想把这两者作为一个函数的两个参数传递过去来调用这个函数。简单的例子比如让两个 <code>Container</code> 的值相加：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// 这样是行不通的，因为 2 和 3 都藏在瓶子里。</span>
<span class="token function">add</span><span class="token punctuation">(</span>Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//NaN</span>

<span class="token comment" spellcheck="true">// 使用可靠的 map 函数试试</span>
<span class="token keyword">const</span> container_of_add_2 <span class="token operator">=</span> <span class="token function">map</span><span class="token punctuation">(</span>add<span class="token punctuation">,</span> Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Container(add(2))</span>
</code></pre>
      </div>
<p>这时候我们创建了一个 <code>Container</code>，它内部的值是一个局部调用的（partially applied）的函数。确切点讲就是，我们想让 <code>Container(add(2))</code> 中的 <code>add(2)</code> 应用到 <code>Container(3)</code> 中的 <code>3</code> 上来完成调用。也就是说，我们想把一个 functor 应用到另一个上。</p>
<p>巧的是，完成这种任务的工具已经存在了，即 <code>chain</code> 函数。我们可以先 <code>chain</code> 然后再 <code>map</code> 那个局部调用的 <code>add(2)</code>，就像这样：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code>Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<p>只不过，这种方式有一个问题，那就是 monad 的顺序执行问题：所有的代码都只会在前一个 monad 执行完毕之后才执行。想想看，我们的这两个值足够强健且相互独立，如果仅仅为了满足 monad 的顺序要求而延迟 <code>Container(3)</code> 的创建，我觉得是非常没有必要的。</p>
<p>事实上，当遇到这种问题的时候，要是能够无需借助这些不必要的函数和变量，以一种简明扼要的方式把一个 functor 的值应用到另一个上去就好了。</p>
<h3 id="瓶中之船"><a href="#%E7%93%B6%E4%B8%AD%E4%B9%8B%E8%88%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>瓶中之船</h3>
<html><head></head><body></body></html>
<p><code>ap</code> 就是这样一种函数，能够把一个 functor 的函数值应用到另一个 functor 的值上。把这句话快速地说上 5 遍。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code>Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Container(5)</span>

<span class="token comment" spellcheck="true">// all together now</span>
Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Container(5)</span>
</code></pre>
      </div>
<p>这样就大功告成了，而且代码干净整洁。可以看到，<code>Container(3)</code> 从嵌套的 monad 函数的牢笼中释放了出来。需要再次强调的是，本例中的 <code>add</code> 是被 <code>map</code> 所局部调用（partially apply）的，所以 <code>add</code> 必须是一个 curry 函数。</p>
<p>可以这样定义一个 <code>ap</code> 函数：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code>Container<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>ap <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>other_container<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> other_container<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>__value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
<p>记住，<code>this.__value</code> 是一个函数，将会接收另一个 functor 作为参数，所以我们只需 <code>map</code> 它。由此我们可以得出 applicative functor 的定义：</p>
<blockquote>
<p>applicative functor 是实现了 <code>ap</code> 方法的 pointed functor</p>
</blockquote>
<p>注意 <code>pointed</code> 这个前提，这是非常重要的一个前提，下面的例子会说明这一点。</p>
<p>讲到这里，我已经感受到你的疑虑了（也或者是困惑和恐惧）；心态开放点嘛，<code>ap</code> 还是很有用的。在深入理解这个概念之前，我们先来探索一个特性。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code>F<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token operator">==</span> F<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>F<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
      </div>
<p>这行代码翻译成人类语言就是，map 一个 <code>f</code> 等价于 <code>ap</code> 一个值为 <code>f</code> 的 functor。或者更好的译法是，你既可以把 <code>x</code> 放到容器里然后调用 <code>map(f)</code>，也可以同时让 <code>f</code> 和 <code>x</code> 发生 lift（参看第 8 章），然后对他们调用 <code>ap</code>。这让我们能够以一种从左到右的方式编写代码：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code>Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Maybe(5)</span>

Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Task(5)</span>
</code></pre>
      </div>
<p>细心的读者可能发现了，上述代码中隐约有普通函数调用的影子。没关系，我们稍后会学习 <code>ap</code> 的 pointfree 版本；暂时先把这当作此类代码的推荐写法。通过使用 <code>of</code>，每一个值都被输送到了各个容器里的奇幻之地，就像是在另一个平行世界里，每个程序都可以是异步的或者是 null 或者随便什么值，而且不管是什么，<code>ap</code> 都能在这个平行世界里针对这些值应用各种各样的函数。这就像是在一个瓶子中造船。</p>
<p>你注意到没？上例中我们使用了 <code>Task</code>，这是 applicative functor 主要的用武之地。现在我们来看一个更深入的例子。</p>
<h3 id="协调与激励"><a href="#%E5%8D%8F%E8%B0%83%E4%B8%8E%E6%BF%80%E5%8A%B1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>协调与激励</h3>
<p>假设我们要创建一个旅游网站，既需要获取游客目的地的列表，还需要获取地方事件的列表。这两个请求就是相互独立的 api 调用。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// Http.get :: String -> Task Error HTML</span>

<span class="token keyword">var</span> renderPage <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>destinations<span class="token punctuation">,</span> events<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* render page */</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>renderPage<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/destinations'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/events'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// Task("&lt;div>some page with dest and events&lt;/div>")</span>
</code></pre>
      </div>
<p>两个请求将会同时立即执行，当两者的响应都返回之后，<code>renderPage</code> 就会被调用。这与 monad 版本的那种必须等待前一个任务完成才能继续执行后面的操作完全不同。本来我们就无需根据目的地来获取事件，因此也就不需要依赖顺序执行。</p>
<p>再次强调，因为我们是使用局部调用的函数来达成上述结果的，所以必须要保证 <code>renderpage</code> 是 curry 函数，否则它就不会一直等到两个 <code>Task</code> 都完成。而且如果你碰巧自己做过类似的事，那你一定会感激 <code>applicative functor</code> 这个异常简洁的接口的。这就是那种能够让我们离“奇点”（singularity）更近一步的优美代码。</p>
<p>再来看另外一个例子。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// 帮助函数：</span>
<span class="token comment" spellcheck="true">// ==============</span>
<span class="token comment" spellcheck="true">//  $ :: String -> IO DOM</span>
<span class="token keyword">var</span> $ <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">//  getVal :: String -> IO String</span>
<span class="token keyword">var</span> getVal <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">prop</span><span class="token punctuation">(</span><span class="token string">'value'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> $<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// Example:</span>
<span class="token comment" spellcheck="true">// ===============</span>
<span class="token comment" spellcheck="true">//  signIn :: String -> String -> Bool -> User</span>
<span class="token keyword">var</span> signIn <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">,</span> remember_me<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* signing in */</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>

IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>signIn<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">getVal</span><span class="token punctuation">(</span><span class="token string">'#email'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">getVal</span><span class="token punctuation">(</span><span class="token string">'#password'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// IO({id: 3, email: "gg@allin.com"})</span>
</code></pre>
      </div>
<p><code>signIn</code> 是一个接收 3 个参数的 curry 函数，因此我们需要调用 <code>ap</code> 3 次。在每一次的 <code>ap</code> 调用中，<code>signIn</code> 就收到一个参数然后运行，直到所有的参数都传进来，它也就执行完毕了。我们可以继续扩展这种模式，处理任意多的参数。另外，左边两个参数在使用 <code>getVal</code> 调用后自然而然地成为了一个 <code>IO</code>，但是最右边的那个却需要手动 <code>lift</code>，然后变成一个 <code>IO</code>，这是因为 <code>ap</code> 需要调用者及其参数都属于同一类型。</p>
<h3 id="lift"><a href="#lift" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>lift</h3>
<p>我们来试试以一种 pointfree 的方式调用 applicative functor。因为 <code>map</code> 等价于 <code>of/ap</code>，那么我们就可以定义无数个能够 <code>ap</code> 通用函数。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">var</span> liftA2 <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> functor1<span class="token punctuation">,</span> functor2<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> functor1<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">var</span> liftA3 <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> functor1<span class="token punctuation">,</span> functor2<span class="token punctuation">,</span> functor3<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> functor1<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor3<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//liftA4, etc</span>
</code></pre>
      </div>
<p><code>liftA2</code> 是个奇怪的名字，听起来像是破败工厂里挑剔的货运电梯，或者伪豪华汽车公司的个性车牌。不过你要是真正理解了，那么它的含义也就不证自明了：让那些小代码块发生 lift，成为 applicative functor 中的一员。</p>
<p>刚开始我也觉得这种 2-3-4 的写法没什么意义，看起来又丑又没有必要，毕竟我们可以在 JavaScript 中检查函数的参数数量然后再动态地构造这样的函数。不过，局部调用（partially apply）<code>liftA(N)</code> 本身，有时也能发挥它的用处，这样的话，参数数量就固定了。</p>
<p>来看看实际用例：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// checkEmail :: User -> Either String Email</span>
<span class="token comment" spellcheck="true">// checkName :: User -> Either String String</span>

<span class="token comment" spellcheck="true">//  createUser :: Email -> String -> IO User</span>
<span class="token keyword">var</span> createUser <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>email<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* creating... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Either<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>createUser<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">checkEmail</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">checkName</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Left("invalid email")</span>

<span class="token function">liftA2</span><span class="token punctuation">(</span>createUser<span class="token punctuation">,</span> <span class="token function">checkEmail</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">checkName</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Left("invalid email")</span>
</code></pre>
      </div>
<p><code>createUser</code> 接收两个参数，因此我们使用的是 <code>liftA2</code>。上述两个语句是等价的，但是使用了 <code>liftA2</code> 的版本没有提到 <code>Either</code>，这就使得它更加通用灵活，因为不必与特定的数据类型耦合在一起。</p>
<p>我们试试以这种方式重写前一个例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token function">liftA2</span><span class="token punctuation">(</span>add<span class="token punctuation">,</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Maybe(5)</span>

<span class="token function">liftA2</span><span class="token punctuation">(</span>renderPage<span class="token punctuation">,</span> Http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/destinations'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/events'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// Task("&lt;div>some page with dest and events&lt;/div>")</span>

<span class="token function">liftA3</span><span class="token punctuation">(</span>signIn<span class="token punctuation">,</span> <span class="token function">getVal</span><span class="token punctuation">(</span><span class="token string">'#email'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getVal</span><span class="token punctuation">(</span><span class="token string">'#password'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// IO({id: 3, email: "gg@allin.com"})</span>
</code></pre>
      </div>
<h3 id="操作符"><a href="#%E6%93%8D%E4%BD%9C%E7%AC%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>操作符</h3>
<p>在 haskell、scala、PureScript 以及 swift 等语言中，开发者可以创建自定义的中缀操作符（infix operators），所以你能看到到这样的语法：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-hs"><code>-- haskell
add <$> Right 2 <*> Right 3</code></pre>
      </div>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// JavaScript</span>
<span class="token function">map</span><span class="token punctuation">(</span>add<span class="token punctuation">,</span> <span class="token function">Right</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">Right</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
      </div>
<p><code>&#x3C;$></code> 就是 <code>map</code>（亦即 <code>fmap</code>），<code>&#x3C;*></code> 不过就是 <code>ap</code>。这样的语法使得开发者可以以一种更自然的风格来书写函数式应用，而且也能减少一些括号。</p>
<h3 id="免费开瓶器"><a href="#%E5%85%8D%E8%B4%B9%E5%BC%80%E7%93%B6%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>免费开瓶器</h3>
<html><head></head><body></body></html>
<p>我们尚未对衍生函数（derived function）着墨过多。不过看到本书介绍的所有这些接口都互相依赖并遵守一些定律，那么我们就可以根据一些强接口来定义一些弱接口了。</p>
<p>比如，我们知道一个 applicative 首先是一个 functor，所以如果已经有一个 applicative 实例的话，毫无疑问可以依此定义一个 functor。</p>
<p>这种完美的计算上的大和谐（computational harmony）之所以存在，是因为我们在跟一个数学“框架”打交道。哪怕是莫扎特在小时候就下载了 ableton（译者注：一款专业的音乐制作软件），他的钢琴也不可能弹得更好。</p>
<p>前面提到过，<code>of/ap</code> 等价于 <code>map</code>，那么我们就可以利用这点来定义 <code>map</code>：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// 从 of/ap 衍生出的 map</span>
X<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>map <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>constructor<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
<p>monad 可以说是处在食物链的顶端，因此如果已经有了一个 <code>chain</code> 函数，那么就可以免费得到 functor 和 applicative：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// 从 chain 衍生出的 map</span>
X<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>map <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> m<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment" spellcheck="true">// 从 chain/map 衍生出的 ap</span>
X<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>ap <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> other<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<p>定义一个 monad，就既能得到 applicative 也能得到 functor。这一点非常强大，相当于这些“开瓶器”全都是免费的！我们甚至可以审查一个数据类型，然后自动化这个过程。</p>
<p>应该要指出来的一点是，<code>ap</code> 的魅力有一部分就来自于并行的能力，所以通过 <code>chain</code> 来定义它就失去了这种优化。即便如此，开发者在设计出最佳实现的过程中就能有一个立即可用的接口，也是很好的。</p>
<p>为啥不直接使用 monad？因为最好用合适的力量来解决合适的问题，一分不多，一分不少。这样就能通过排除可能的功能性来做到最小化认知负荷。因为这个原因，相比 monad，我们更倾向于使用 applicative。</p>
<p>向下的嵌套结构使得 monad 拥有串行计算、变量赋值和暂缓后续执行等独特的能力。不过见识到 applicative 的实际用例之后，你就不必再考虑上面这些问题了。</p>
<p>下面，来看看理论知识。</p>
<h3 id="定律"><a href="#%E5%AE%9A%E5%BE%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>定律</h3>
<p>就像我们探索过的其他数学结构一样，我们在日常编码中也依赖 applicative functor 一些有用的特性。首先，你应该知道 applicative functor 是“组合关闭”（closed under composition）的，意味着 <code>ap</code> 永远不会改变容器类型（另一个胜过 monad 的原因）。这并不是说我们无法拥有多种不同的作用——我们还是可以把不同的类型压栈的，只不过我们知道它们将会在整个应用的过程中保持不变。</p>
<p>下面的例子可以说明这一点：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code>  <span class="token keyword">var</span> tOfM <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">,</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token function">liftA2</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>concat<span class="token punctuation">,</span> <span class="token function">tOfM</span><span class="token punctuation">(</span><span class="token string">'Rainy Days and Mondays'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">tOfM</span><span class="token punctuation">(</span><span class="token string">' always get me down'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token comment" spellcheck="true">// Task(Maybe(Rainy Days and Mondays always get me down))</span>
</code></pre>
      </div>
<p>你看，不必担心不同的类型会混合在一起。</p>
<p>该去看看我们最喜欢的范畴学定律了：<em>同一律</em>（identity）。</p>
<h3 id="同一律（identity）"><a href="#%E5%90%8C%E4%B8%80%E5%BE%8B%EF%BC%88identity%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同一律（identity）</h3>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// 同一律</span>
A<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">==</span> v
</code></pre>
      </div>
<p>是的，对一个 functor 应用 <code>id</code> 函数不会改变 <code>v</code> 里的值。比如：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">var</span> v <span class="token operator">=</span> Identity<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"Pillow Pets"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Identity<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">==</span> v
</code></pre>
      </div>
<p><code>Identity.of(id)</code> 的“无用性”让我不禁莞尔。这里有意思的一点是，就像我们之前证明了的，<code>of/ap</code> 等价于 <code>map</code>，因此这个同一律遵循的是 functor 的同一律：<code>map(id) == id</code>。</p>
<p>使用这些定律的优美之处在于，就像一个富有激情的幼儿园健身教练让所有的小朋友都能愉快地一块玩耍一样，它们能够强迫所有的接口都能完美结合。</p>
<h3 id="同态（homomorphism）"><a href="#%E5%90%8C%E6%80%81%EF%BC%88homomorphism%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同态（homomorphism）</h3>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// 同态</span>
A<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> A<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
      </div>
<p><em>同态</em>就是一个能够保持结构的映射（structure preserving map）。实际上，functor 就是一个在不同范畴间的同态，因为 functor 在经过映射之后保持了原始范畴的结构。</p>
<p>事实上，我们不过是把普通的函数和值放进了一个容器，然后在里面进行各种计算。所以，不管是把所有的计算都放在容器里（等式左边），还是先在外面进行计算然后再放到容器里（等式右边），其结果都是一样的。</p>
<p>一个简单例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code>Either<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>toUpper<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Either<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"oreos"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> Either<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">toUpper</span><span class="token punctuation">(</span><span class="token string">"oreos"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
      </div>
<h3 id="互换（interchange）"><a href="#%E4%BA%92%E6%8D%A2%EF%BC%88interchange%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>互换（interchange）</h3>
<p>互换（interchange）表明的是选择让函数在 <code>ap</code> 的左边还是右边发生 lift 是无关紧要的。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// 互换</span>
v<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>A<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> A<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
</code></pre>
      </div>
<p>这里有个例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">var</span> v <span class="token operator">=</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>reverse<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">'Sparklehorse'</span><span class="token punctuation">;</span>

v<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
</code></pre>
      </div>
<h3 id="组合（composition）"><a href="#%E7%BB%84%E5%90%88%EF%BC%88composition%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>组合（composition）</h3>
<p>最后是组合。组合不过是在检查标准的函数组合是否适用于容器内部的函数调用。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// 组合</span>
A<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>compose<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">==</span> u<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">var</span> u <span class="token operator">=</span> IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>toUpper<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> v <span class="token operator">=</span> IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"&amp; beyond"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> w <span class="token operator">=</span> IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"blood bath "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>compose<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">==</span> u<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
      </div>
<h3 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>
<p>处理多个 functor 作为参数的情况，是 applicative functor 一个非常好的应用场景。借助 applicative functor，我们能够在 functor 的世界里调用函数。尽管已经可以通过 monad 达到这个目的，但在不需要 monad 的特定功能的时候，我们还是更倾向于使用 applicative functor。</p>
<p>至此我们已经基本介绍完容器的 api 了，我们学会了如何对函数调用 <code>map</code>、<code>chain</code> 和 <code>ap</code>。下一章，我们将学习如何更好地处理多个 functor，以及如何以一种原则性的方式拆解它们。</p>]]></description><link>https://reactjs.org/blog/2018/11/07/FB16-Applicative-Functor.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/11/07/FB16-Applicative-Functor.html</guid><pubDate>Tue, 06 Nov 2018 16:00:00 GMT</pubDate></item><item><title><![CDATA[FP15：Monad-2]]></title><description><![CDATA[<blockquote>
<p>“A monad is just a monoid in the category of endofunctors. What’s the problem?”</p>
</blockquote>
<p>Monad是非常简单的，但是它的概念却有点让人云里雾里，尤其是网上查询资料博客的时候，一般会从范畴论开始讲解，这是正确的道路，不过可惜的是大部分的JavaScript开发人员，并不懂范畴论，范畴不仅仅是一种数学语言，也是一种哲学观点，范畴论也绝不是一两篇文章就能讲清楚的，这里我们不过多的去说明范畴论，而仅仅是谈论一下在计算机编程中的Monad的概念</p>
<p>Monad是一种组合函数的方法，除了返回值之外，还需要上下文，比如计算，if/else分支，IO等等。Monad可以类型提升，并且扁平化的映射<code>a -> M(b)</code>,使函数可组合，可以把类型a的数据映射成数据b的类型，并隐藏了实现的细节</p>
<blockquote>
<p>这里说的上下文不同于函数执行上下文，这里的上下文，仅仅是只数据的外部环境，或者是某种Wrapper、Box之类的概念，例如数组的仅仅是对数据的一种包裹，但是却可以提供很多的便捷的方法</p>
</blockquote>
<ul>
<li>Function map:<code>a=>b</code></li>
<li>Functor map with context:<code>Functor(a) => Functor(b)</code></li>
<li>Monad flatten and map with context:<code>Monad(Monad(a)) => Monad(b)</code></li>
</ul>
<p>上面所说的：<code>map</code>，<code>flatten</code>,<code>context</code>又是什么意思呢？</p>
<ul>
<li>Map的意思是说，使用参数a调用一个函数，计算之后，函数返回值为b. Given some input, return some output.</li>
<li>Context是组合Monad的计算细节，这里和Functor类似，我们可以直接调用<code>fmap</code>之类的方法，却无需关心实现的细节，这样我们就可以放心的在上下文环境中，完成从数据a,到数据b的映射，并返回处于同样上下文中的b，eg:<code>Array(a) => Array(b)</code>,<code>Observable(a) => Observable(b)</code></li>
<li>Type lift意味着将数据提升到上下文中,这样可以方便的使用上下文的方法，<code>a => Functor(a)</code>,Monad只不过是更强大的Functor，eg:字符串’abc’,‘xyz’，把他们做个类型提升：<code>['abc','xyz']</code>,那么就可以方便快捷的，使用数据的map,filter等等方法了，借助Functor可以提升任何类型的数据</li>
<li>Flatten是从上下文中取出数据<code>Functor(a) => a</code>,去除包装，取出果实，有可能一个值是被层层包装的，那么就是层层的去除包装来扁平化，类似于拨洋葱一样一层一层的去除外衣</li>
</ul>
<p>Example:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// Some data of type `a`</span>
<span class="token keyword">const</span> f <span class="token operator">=</span> n <span class="token operator">=></span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// A function from `a` to `b`</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// The type lift.</span>
<span class="token comment" spellcheck="true">// JS has type lift sugar for arrays: [x]</span>
<span class="token comment" spellcheck="true">// .map() applies the function f to the value x</span>
<span class="token comment" spellcheck="true">// in the context of the array.</span>
<span class="token keyword">const</span> result <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [40]</span>
</code></pre>
      </div>
<p>在这个例子中，Array就是<code>context</code>,<code>x</code>是被包裹的值。</p>
<p>这个例子中没有包含，数组中的数组，但是使用concat扁平化数组，绝不陌生：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>concat<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// [1, 2, 3, 4]</span>
</code></pre>
      </div>
<h3 id="youre-probably-already-using-monads"><a href="#youre-probably-already-using-monads" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>You’re probably already using monads</h3>
<p>函数组合创建数据流经的函数管道。您在管道的第一阶段输入了一些输入，并且一些数据从管道的最后一个阶段弹出，进行了转换。但要实现这一点，管道的每个阶段都必须期望前一阶段返回的数据类型。</p>
<p>编写简单的函数很容易，因为类型都很容易排列。只需将输出类型b的函数<code>g</code>与输入类型b的函数<code>f</code>匹配即可：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-none"><code>g: a => b
f: b => c
h = f(g(a)): a => c</code></pre>
      </div>
<p>如果是在<code>Functor</code>中进行组合或者连续调用，也非常简单，因为永远都是相同的Wrapper类型：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-none"><code>g: F(a) => F(b)
f: F(b) => F(c)
h = f(g(Fa)): F(a) => F(c)</code></pre>
      </div>
<p>但是如果你想组合的函数是<code>a => F(b)</code>,<code>b => F(c)</code>,这个时候就需要Monad了，使用<code>M</code>Functor替换一下<code>F</code>,让问题更清晰一些：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-none"><code>g: a => M(b)
f: b => M(c)
h = composeM(f, g): a => M(c)</code></pre>
      </div>
<p>Oops.这个时候发现类型对应不上，<code>f</code>函数的输入我们想要的是类型<code>b</code>,但是我们得到的却是类型<code>M(b)</code>,由于这中错位，在<code>composeM</code>中，我们需要从函数<code>g</code>的返回值<code>M(b)</code>中取出数据<code>b</code>。而这个过程正是<code>flaten</code>和<code>map</code>的过程</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-none"><code>g: a => M(b) flattens to => b
f: b maps to => M(c)
h composeM(f, g):a flatten(M(b)) => b => map(b => M(c)) => M(c)</code></pre>
      </div>
<p>在上面中<code>M(b) => b</code>的展平，以及<code>b => M(c)</code>的映射，实在<code>a => M(c)</code>的<code>chain</code>中完成的，在更高层级<code>composeM</code>中的完成的，稍后会讲解<code>composeM</code>如何实现。</p>
<p>现在我们只要知道我们借助Monad完成更高级的函数组合，有很多的函数不是简单的从<code>a => b</code>的映射，有些函数需要处理副作用，例如(promise)、分支处理(Either)、异常处理(Maybe)。。。</p>
<p>举一个更实际的例子，如果我们要从一个异步的API中获取某个用户的信息，然后把这个信息，传递给另一个异步的API,来查询别的数据，这个时候我们怎么办呢？</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-none"><code>getUserById(id) => Promise(User)
hasPermision(User) => Promise(Boolean)</code></pre>
      </div>
<p>首先写一些工具函数，帮助我们完成任务：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> compose <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>fns<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> fns<span class="token punctuation">.</span><span class="token function">reduceRight</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> trace <span class="token operator">=</span> label <span class="token operator">=></span> value <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> label <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span> value <span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<p>然后可以这样使用代码：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> label <span class="token operator">=</span> <span class="token string">'API call composition'</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// a => Promise(b)</span>
<span class="token keyword">const</span> getUserById <span class="token operator">=</span> id <span class="token operator">=></span> id <span class="token operator">===</span> <span class="token number">3</span> <span class="token operator">?</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Kurt'</span><span class="token punctuation">,</span> role<span class="token punctuation">:</span> <span class="token string">'Author'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>
    undefined

<span class="token comment" spellcheck="true">// b => Promise(c)</span>
<span class="token keyword">const</span> hasPermission <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> role <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>role <span class="token operator">===</span> <span class="token string">'Author'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// Try to compose them. Warning: this will fail.</span>
<span class="token keyword">const</span> authUser <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>hasPermission<span class="token punctuation">,</span> getUserById<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Oops! Always false!</span>
<span class="token function">authUser</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">trace</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<p>当我们组合<code>getUserById</code>，<code>hasPermission</code>函数的时候，我们发现了一个大问题，<code>hasPermission</code>函数期望得到一个<code>User</code>对象作为参数，而<code>getUserById</code>函数的返回值却是<code>Promise(User)</code>，为了解决这个问题，我们需要使用<code>then</code>方法从<code>Promise(User)</code>中把<code>User</code>对象取出来,为此我们做一个定制版的<code>composePromises</code>函数：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> composeM <span class="token operator">=</span> chainMethod <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token operator">...</span>ms<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
    ms<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">[</span>chainMethod<span class="token punctuation">]</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> composePromises <span class="token operator">=</span> <span class="token function">composeM</span><span class="token punctuation">(</span><span class="token string">'then'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> label <span class="token operator">=</span> <span class="token string">'API call composition'</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// a => Promise(b)</span>
<span class="token keyword">const</span> getUserById <span class="token operator">=</span> id <span class="token operator">=></span> id <span class="token operator">===</span> <span class="token number">3</span> <span class="token operator">?</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Kurt'</span><span class="token punctuation">,</span> role<span class="token punctuation">:</span> <span class="token string">'Author'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>
    undefined

<span class="token comment" spellcheck="true">// b => Promise(c)</span>
<span class="token keyword">const</span> hasPermission <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> role <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>role <span class="token operator">===</span> <span class="token string">'Author'</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// Compose the functions (this works!)</span>
<span class="token keyword">const</span> authUser <span class="token operator">=</span> <span class="token function">composePromises</span><span class="token punctuation">(</span>hasPermission<span class="token punctuation">,</span> getUserById<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">authUser</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">trace</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
</code></pre>
      </div>
<p>Promise也是一种Monad。</p>
<h4 id="what-monads-are-made-of"><a href="#what-monads-are-made-of" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What Monads are Made of</h4>
<p>Monad遵循一个简单的对称，把一个值包装到context中，并且能够把值从context中取出来。</p>
<ul>
<li><strong>Lift/Unit</strong>:把一个值包装到Monad的context中，<code>a => M(a)</code></li>
<li><strong>Flatten/Join</strong>:把值从context中取出来，<code>M(a) => a</code></li>
</ul>
<p>Monad肯定也是一个Functor,那么很明显也有一个fmap方法：</p>
<ul>
<li><strong>Map</strong>:从一个Functor映射到另一个Functor,<code>M(a) => M(b)</code></li>
</ul>
<p>合并<code>Flatten</code>和<code>Map</code>,这个就是<code>Chain</code></p>
<ul>
<li><strong>FlatMap/Chain</strong>: Flatten + map: <code>M(M(a)) => M(b)</code></li>
</ul>
<blockquote>
<p>在Promise中<code>.then</code>方法实际上就是Monad中的<code>FlatMap/Chain</code>方法</p>
</blockquote>
<blockquote>
<p>Monad是一个抽象接口(类似于Java中的Interface)，定义了实现该接口必须定义的方法，而实现了Monad的具体类型被称为<strong>Monadic</strong>,Monadic才是根据方向，可以有不同的具体的实现,例如Promise，Array等等</p>
</blockquote>
<h4 id="扩展应用"><a href="#%E6%89%A9%E5%B1%95%E5%BA%94%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>扩展应用</h4>
<p>看一个具体的例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// The algebraic definition of function composition:</span>
<span class="token comment" spellcheck="true">// (f ∘ g)(x) = f(g(x))</span>
<span class="token keyword">const</span> compose <span class="token operator">=</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> x <span class="token operator">=</span> <span class="token number">20</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// The value</span>
<span class="token keyword">const</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// The container</span>
<span class="token comment" spellcheck="true">// Some functions to compose</span>
<span class="token keyword">const</span> g <span class="token operator">=</span> n <span class="token operator">=></span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> f <span class="token operator">=</span> n <span class="token operator">=></span> n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Proof that .map() accomplishes function composition.</span>
<span class="token comment" spellcheck="true">// Chaining calls to map is function composition.</span>
<span class="token function">trace</span><span class="token punctuation">(</span><span class="token string">'map composes'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
    arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>g<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span>
    arr<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">compose</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// => [42], [42]</span>
</code></pre>
      </div>
<p>不仅仅是数组具有map方法，我们可以把任何包含<code>map</code>方法的Functor,都可以组合</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> composeMap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>ms<span class="token punctuation">)</span> <span class="token operator">=></span> ms<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
      </div>
<p>Promise的组合:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> label <span class="token operator">=</span> <span class="token string">'Promise composition'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> g <span class="token operator">=</span> n <span class="token operator">=></span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> f <span class="token operator">=</span> n <span class="token operator">=></span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>n <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> h <span class="token operator">=</span> <span class="token function">composePromises</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">h</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token function">trace</span><span class="token punctuation">(</span>label<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">// Promise composition: 42</span>
</code></pre>
      </div>
<p>其实规律非常简单，只要是这种结构的数据都可以自由的定义组合：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> composeM <span class="token operator">=</span> method <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token operator">...</span>ms<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">(</span>
  ms<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">[</span>method<span class="token punctuation">]</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">const</span> composePromises <span class="token operator">=</span> <span class="token function">composeM</span><span class="token punctuation">(</span><span class="token string">'then'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> composeMap <span class="token operator">=</span> <span class="token function">composeM</span><span class="token punctuation">(</span><span class="token string">'map'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> composeFlatMap <span class="token operator">=</span> <span class="token function">composeM</span><span class="token punctuation">(</span><span class="token string">'flatMap'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </div>]]></description><link>https://reactjs.org/blog/2018/09/11/FB15-Monad-2.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/09/11/FB15-Monad-2.html</guid><pubDate>Mon, 10 Sep 2018 16:00:00 GMT</pubDate></item><item><title><![CDATA[FP14：Monad-1]]></title><description><![CDATA[<h3 id="pointed-functor"><a href="#pointed-functor" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>pointed functor</h3>
<p>在继续后面的内容之前，我得向你坦白一件事：关于我们先前创建的容器类型上的 of 方法，我并没有说出它的全部实情。真实情况是，of 方法不是用来避免使用 new 关键字的，而是用来把值放到默认最小化上下文（default minimal context）中的。是的，of 没有真正地取代构造器——它是一个我们称之为 pointed 的重要接口的一部分。</p>
<blockquote>
<p>pointed functor 是实现了 of 方法的 functor</p>
</blockquote>
<p>这里的关键是把任意值丢到容器里然后开始到处使用 map 的能力。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code>IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"tetris"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">" master"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// IO("tetris master")</span>

Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">1336</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Maybe(1337)</span>

Either<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"The past, present and future walk into a bar..."</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>
  <span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"it was tense."</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Right("The past, present and future walk into a bar...it was tense.")</span>
</code></pre>
      </div>
<p>如果你还记得，<code>IO</code>的构造器接受一个函数作为参数，而<code>Maybe</code>和<code>Either</code>的构造器可以接受任意值。实现这种接口的动机是，我们希望能有一种通用、一致的方式往<code>functor</code>里填值，而且中间不会涉及到复杂性，也不会涉及到对构造器的特定要求。“默认最小化上下文”这个术语可能不够精确，但是却很好地传达了这种理念：我们希望容器类型里的任意值都能发生<code>lift</code>，然后像所有的<code>functor</code>那样再<code>map</code>出去。</p>
<p>有件很重要的事我必须得在这里纠正，那就是，<code>Left.of</code>没有任何道理可言，包括它的双关语也是。每个<code>functor</code>都要有一种把值放进去的方式，对<code>Either</code>来说，它的方式就是<code>new Right(x)</code>。我们为<code>Right</code>定义<code>of</code>的原因是，如果一个类型容器可以<code>map</code>，那它就应该<code>map</code>。看上面的例子，你应该会对<code>of</code>通常的工作模式有一个直观的印象，而<code>Left</code>破坏了这种模式。</p>
<p>你可能已经听说过<code>pure</code>、<code>point</code>、<code>unit</code>和<code>return</code>之类的函数了，它们都是<code>of</code>这个史上最神秘函数的不同名称。<code>of</code>将在我们开始使用<code>monad</code>的时候显示其重要性，因为后面你会看到，手动把值放回容器是我们自己的责任。</p>
<p>要避免<code>new</code>关键字，可以借助一些标准的<code>JavaScript</code>技巧或者类库达到目的。所以从这里开始，我们就利用这些技巧或类库，像一个负责任的成年人那样使用<code>of</code>。我推荐使用<code>folktale</code>、<code>ramda</code>或<code>fantasy-land</code>里的<code>functor</code>实例，因为它们同时提供了正确的<code>of</code>方法和不依赖<code>new</code>的构造器。</p>
<h3 id="mixing-metaphors"><a href="#mixing-metaphors" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mixing Metaphors</h3>
<p>
你看，除了太空墨西哥卷，monad 还被喻为洋葱。让我以一个常见的场景来说明这点：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// readFile :: String -> IO String</span>
<span class="token keyword">const</span> readFile <span class="token operator">=</span> filename <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token string">'utf-8'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// print :: String -> IO String</span>
<span class="token keyword">const</span> print <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// cat :: String -> IO (IO String)</span>
<span class="token keyword">const</span> cat <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span><span class="token punctuation">,</span> readFile<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">cat</span><span class="token punctuation">(</span><span class="token string">'.git/config'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// IO(IO('[core]\nrepositoryformatversion = 0\n'))</span>
</code></pre>
      </div>
<p>这里我们得到的是一个<code>IO</code>，只不过它陷进了另一个<code>IO</code>。要想使用它，我们必须这样调用：<code>map(map(f))</code>；要想观察它的作用，必须这样：<code>unsafePerformIO().unsafePerformIO()</code>。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// cat :: String -> IO (IO String)</span>
<span class="token keyword">const</span> cat <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span><span class="token punctuation">,</span> readFile<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// catFirstChar :: String -> IO (IO String)</span>
<span class="token keyword">const</span> catFirstChar <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> cat<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">catFirstChar</span><span class="token punctuation">(</span><span class="token string">'.git/config'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// IO(IO('['))</span>
</code></pre>
      </div>
<p>尽管在应用中把这两个作用打包在一起没什么不好的，但总感觉像是在穿着两套防护服工作，结果就形成一个稀奇古怪的<code>API</code>。再来看另一种情况：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// safeProp :: Key -> {Key: a} -> Maybe a</span>
<span class="token keyword">const</span> safeProp <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> obj<span class="token punctuation">)</span> <span class="token operator">=></span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// safeHead :: [a] -> Maybe a</span>
<span class="token keyword">const</span> safeHead <span class="token operator">=</span> <span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// firstAddressStreet :: User -> Maybe (Maybe (Maybe Street))</span>
<span class="token keyword">const</span> firstAddressStreet <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'street'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span>safeHead<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'addresses'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">firstAddressStreet</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  addresses<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> street<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Mulburry'</span><span class="token punctuation">,</span> number<span class="token punctuation">:</span> <span class="token number">8402</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> postcode<span class="token punctuation">:</span> <span class="token string">'WC2N'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Maybe(Maybe(Maybe({name: 'Mulburry', number: 8402})))</span>
</code></pre>
      </div>
<p>这里的<code>functor</code>同样是嵌套的，函数中三个可能的失败都用了<code>Maybe</code>做预防也很干净整洁，但是要让最后的调用者调用三次<code>map</code>才能取到值未免也太无礼了点——我们和它才刚刚见面而已。这种嵌套<code>functor</code>的模式会时不时地出现，而且是<code>monad</code>的主要使用场景。</p>
<p>我说过<code>monad</code>像洋葱，那是因为当我们用<code>map</code>剥开嵌套的<code>functor</code>以获取它里面的值的时候，就像剥洋葱一样让人忍不住想哭。不过，我们可以擦干眼泪，做个深呼吸，然后使用一个叫作<code>join</code>的方法。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> mmo <span class="token operator">=</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">'nunchucks'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Maybe(Maybe('nunchucks'))</span>

mmo<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Maybe('nunchucks')</span>

<span class="token keyword">const</span> ioio <span class="token operator">=</span> IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">'pizza'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// IO(IO('pizza'))</span>

ioio<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// IO('pizza')</span>

<span class="token keyword">const</span> ttt <span class="token operator">=</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">'sewers'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Task(Task(Task('sewers')));</span>

ttt<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Task(Task('sewers'))</span>
</code></pre>
      </div>
<p>如果有两层相同类型的嵌套，那么就可以用 join 把它们压扁到一块去。这种结合的能力，functor 之间的联姻，就是 monad 之所以成为 monad 的原因。来看看它更精确的完整定义：</p>
<p><strong>monad是可以扁平化（flatten）的 pointed functor。</strong></p>
<p>一个 functor，只要它定义个了一个<code>join</code>方法和一个<code>of</code>方法，并遵守一些定律，那么它就是一个<code>monad</code>。<code>join</code>的实现并不太复杂，我们来为 <code>Maybe</code>定义一个：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code>Maybe<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>join <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">isNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$value<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<p>看，就像子宫里双胞胎中的一个吃掉另一个那么简单。如果有一个<code>Maybe(Maybe(x))</code>，那么 <code>.$value``将会移除多余的一层，然后我们就能安心地从那开始进行</code>map。要不然，我们就将会只有一个<code>Maybe</code>，因为从一开始就没有任何东西被<code>map</code>调用。</p>
<p>既然已经有了<code>join</code>方法，我们把<code>monad</code>魔法作用到<code>firstAddressStreet</code>例子上，看看它的实际作用：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// join :: Monad m => m (m a) -> m a</span>
<span class="token keyword">const</span> join <span class="token operator">=</span> mma <span class="token operator">=></span> mma<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// firstAddressStreet :: User -> Maybe Street</span>
<span class="token keyword">const</span> firstAddressStreet <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'street'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span>safeHead<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'addresses'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">firstAddressStreet</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  addresses<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> street<span class="token punctuation">:</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'Mulburry'</span><span class="token punctuation">,</span> number<span class="token punctuation">:</span> <span class="token number">8402</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> postcode<span class="token punctuation">:</span> <span class="token string">'WC2N'</span> <span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Maybe({name: 'Mulburry', number: 8402})</span>
</code></pre>
      </div>
<p>只要遇到嵌套的 Maybe，就加一个 join，防止它们从手中溜走。我们对 IO 也这么做试试看，感受下这种感觉。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code>IO<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>join <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">unsafePerformIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
<p>同样是简单地移除了一层容器。注意，我们还没有提及纯粹性的问题，仅仅是移除过度紧缩的包裹中的一层而已。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// log :: a -> IO a</span>
<span class="token keyword">const</span> log <span class="token operator">=</span> x <span class="token operator">=></span> IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> x<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// setStyle :: Selector -> CSSProps -> IO DOM</span>
<span class="token keyword">const</span> setStyle <span class="token operator">=</span>
  <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>sel<span class="token punctuation">,</span> props<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">jQuery</span><span class="token punctuation">(</span>sel<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span>props<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// getItem :: String -> IO String</span>
<span class="token keyword">const</span> getItem <span class="token operator">=</span> key <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> localStorage<span class="token punctuation">.</span><span class="token function">getItem</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// applyPreferences :: String -> IO DOM</span>
<span class="token keyword">const</span> applyPreferences <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">setStyle</span><span class="token punctuation">(</span><span class="token string">'#main'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span>parse<span class="token punctuation">)</span><span class="token punctuation">,</span>
  getItem<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">applyPreferences</span><span class="token punctuation">(</span><span class="token string">'preferences'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">unsafePerformIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Object {backgroundColor: "green"}</span>
<span class="token comment" spellcheck="true">// &lt;div style="background-color: 'green'"/></span>
</code></pre>
      </div>
<p>getItem 返回了一个 IO String，所以可以直接用 map 来解析它。log 和 setStyle 返回的都是 IO，所以必须要使用 join 来保证这里边的嵌套处于控制之中。</p>
<h3 id="my-chain-hits-my-chest"><a href="#my-chain-hits-my-chest" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>My Chain Hits My Chest</h3>
<p>
你可能已经从上面的例子中注意到这种模式了：我们总是在紧跟着 map 的后面调用 join。让我们把这个行为抽象到一个叫做 chain 的函数里。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// chain :: Monad m => (a -> m b) -> m a -> m b</span>
<span class="token keyword">const</span> chain <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token operator">=></span> m<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// or</span>

<span class="token comment" spellcheck="true">// chain :: Monad m => (a -> m b) -> m a -> m b</span>
<span class="token keyword">const</span> chain <span class="token operator">=</span> f <span class="token operator">=></span> <span class="token function">compose</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<p>这里仅仅是把 map/join 套餐打包到一个单独的函数中。如果你之前了解过 monad，那你可能已经看出来 chain 叫做 >>=（读作 bind）或者 flatMap；都是同一个概念的不同名称罢了。我个人认为 flatMap 是最准确的名称，但本书还是坚持使用 chain，因为它是 JS 里接受程度最高的一个。我们用 chain 重构下上面两个例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// map/join</span>
<span class="token keyword">const</span> firstAddressStreet <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'street'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span>safeHead<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'addresses'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// chain</span>
<span class="token keyword">const</span> firstAddressStreet <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'street'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">chain</span><span class="token punctuation">(</span>safeHead<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'addresses'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// map/join</span>
<span class="token keyword">const</span> applyPreferences <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span><span class="token function">setStyle</span><span class="token punctuation">(</span><span class="token string">'#main'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  join<span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span>parse<span class="token punctuation">)</span><span class="token punctuation">,</span>
  getItem<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// chain</span>
<span class="token keyword">const</span> applyPreferences <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">setStyle</span><span class="token punctuation">(</span><span class="token string">'#main'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">chain</span><span class="token punctuation">(</span>log<span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token function">map</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span>parse<span class="token punctuation">)</span><span class="token punctuation">,</span>
  getItem<span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<p>我把所有的 map/join 都替换为了 chain，这样代码就显得整洁了些。整洁固然是好事，但 chain 的能力却不止于此——它更多的是龙卷风而不是吸尘器。因为 chain 可以轻松地嵌套多个作用，因此我们就能以一种纯函数式的方式来表示 序列（sequence） 和 变量赋值（variable assignment）。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// getJSON :: Url -> Params -> Task JSON</span>
<span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token string">'/authenticate'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> username<span class="token punctuation">:</span> <span class="token string">'stale'</span><span class="token punctuation">,</span> password<span class="token punctuation">:</span> <span class="token string">'crackers'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>user <span class="token operator">=></span> <span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token string">'/friends'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> user_id<span class="token punctuation">:</span> user<span class="token punctuation">.</span>id <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Task([{name: 'Seimith', id: 14}, {name: 'Ric', id: 39}]);</span>

<span class="token comment" spellcheck="true">// querySelector :: Selector -> IO DOM</span>
<span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'input.username'</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> uname <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'input.email'</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> email <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> IO<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Welcome </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>uname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> prepare for spam at </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>email<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// IO('Welcome Olivia prepare for spam at olivia@tremorcontrol.net');</span>

Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>three <span class="token operator">=></span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>three<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Maybe(5);</span>

Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'address'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">safeProp</span><span class="token punctuation">(</span><span class="token string">'street'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Maybe(null);</span>
</code></pre>
      </div>
<p>本来我们可以用 compose 写上面的例子，但这将需要几个帮助函数，而且这种风格怎么说都要通过闭包进行明确的变量赋值。相反，我们使用了插入式的 chain。顺便说一下，chain 可以自动从任意类型的 map 和 join 衍生出来，就像这样：t.prototype.chain = function(f) { return this.map(f).join(); }。如果手动定义 chain 能让你觉得性能会好点的话（实际上并不会），我们也可以手动定义它，尽管还必须要费力保证函数功能的正确性——也就是说，它必须与紧接着后面有 join 的 map 相等。如果 chain 是简单地通过结束调用 of 后把值放回容器这种方式定义的，那么就会造成一个有趣的后果，即可以从 chain 那里衍生出一个 map。同样地，我们还可以用 chain(id) 定义 join。听起来好像是在跟魔术师玩德州扑克，魔术师想要什么牌就有什么牌；但是就像大部分的数学理论一样，所有这些原则性的结构都是相互关联的。fantasyland 仓库中提到了许多上述衍生概念，这个仓库也是 JavaScript 官方的代数数据结构（algebraic data types）标准。</p>
<p>好了，我们来看上面的例子。第一个例子中，可以看到两个 Task 通过 chain 连接形成了一个异步操作的序列——它先获取 user，然后用 user.id 查找 user 的 friends。chain 避免了 Task(Task([Friend])) 这种情况。</p>
<p>第二个例子是用 querySelector 查找几个 input 然后创建一条欢迎信息。注意看我们是如何在最内层的函数里访问 uname 和 email 的——这是函数式变量赋值的绝佳表现。因为 IO 大方地把它的值借给了我们，我们也要负起以同样方式把值放回去的责任——不能辜负它的信任（还有整个程序的信任）。IO.of 非常适合做这件事，同时它也解释了为何 pointed 这一特性是 monad 接口得以存在的重要前提。不过，map 也能返回正确的类型：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'input.username'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> uname <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span>
  <span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'input.email'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">{</span> value<span class="token punctuation">:</span> email <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span>
    <span class="token template-string"><span class="token string">`Welcome </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>uname<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> prepare for spam at </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>email<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// IO('Welcome Olivia prepare for spam at olivia@tremorcontrol.net');</span>
</code></pre>
      </div>
<p>最后两个例子用了 Maybe。因为 chain 其实是在底层调用了 map，所以如果遇到 null，代码就会立刻停止运行。</p>
<p>如果觉得这些例子不太容易理解，你也不必担心。多跑跑代码，多琢磨琢磨，把代码拆开来研究研究，再把它们拼起来看看。总之记住，返回的如果是“普通”值就用 map，如果是 functor 就用 chain。</p>
<p>这里我得提醒一下，上述方式对两个不同类型的嵌套容器是不适用的。functor 组合，以及后面会讲到的 monad transformer 可以帮助我们应对这种情况。</p>
<h3 id="power-trip"><a href="#power-trip" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Power Trip</h3>
<p>这种容器编程风格有时也能造成困惑，我们不得不努力理解一个值到底嵌套了几层容器，或者需要用 map 还是 chain（很快我们就会认识更多的容器类型）。使用一些技巧，比如重写 inspect 方法之类，能够大幅提高 debug 的效率。后面我们也会学习如何创建一个“栈”，使之能够处理任何丢给它的作用（effects）。不过，有时候也需要权衡一下是否值得这样做。</p>
<p>我很乐意挥起 monad 之剑，向你展示这种编程风格的力量。就以读一个文件，然后就把它直接上传为例吧：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// readFile :: Filename -> Either String (Future Error String)</span>
<span class="token comment" spellcheck="true">// httpPost :: String -> Future Error JSON</span>

<span class="token comment" spellcheck="true">//  upload :: String -> Either String (Future Error JSON)</span>
<span class="token keyword">var</span> upload <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token function">httpPost</span><span class="token punctuation">(</span><span class="token string">'/uploads'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> readFile<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<p>这里，代码不止一次在不同的分支执行。从类型签名可以看出，我们预防了三个错误——readFile 使用 Either 来验证输入（或许还有确保文件名存在）；readFile 在读取文件的时候可能会出错，错误通过 readFile 的 Future 表示；文件上传可能会因为各种各样的原因出错，错误通过 httpPost 的 Future 表示。我们就这么随意地使用 chain 实现了两个嵌套的、有序的异步执行动作。</p>
<p>所有这些操作都是在一个从左到右的线性流中完成的，是完完全全纯的、声明式的代码，是可以等式推导（equational reasoning）并拥有可靠特性（reliable properties）的代码。我们没有被迫使用不必要甚至令人困惑的变量名，我们的 upload 函数符合通用接口而不是特定的一次性接口。这些都是在一行代码中完成的啊！</p>
<p>让我们来跟标准的命令式的实现对比一下：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">//  upload :: String -> (String -> a) -> Void</span>
<span class="token keyword">var</span> upload <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>filename<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token string">"You need a filename!"</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token function">readFile</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> contents<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span>
      <span class="token function">httpPost</span><span class="token punctuation">(</span>contents<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>err<span class="token punctuation">,</span> json<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span>
        <span class="token function">callback</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
<p>看看，这简直就是魔鬼的算术，我们就像一颗弹珠一样在变幻莫测的迷宫中穿梭。无法想象如果这是一个典型的应用，而且一直在改变变量会怎样——我们肯定会像陷入沥青坑那样无所适从。</p>
<h3 id="theory"><a href="#theory" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Theory</h3>
<p>我们要看的第一条定律是结合律，但可能不是你熟悉的那个结合律。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code> <span class="token comment" spellcheck="true">// 结合律</span>
  <span class="token function">compose</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span>join<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">compose</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> join<span class="token punctuation">)</span>
</code></pre>
      </div>
<p>这些定律表明了 monad 的嵌套本质，所以结合律关心的是如何让内层或外层的容器类型 join，然后取得同样的结果。用一张图来表示可能效果会更好：

从左上角往下，先用 join 合并 M(M(M a)) 最外层的两个 M，然后往右，再调用一次 join，就得到了我们想要的 M a。或者，从左上角往右，先打开最外层的 M，用 map(join) 合并内层的两个 M，然后再向下调用一次 join，也能得到 M a。不管是先合并内层还是先合并外层的 M，最后都会得到相同的 M a，所以这就是结合律。值得注意的一点是 map(join) != join。两种方式的中间步骤可能会有不同的值，但最后一个 join 调用后最终结果是一样的。</p>
<p>第二个定律与结合律类似：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// 同一律 (M a)</span>
  <span class="token function">compose</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> <span class="token keyword">of</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token function">compose</span><span class="token punctuation">(</span>join<span class="token punctuation">,</span> <span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">of</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> id
</code></pre>
      </div>
<p>这表明，对任意的 monad M，of 和 join 相当于 id。也可以使用 map(of) 由内而外实现相同效果。我们把这个定律叫做“三角同一律”（triangle identity），因为把它图形化之后就像一个三角形：

如果从左上角开始往右，可以看到 of 的确把 M a 丢到另一个 M 容器里去了。然后再往下 join，就得到了 M a，跟一开始就调用 id 的结果一样。从右上角往左，可以看到如果我们通过 map 进到了 M 里面，然后对普通值 a 调用 of，最后得到的还是 M (M a)；再调用一次 join 将会把我们带回原点，即 M a。</p>
<p>我要说明一点，尽管这里我写的是 of，实际上对任意的 monad 而言，都必须要使用明确的 M.of。</p>
<p>我已经见过这些定律了，同一律和结合律，以前就在哪儿见过…等一下，让我想想…是的！它们是范畴遵循的定律！不过这意味着我们需要一个组合函数来给出一个完整定义。见证吧：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> mcompose <span class="token operator">=</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">chain</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// left identity</span>
<span class="token function">mcompose</span><span class="token punctuation">(</span>M<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token operator">===</span> f<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// right identity</span>
<span class="token function">mcompose</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> M<span class="token punctuation">)</span> <span class="token operator">===</span> f<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// associativity</span>
<span class="token function">mcompose</span><span class="token punctuation">(</span><span class="token function">mcompose</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span><span class="token punctuation">,</span> h<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">mcompose</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token function">mcompose</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> h<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<p>毕竟它们是范畴学里的定律。monad 来自于一个叫 “Kleisli 范畴”的范畴，这个范畴里边所有的对象都是 monad，所有的态射都是联结函数（chained funtions）。我不是要在没有提供太多解释的情况下，拿范畴学里各式各样的概念来取笑你。我的目的是涉及足够多的表面知识，向你说明这中间的相关性，让你在关注日常实用特性之余，激发起对这些定律的兴趣。</p>
<h3 id="summary"><a href="#summary" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Summary</h3>
<p>monad 让我们深入到嵌套的运算当中，使我们能够在完全避免回调金字塔（pyramid of doom）情况下，为变量赋值，运行有序的作用，执行异步任务等等。当一个值被困在几层相同类型的容器中时，monad 能够拯救它。借助 “pointed” 这个可靠的帮手，monad 能够借给我们从盒子中取出的值，而且知道我们会在结束使用后还给它。</p>
<p>是的，monad 非常强大，但我们还需要一些额外的容器函数。比如，假设我们想同时运行一个列表里的 api 调用，然后再搜集返回的结果，怎么办？是可以使用 monad 实现这个任务，但必须要等每一个 api 完成后才能调用下一个。合并多个合法性验证呢？我们想要的肯定是持续验证以搜集错误列表，但是 monad 会在第一个 Left 登场的时候停掉整个演出。</p>
<p>下一章，我们将看到 applicative functor 如何融入这个容器世界，以及为何在很多情况下它比 monad 更好用。</p>]]></description><link>https://reactjs.org/blog/2018/09/02/FP14-Monad-1.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/09/02/FP14-Monad-1.html</guid><pubDate>Sat, 01 Sep 2018 16:00:00 GMT</pubDate></item><item><title><![CDATA[代理模式]]></title><description><![CDATA[<h3 id="模仿类"><a href="#%E6%A8%A1%E4%BB%BF%E7%B1%BB" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>模仿类</h3>
<p>多年以来，JavaScript中有一种奇怪的行为一直在被无耻地滥用，那就是<code>模仿类</code>。我们会仔细分析这种方法。
这种奇怪的“类似类”的行为利用了函数的一种特殊特性:所有的函数默认都会拥有一个名为<code>prototype</code>的公有并且不可枚举的属性，它会指向另一个对象:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// ...</span>
<span class="token punctuation">}</span>
Foo<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// { }</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span> a <span class="token punctuation">)</span> <span class="token operator">===</span> Foo<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span>
</code></pre>
      </div>
<p>这个对象通常被称为<code>Foo的原型</code>，因为我们通过名为<code>Foo.prototype</code>的属性引用来访问它。</p>
<p>调用<code>new Foo()</code>时会创建<code>a</code>，其中的一步就是给<code>a</code>一个内部的<code>[[Prototype]]</code>链接，关联到<code>Foo.prototype</code>指向的那个对象。
下面是<code>new</code>操作符的具体实现，也就是假如没有<code>new</code>操作符的时候，我们该怎么实现<code>new</code>呢？</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">function</span> <span class="token function">newObject</span><span class="token punctuation">(</span>Constructor<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    Constructor<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">...</span>arguments<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
<p>在面向类的语言中，类可以被复制(或者说实例化)多次，就像用模具制作东西一样。之所以会这样是因为实例化(或者继承)一个类就意味着“把类的行为复制到物理对象中”，对于每一个新实例来说都会重复这个过程。
但是在JavaScript中，并没有类似的复制机制。你不能创建一个类的多个实例，只能创建多个对象，它们<code>[[Prototype]]</code>关联的是同一个对象。但是在默认情况下并不会进行复制， 因此这些对象之间并不会完全失去联系，它们是互相关联的。</p>
<p><code>new Foo()</code>会生成一个新对象(我们称之为a)，这个新对象的内部链接<code>[[Prototype]]</code>关联的是<code>Foo.prototype</code>对象。</p>
<p>最后我们得到了两个对象，它们之间互相关联，就是这样。</p>
<p>我们并没有初始化一个类，实际上我们并没有从“类”中复制任何行为到一个对象中，只是让两个对象互相关联。</p>
<p>继承意味着复制操作，JavaScript(默认)并不会复制对象属性。</p>
<p>相反，JavaScript会在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数。</p>
<p><code>Object.create(..)</code> 是一个大英雄，现在是时候来弄明白为 什么了:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token punctuation">{</span>
something<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span> <span class="token string">"Tell me something good..."</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> bar <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span> foo <span class="token punctuation">)</span><span class="token punctuation">;</span> bar<span class="token punctuation">.</span><span class="token function">something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Tell me something good...</span>
</code></pre>
      </div>
<p><code>Object.create(..)</code> 会创建一个新对象(<code>bar</code>)并把它关联到我们指定的对象(<code>foo</code>)，这样 我们就可以充分发挥<code>[[Prototype]]</code>机制的威力(委托)并且避免不必要的麻烦(比如使用<code>new</code>的构造函数调用会生成<code>.prototype</code> 和<code>.constructor</code>引用)。</p>
<p>换句话说JavaScript中这个原型链机制的本质就是对象之间的关联关系，对象之间从未存在过“继承”这种东西</p>]]></description><link>https://reactjs.org/blog/2018/08/24/代理-pattern.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/08/24/代理-pattern.html</guid><pubDate>Thu, 23 Aug 2018 16:00:00 GMT</pubDate></item><item><title><![CDATA['类'模式]]></title><description><![CDATA[<h3 id="oop"><a href="#oop" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>oop</h3>
<p>面向对象编程强调的是数据和操作数据的行为本质上是相互关联的(当然，不同的数据有不同的行为)，因此好的设计就是把数据以及和它相关的行为打包(封装)起来，这在正是的计算机科学中有时候被称为数据结构。</p>
<p>举例来说：用来表示一个单词或者短语的<code>一串字符通</code>常被称为字符串。字符就是<code>数据</code>。但是你关心的往往不是<code>数据是什么</code>，而是<code>可以对数据做什么</code>，所以可以应用在这种数据上的行为(计算长度、添加数据、搜索，等等)都被设计成<code>String</code>类的方法。</p>
<p>所有字符串都是<code>String</code>类的一个实例，也就是说它是一个包裹，包含字符数据和我们可以 应用在数据上的函数。</p>
<p>我们来看一个常见的例子，“汽车”可以被看作“交通工具”的一种特例，后者是更广泛的类。</p>
<p>我们可以在软件中定义一个<code>Vehicle</code>类和一个<code>Car</code>类来对这种关系进行建模。
<code>Vehicle</code>的定义可能包含推进器(比如引擎)、载人能力等等，这些都是<code>Vehicle</code>的行为。我们在<code>Vehicle</code>中定义的是(几乎)所有类型的交通工具(飞机、火车和汽车)都包含的东西。
在我们的软件中，对不同的交通工具重复定义“载人能力”是没有意义的。相反，我们只在<code>Vehicle</code>中定义一次，定义<code>Car</code>时，只要声明它<code>继承</code>(或者扩展)了<code>Vehicle</code>的这个基础定义就行。<code>Car</code>的定义就是对通用<code>Vehicle</code>定义的特殊化。
虽然<code>Vehicle</code>和<code>Car</code>会定义相同的方法，但是实例中的数据可能是不同的，比如每辆车独一无二的 VIN(Vehicle Identification Number，车辆识别号码)，等等。</p>
<p>这就是<code>类</code>、<code>继承</code>和<code>实例化</code>。
类的另一个核心概念是<code>多态</code>，这个概念是说父类的通用行为可以被子类<code>用更特殊的行为重写</code>。实际上，相对多态性允许我们从重写行为中引用基础行为。</p>
<p>类理论强烈建议父类和子类使用相同的方法名来表示特定的行为，从而让子类重写父类。</p>
<p>总结一下经典的面向对象编程的思维导图：
</p>
<h3 id="类与实例"><a href="#%E7%B1%BB%E4%B8%8E%E5%AE%9E%E4%BE%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>类与实例</h3>
<p>举例来说类和实例的关系，服装设计师会设计好每个服装的模型，包括领口多款，袖子多长，等等模版；设计师并不关心他设计的模版衣服会在哪里生产，会生产多少件。</p>
<p>而生产厂家拿到了衣服的模版之后，就会让工人来批量生产衣服。</p>
<p>那么生产完成之后的具体的每一件衣服。也就是模版的一份物理实例，本质上就是对模版的复制。</p>
<p>一个类就是一个模版。为了获得真正可以交互的对象，我们必须按照类来建造(也可以说<code>实例化</code>)一个东西，这个东西通常被称为<code>实例</code>，有需要的话，我们可以直接在实例上调用方法并访问其所有公有数据属性。
这个对象就是类中描述的所有特性的一份副本。</p>
<h3 id="构造函数"><a href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>构造函数</h3>
<p>类实例是由一个特殊的类方法构造的，这个方法名通常和类名相同，被称为构造函数。这
个方法的任务就是初始化实例需要的所有信息(状态)。 举例来说，思考下面这个关于类的伪代码(编造出来的语法):</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">class</span> <span class="token class-name">CoolGuy</span> <span class="token punctuation">{</span>
  specialTrick <span class="token operator">=</span> nothing
  <span class="token function">CoolGuy</span><span class="token punctuation">(</span> trick <span class="token punctuation">)</span> <span class="token punctuation">{</span>
    specialTrick <span class="token operator">=</span> trick
<span class="token punctuation">}</span>
  <span class="token function">showOff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">output</span><span class="token punctuation">(</span> <span class="token string">"Here's my trick: "</span><span class="token punctuation">,</span> specialTrick <span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
<p>我们可以调用类构造函数来生成一个<code>CoolGuy</code>实例:</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code>Joe <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CoolGuy</span><span class="token punctuation">(</span> <span class="token string">"jumping rope"</span> <span class="token punctuation">)</span>
Joe<span class="token punctuation">.</span><span class="token function">showOff</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 这是我的绝技:跳绳</span>
</code></pre>
      </div>
<p>注意，<code>CoolGuy</code>类有一个<code>CoolGuy()</code>构造函数，执行<code>new</code>它。构造函数会返回一个对象(也就是类的一个实例)，之后我们可以在这个对象上调用<code>showOff()</code>方法，来输出指定 <code>CoolGuy</code>的特长。
类构造函数属于类，而且通常和类同名。此外，构造函数大多需要用<code>new</code>来调，这样语言引擎才知道你想要构造一个新的类实例。</p>
<h3 id="类的继承"><a href="#%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>类的继承</h3>
<p>在面向类的语言中，你可以先定义一个类，然后定义一个继承前者的类。
后者通常被称为“子类”，前者通常被称为“父类”。这些术语显然是类比父母和孩子，不过在意思上稍有扩展，你很快就会看到。
对于父母的亲生孩子来说，父母的基因特性会被复制给孩子。显然，在大多数生物的繁殖系统中，双亲都会贡献等量的基因给孩子。但是在编程语言中，我们假设只有一个父类。
一旦孩子出生，他们就变成了单独的个体。虽然孩子会从父母继承许多特性，但是他是一个独一无二的存在。如果孩子的头发是红色，父母的头发未必是红的，也不会随之变红，二者之间没有直接的联系。</p>
<p>同理，定义好一个子类之后，相对于父类来说它就是一个独立并且完全不同的类。子类会包含父类行为的原始副本，但是也可以重写所有继承的行为甚至定义新行为。
非常重要的一点是，我们讨论的父类和子类并不是实例。父类和子类的比喻容易造成一些误解，实际上我们应当把父类和子类称为父类 DNA 和子类 DNA。我们需要根据这些 DNA 来创建(或者说实例化)一个人，然后才能和他进行沟通。</p>
<p>好了，我们先抛开现实中的父母和孩子，来看一个稍有不同的例子:不同类型的交通工具。这是一个非常典型(并且经常被抱怨)的讲解继承的例子。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">class</span> <span class="token class-name">Vehicle</span> <span class="token punctuation">{</span>
  engines <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token function">ignition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">output</span><span class="token punctuation">(</span><span class="token string">"Turning on my engine."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token function">drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">ignition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">output</span><span class="token punctuation">(</span><span class="token string">"Steering and moving forward!"</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">Car</span> inherits Vehicle <span class="token punctuation">{</span>
  wheels <span class="token operator">=</span> <span class="token number">4</span>
  <span class="token function">drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    inherited<span class="token punctuation">:</span> <span class="token function">drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">output</span><span class="token punctuation">(</span><span class="token string">"Rolling on all "</span><span class="token punctuation">,</span> wheels<span class="token punctuation">,</span> <span class="token string">" wheels!"</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">SpeedBoat</span> inherits Vehicle <span class="token punctuation">{</span>
  engines <span class="token operator">=</span> <span class="token number">2</span>
  <span class="token function">ignition</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">output</span><span class="token punctuation">(</span><span class="token string">"Turning on my "</span><span class="token punctuation">,</span> engines<span class="token punctuation">,</span> <span class="token string">" engines."</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token function">pilot</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    inherited<span class="token punctuation">:</span> <span class="token function">drive</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token function">output</span><span class="token punctuation">(</span><span class="token string">"Speeding through the water with ease!"</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
<p>我们通过定义<code>Vehicle</code>类来假设一种发动机，一种点火方式，一种驾驶方法。但是你不可 能制造一个通用的“交通工具”，因为这个类只是一个抽象的概念。
接下来我们定义了两类具体的交通工具:<code>Car</code>和<code>SpeedBoat</code>。它们都从<code>Vehicle</code>继承了通用的特性并根据自身类别修改了某些特性。汽车需要四个轮子，快艇需要两个发动机，因此 它必须启动两个发动机的点火装置。</p>
<h4 id="多态"><a href="#%E5%A4%9A%E6%80%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>多态</h4>
<p><code>Car</code>重写了继承自父类的<code>drive()</code>方法，但是之后<code>Car</code>调用了<code>inherited:drive(</code>)方法， 这表明<code>Car</code>可以引用继承来的原始<code>drive()</code>方法。快艇的<code>pilot()</code>方法同样引用了原始<code>drive()</code>方法。
这个技术被称为多态或者虚拟多态。在本例中，更恰当的说法是相对多态。
多态是一个非常广泛的话题，我们现在所说的“相对”只是多态的一个方面:任何方法都
可以引用继承层次中高层的方法(无论高层的方法名和当前方法名是否相同)。之所以说 “相对”是因为我们并不会定义想要访问的绝对继承层次(或者说类)，而是使用相对引用 “查找上一层”。
在许多语言中可以使用<code>super</code>来代替本例中的 inherited:，它的含义是“超类” (superclass)，表示当前类的父类/祖先类。
多态的另一个方面是，在继承链的不同层次中一个方法名可以被多次定义，当调用方法时 会自动选择合适的定义。
在之前的代码中就有两个这样的例子:drive() 被定义在<code>Vehicle</code>和<code>Car</code>中，<code>ignition()</code>被定义在<code>Vehicle</code>和<code>SpeedBoat</code>中。</p>
<h3 id="maxin"><a href="#maxin" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>maxin</h3>
<p>上面是描述的经典的面向对象编程中的基本的概念以及特征。</p>
<blockquote>
<p>我个人认为更应该叫面向类编程，而JavaScript才是真正的面向对象编程，JavaScript中只有对象而没有类的概念,并且可以不通过类就能直接创建对象。</p>
</blockquote>
<p>在继承或者实例化时，JavaScript的对象机制并不会自动执行复制行为。简单来说,JavaScript中只有对象，并不存在可以被实例化的“类”。一个对象并不会被复制到其他对象，它们会被<code>关联</code>起来。</p>
<p>由于在其他语言中类表现出来的都是复制行为，因此JavaScript开发者也想出了一个方法来模拟类的复制行为，这个方法就是混入。接下来我们会看到两种类型的混入:显式和隐式。</p>
<h4 id="显式混入"><a href="#%E6%98%BE%E5%BC%8F%E6%B7%B7%E5%85%A5" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>显式混入</h4>
<p>首先我们来回顾一下之前提到的<code>Vehicle</code>和<code>Car</code>。由于<code>JavaScript</code>不会自动实现<code>Vehicle</code>到<code>Car</code>的复制行为，所以我们需要手动实现复制功能。这个功能在许多库和框架中被称为<code>extend(..)</code>，但是为了方便理解我们称之为<code>mixin(..)</code>。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// 非常简单的 mixin(..) 例子 :</span>
<span class="token keyword">function</span> <span class="token function">mixin</span><span class="token punctuation">(</span>sourceObj<span class="token punctuation">,</span> targetObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> sourceObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment" spellcheck="true">// 只会在不存在的情况下复制</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>key <span class="token keyword">in</span> targetObj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      targetObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> sourceObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> targetObj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> Vehicle <span class="token operator">=</span> <span class="token punctuation">{</span>
  engines<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
  ignition<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Turning on my engine."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  drive<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">ignition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"Steering and moving forward!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> Car <span class="token operator">=</span> <span class="token function">mixin</span><span class="token punctuation">(</span>Vehicle<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  wheels<span class="token punctuation">:</span> <span class="token number">4</span><span class="token punctuation">,</span>
  drive<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    Vehicle<span class="token punctuation">.</span>drive<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>
      <span class="token string">"Rolling on all "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>wheels <span class="token operator">+</span> <span class="token string">" wheels!"</span>
    <span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<blockquote>
<p>有一点需要注意，我们处理的已经不再是类了，因为在 JavaScript 中不存在 类，Vehicle 和 Car 都是对象，供我们分别进行复制和粘贴。</p>
</blockquote>
<p>现在<code>Car</code>中就有了一份<code>Vehicle</code>属性和函数的副本了。从技术角度来说，函数实际上没有被复制，复制的是函数引用。所以，<code>Car</code>中的属性<code>ignition</code>只是从<code>Vehicle</code>中复制过来的对于<code>ignition()</code>函数的引用。相反，属性<code>engines</code> 就是直接从<code>Vehicle</code>中复制了值 1。
<code>Car</code>已经有了<code>drive</code>属性(函数)，所以这个属性引用并没有被<code>mixin</code>重写，从而保留了<code>Car</code>中定义的同名属性，实现了“子类”对“父类”属性的重写(参见 mixin(..) 例子中 的 if 语句)。</p>
<h4 id="显式多态"><a href="#%E6%98%BE%E5%BC%8F%E5%A4%9A%E6%80%81" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>显式多态</h4>
<p>我们来分析一下这条语句:<code>Vehicle.drive.call(this)</code>。这就是我所说的显式多态。还记得吗，在之前的伪代码中对应的语句是<code>inherited:drive()</code>，我们称之为<code>相对多态</code>。
JavaScript(在 ES6之前;参见附录A)并没有相对多态的机制。所以，由于<code>Car</code>和<code>Vehicle</code>中都有<code>drive()</code>函数，为了指明调用对象，我们必须使用绝对(而不是相对)引 用。我们通过名称显式指定<code>Vehicle</code>对象并调用它的<code>drive()</code>函数。
但是如果直接执行<code>Vehicle.drive()</code>，函数调用中的<code>this</code>会被绑定到<code>Vehicle</code>对象而不是<code>Car</code>对象，这并不是我们想要的。因此，我们会使用<code>.call(this)</code>来确保 drive() 在<code>Car</code>对象的上下文中执行。</p>
<p>复制操作完成后，<code>Car</code>就和<code>Vehicle</code>分离了，向<code>Car</code>中添加属性不会影响<code>Vehicle</code>，反之亦然。</p>
<blockquote>
<p>这里跳过了一些小细节，实际上，在复制完成之后两者之间仍然有一些巧妙 的方法可以“影响”到对方，例如引用同一个对象(比如一个数组)。</p>
</blockquote>
<p>由于两个对象引用的是同一个函数，因此这种复制(或者说混入)实际上并不能完全模拟面向类的语言中的复制。
JavaScript中的函数无法(用标准、可靠的方法)真正地复制，所以你只能复制对共享函数对象的引用(函数就是对象,只不过是可调用的对象)。如果你修改了共享的函数对象(比如 ignition())，比如添加了一个属性，那<code>Vehicle</code>和<code>Car</code>都会受到影响。
显式混入是JavaScript中一个很棒的机制，不过它的功能也没有看起来那么强大。虽然它可以把一个对象的属性复制到另一个对象中，但是这其实并不能带来太多的好处，无非就是少几条定义语句，而且还会带来我们刚才提到的函数对象引用问题。</p>
<p>在支持相对多态的面向类的语言中，<code>Car</code>和<code>Vehicle</code>之间的联系只在类定义的开头被创建,从而只需要在这一个地方维护两个类的联系。</p>
<p>但是在JavaScript中(由于屏蔽)使用显式伪多态会在所有需要使用(伪)多态引用的地 方创建一个函数关联，这会极大地增加维护成本。此外，由于显式伪多态可以模拟多重继承，所以它会进一步增加代码的复杂度和维护难度。
使用伪多态通常会导致代码变得更加复杂、难以阅读并且难以维护，因此应当尽量避免使 用显式伪多态，因为这样做往往得不偿失。</p>
<h3 id="solution"><a href="#solution" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>solution</h3>
<p>类是一种设计模式。许多语言提供了对于面向类软件设计的原生语法。JavaScript也有类似的语法，但是和其他语言中的类完全不同。</p>
<p>类意味着复制。</p>
<p>传统的类被实例化时，它的行为会被复制到实例中。类被继承时，行为也会被复制到子类中。</p>
<p>多态(在继承链的不同层次名称相同但是功能不同的函数)看起来似乎是从子类引用父类，但是本质上引用的其实是复制的结果。</p>
<p>JavaScript并不会(像类那样)自动创建对象的副本。</p>
<p>混入模式可以用来模拟类的复制行为，但是通常会产生丑陋并且脆弱的语法，比如显式伪多态<code>(OtherObj.methodName.call(this, ...))</code>，这会让代码更加难懂并且难以维护。</p>
<p>此外，显式混入实际上无法完全模拟类的复制行为，因为对象(和函数!别忘了函数也 是对象)只能复制引用，无法复制被引用的对象或者函数本身。忽视这一点会导致许多问题。
总地来说，在<code>JavaScript</code>中模拟类是得不偿失的，虽然能解决当前的问题，但是可能会埋下更多的隐患。</p>]]></description><link>https://reactjs.org/blog/2018/08/24/class-pattern.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/08/24/class-pattern.html</guid><pubDate>Thu, 23 Aug 2018 16:00:00 GMT</pubDate></item><item><title><![CDATA[FP13：IO - keep code pure]]></title><description><![CDATA[<h3 id="old-mcdonald-had-effects"><a href="#old-mcdonald-had-effects" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Old McDonald Had Effects…</h3>
<p>在关于纯函数的的那一章（即第 3 章）里，有一个很奇怪的例子。这个例子中的函数会产生副作用，但是我们通过把它包裹在另一个函数里的方式把它变得看起来像一个纯函数。这里还有一个类似的例子：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">//  getFromStorage :: String -> (_ -> String)</span>
<span class="token keyword">var</span> getFromStorage <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> localStorage<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
<p>要是我们没把<code>getFromStorage</code>包在另一个函数里，它的输出值就是不定的，会随外部环境变化而变化。有了这个结实的包裹函数（wrapper），同一个输入就总能返回同一个输出：一个从<code>localStorage</code>里取出某个特定的元素的函数。就这样（也许再高唱几句赞美圣母的赞歌）我们洗涤了心灵，一切都得到了宽恕。</p>
<p>然而，这并没有多大的用处，你说是不是。就像是你收藏的全新未拆封的玩偶，不能拿出来玩有什么意思。所以要是能有办法进到这个容器里面，拿到它藏在那儿的东西就好了…办法是有的，请看 IO：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> compose <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">...</span>fns<span class="token punctuation">)</span> <span class="token operator">=></span> x <span class="token operator">=></span> fns<span class="token punctuation">.</span><span class="token function">reduceRight</span><span class="token punctuation">(</span><span class="token punctuation">(</span>y<span class="token punctuation">,</span> f<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>

<span class="token keyword">class</span> <span class="token class-name">IO</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>_<span class="token punctuation">.</span><span class="token function">isFunction</span><span class="token punctuation">(</span>effect<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'IO Usage:function required'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>effect <span class="token operator">=</span> effect
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">of</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">from</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">map</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token function">compose</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>effect<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">effect</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
<p><code>IO</code>跟之前的<code>functor</code>不同的地方在于，它的<code>$value</code>(在这里叫<code>effect</code>)总是一个函数。不过我们不把它当作一个函数——实现的细节我们最好先不管。这里发生的事情跟我们在<code>getFromStorage</code>那里看到的一模一样：<code>IO</code>把非纯执行动作（impure action）捕获到包裹函数里，目的是延迟执行这个非纯动作。就这一点而言，我们认为<code>IO</code>包含的是被包裹的执行动作的返回值，而不是包裹函数本身。这在<code>of</code>函数里很明显<code>IO(function(){ return x })</code> 仅仅是为了延迟执行，其实我们得到的是<code>IO(x)</code>。</p>
<blockquote>
<p>IO和Maybe、Either不太一样，它包装的是effect函数，而不是一个值。但是，一个函数完全可以看作一个等待计算的惰性的值，不是吗</p>
</blockquote>
<p>来用用看：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// ioWindow :: IO Window</span>
<span class="token keyword">const</span> ioWindow <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> window<span class="token punctuation">)</span><span class="token punctuation">;</span>

ioWindow<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>win <span class="token operator">=></span> win<span class="token punctuation">.</span>innerWidth<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// IO(1430)</span>

ioWindow
  <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">prop</span><span class="token punctuation">(</span><span class="token string">'location'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">prop</span><span class="token punctuation">(</span><span class="token string">'href'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// IO(() => ['http:', '', 'localhost:8000', 'blog', 'posts'])</span>


<span class="token comment" spellcheck="true">// $ :: String -> IO [DOM]</span>
<span class="token keyword">const</span> $ <span class="token operator">=</span> selector <span class="token operator">=></span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'#myDiv'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>head<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>div <span class="token operator">=></span> div<span class="token punctuation">.</span>innerHTML<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// IO(() => 'I am some inner html')</span>
</code></pre>
      </div>
<p>这里，<code>io_window</code>是一个真正的<code>IO</code>，我们可以直接对它使用<code>map</code>。至于<code>$</code>，则是一个函数，调用后会返回一个<code>IO</code>。我把这里的返回值都写成了概念性的，这样就更加直观；不过实际的返回值是<code>{ effect: [Function] }</code>。当调用<code>IO</code>的 <code>map</code>的时候，我们把传进来的函数放在了<code>map</code>函数里的组合的最末端（也就是最左边），反过来这个函数就成为了新的<code>IO</code> 的新<code>effect</code>，并继续下去。传给<code>map</code>的函数并没有运行，我们只是把它们压到一个<strong>运行栈</strong>的最末端而已，一个函数紧挨着另一个函数，就像小心摆放的多米诺骨牌一样，让人不敢轻易推倒。这种情形很容易叫人联想起“四人帮”（《设计模式》一书作者）提出的命令模式（command pattern）或者队列（queue）。</p>
<p>好了，我们已经把野兽关进了笼子。但是，在某一时刻还是要把它放出来。因为对 IO 调用 map 已经积累了太多不纯的操作，最后再运行它无疑会打破平静。问题是在哪里，什么时候打开笼子的开关？而且有没有可能我们只运行 IO 却不让不纯的操作弄脏双手？答案是可以的，只要把责任推到调用者身上就行了。我们的纯代码，尽管阴险狡诈诡计多端，但是却始终保持一副清白无辜的模样，反而是实际运行 IO 并产生了作用的调用者，背了黑锅。来看一个具体的例子。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code>ioWindow
  <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">prop</span><span class="token punctuation">(</span><span class="token string">'location'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">prop</span><span class="token punctuation">(</span><span class="token string">'href'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
      </div>
<p>在没有执行<code>run</code>函数之前，我们所有的代码都是<code>纯的</code>,我们最后让<code>run</code>函数来背黑锅。</p>
<p>IO 会成为一个忠诚的伴侣，帮助我们驯化那些狂野的非纯操作</p>
<blockquote>
<p>也可以说IO相当于一定程度上的lazy Box</p>
</blockquote>
<h3 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>
<p>我们已经认识了几个不同的 functor，但它们的数量其实是无限的。有一些值得注意的可迭代数据类型（iterable data structure）我们没有介绍，像 tree、list、map 和 pair 等，以及所有你能说出来的。eventstream 和 observable 也都是 functor。</p>
<p>用多个 functor 参数调用一个函数怎么样呢？处理一个由不纯的或者异步的操作组成的有序序列怎么样呢？要应对这个什么都装在盒子里的世界，目前我们工具箱里的工具还不全。下一章，我们将直奔 monad 而去。</p>]]></description><link>https://reactjs.org/blog/2018/08/08/FP13-IO.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/08/08/FP13-IO.html</guid><pubDate>Tue, 07 Aug 2018 16:00:00 GMT</pubDate></item><item><title><![CDATA[FP12：Either:Left or Right]]></title><description><![CDATA[<h3 id="left-or-right-"><a href="#left-or-right-" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Left or Right ?</h3>
<p></p>
<p>说出来可能会让你震惊，<code>try/catch</code> 并不十分“纯”。当一个错误抛出的时候，我们没有收到返回值，反而是得到了一个警告！抛错的函数吐出一大堆的 0 和 1 作为盾和矛来攻击我们，简直就像是在反击输入值的入侵而进行的一场电子大作战。有了<code>Either</code>这个新朋友，我们就能以一种比向输入值宣战好得多的方式来处理错误，那就是返回一条非常礼貌的消息作为回应。我们来看一下：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">class</span> <span class="token class-name">Either</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// Either构造函数，接受一个异常或者合法的值</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$value <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token function">left</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Left</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token function">right</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Right</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token keyword">of</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Either<span class="token punctuation">.</span><span class="token function">right</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token function">fromNullable</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 若值非法则返回Left，否则返回Right</span>
        <span class="token keyword">return</span> val <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> Either<span class="token punctuation">.</span><span class="token function">right</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">:</span> Either<span class="token punctuation">.</span><span class="token function">left</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$value
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Left</span> <span class="token keyword">extends</span> <span class="token class-name">Either</span> <span class="token punctuation">{</span>
    <span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// Left不做任何操作</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span>
    <span class="token function">chain</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>   
        <span class="token keyword">return</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span>
    <span class="token function">filter</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span>
    <span class="token function">getOrElse</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 尝试提取Right中的值，如果不存在则返回默认值</span>
        <span class="token keyword">return</span> other
    <span class="token punctuation">}</span>
    <span class="token function">orElse</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment" spellcheck="true">// 将给定的函数应用于Left值，Right不做任何操作</span>
        <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">getOrElseThrow</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">fold</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Can’t extract the value of a Left(a).'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Right</span> <span class="token keyword">extends</span> <span class="token class-name">Either</span> <span class="token punctuation">{</span>
    <span class="token function">map</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Either<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$value<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">getOrElse</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$value
    <span class="token punctuation">}</span>
    <span class="token function">orElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span>
    <span class="token function">chain</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">getOrElseThrow</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$value
    <span class="token punctuation">}</span>
    <span class="token function">filter</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Either<span class="token punctuation">.</span><span class="token function">fromNullable</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$value<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$value <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token function">fold</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
<p>和<code>Maybe</code>略有不同，<code>Either</code>代表的是两个逻辑分离的Left和Right,他们永远不会同时出现：</p>
<ul>
<li>Left(a) —包含一个可能的错误消息或抛出的一场对象</li>
<li>Right(b) —包含一个成功的值
<code>Either</code>通常操作右值，这意味着在容器上映射函数总是在Right(b)子类型上执行。类似于Maybe的Just分支</li>
</ul>
<p>来看看它们是怎么运行的：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code>Either<span class="token punctuation">.</span><span class="token function">Right</span><span class="token punctuation">(</span><span class="token string">"rain"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">"b"</span><span class="token operator">+</span>str<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Right("brain")</span>

Either<span class="token punctuation">.</span><span class="token function">Left</span><span class="token punctuation">(</span><span class="token string">"rain"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">"b"</span><span class="token operator">+</span>str<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Left("rain")</span>

Either<span class="token punctuation">.</span><span class="token function">Right</span><span class="token punctuation">(</span><span class="token punctuation">{</span>host<span class="token punctuation">:</span> <span class="token string">'localhost'</span><span class="token punctuation">,</span> port<span class="token punctuation">:</span> <span class="token number">80</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">prop</span><span class="token punctuation">(</span><span class="token string">'host'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Right('localhost')</span>

Either<span class="token punctuation">.</span><span class="token function">Left</span><span class="token punctuation">(</span><span class="token string">"rolls eyes..."</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">prop</span><span class="token punctuation">(</span><span class="token string">"host"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Left('rolls eyes...')</span>
</code></pre>
      </div>
<p>Left 就像是青春期少年那样无视我们要 map 它的请求。Right 的作用就像是一个 Container（也就是 Identity）。这里强大的地方在于，Left 有能力在它内部嵌入一个错误消息。</p>
<p>假设有一个可能会失败的函数，就拿根据生日计算年龄来说好了。的确，我们可以用 Maybe(null) 来表示失败并把程序引向另一个分支，但是这并没有告诉我们太多信息。很有可能我们想知道失败的原因是什么。用 Either 写一个这样的程序看看：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> moment <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'moment'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// getAge :: Date -> User -> Either(String, Number)</span>
<span class="token keyword">const</span> getAge <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>now<span class="token punctuation">,</span> user<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> birthDate <span class="token operator">=</span> <span class="token function">moment</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>birthDate<span class="token punctuation">,</span> <span class="token string">'YYYY-MM-DD'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token keyword">return</span> birthDate<span class="token punctuation">.</span><span class="token function">isValid</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token operator">?</span> Either<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>now<span class="token punctuation">.</span><span class="token function">diff</span><span class="token punctuation">(</span>birthDate<span class="token punctuation">,</span> <span class="token string">'years'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">:</span> <span class="token function">left</span><span class="token punctuation">(</span><span class="token string">'Birth date could not be parsed'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">getAge</span><span class="token punctuation">(</span><span class="token function">moment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> birthDate<span class="token punctuation">:</span> <span class="token string">'2005-12-12'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Right(9)</span>

<span class="token function">getAge</span><span class="token punctuation">(</span><span class="token function">moment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> birthDate<span class="token punctuation">:</span> <span class="token string">'July 4, 2001'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Left('Birth date could not be parsed')</span>
</code></pre>
      </div>
<p>这么一来，就像<code>Maybe(null)</code>，当返回一个<code>Left</code>的时候就直接让程序短路。跟<code>Maybe(null)</code>不同的是，现在我们对程序为何脱离原先轨道至少有了一点头绪。有一件事要注意，这里返回的是<code>Either(String, Number)</code>，意味着我们这个 <code>Either</code>左边的值是<code>String</code>，右边（也就是正确的值）的值是<code>Number</code>。</p>
<p>如果 birthdate 合法，这个程序就会把它神秘的命运打印在屏幕上让我们见证；如果不合法，我们就会收到一个有着清清楚楚的错误消息的 Left，尽管这个消息是稳稳当当地待在它的容器里的。这种行为就像，虽然我们在抛错，但是是以一种平静温和的方式抛错，而不是像一个小孩子那样，有什么不对劲就闹脾气大喊大叫。</p>
<p>在这个例子中，我们根据 birthdate 的合法性来控制代码的逻辑分支，同时又让代码进行从右到左的直线运动，而不用爬过各种条件语句的大括号。通常，我们不会把 console.log 放到 zoltar 函数里，而是在调用 zoltar 的时候才 map 它，不过本例中，让你看看 Right 分支如何与 Left 不同也是很有帮助的。我们在 Right 分支的类型签名中使用 _ 表示一个应该忽略的值（在有些浏览器中，你必须要 console.log.bind(console) 才能把 console.log 当作一等公民使用）。</p>
<p>我想借此机会指出一件你可能没注意到的事：这个例子中，尽管 fortune 使用了 Either，它对每一个 functor 到底要干什么却是毫不知情的。前面例子中的 finishTransaction 也是一样。通俗点来讲，一个函数在调用的时候，如果被 map 包裹了，那么它就会从一个非 functor 函数转换为一个 functor 函数。我们把这个过程叫做 lift。一般情况下，普通函数更适合操作普通的数据类型而不是容器类型，在必要的时候再通过 lift 变为合适的容器去操作容器类型。这样做的好处是能得到更简单、重用性更高的函数，它们能够随需求而变，兼容任意 functor。</p>
<p>Either 并不仅仅只对合法性检查这种一般性的错误作用非凡，对一些更严重的、能够中断程序执行的错误比如文件丢失或者 socket 连接断开等，Either 同样效果显著。你可以试试把前面例子中的 Maybe 替换为 Either，看怎么得到更好的反馈。</p>
<blockquote>
<p>仅仅是把 Either 当作一个错误消息的容器使用，这样的介绍有失偏颇，它的能耐远不止于此。比如，它表示了逻辑或（也就是 ||）。再比如，它体现了范畴学里 coproduct 的概念，当然本书不会涉及这方面的知识，但值得你去深入了解，因为这个概念有很多特性值得利用。还比如，它是标准的 sum type（或者叫不交并集，disjoint union of sets），因为它含有的所有可能的值的总数就是它包含的那两种类型的总数</p>
</blockquote>
<h3 id="try-catch"><a href="#try-catch" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>try-catch</h3>
<p>Either还可以用来包装try-catch，来让我们的程序更加的适合函数组合(普通的try/catch会导致程序出现另一个出口，无法进行多个分支的组合)：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> tryCatch <span class="token operator">=</span> f <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Right</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Left</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
<h3 id="either-use-cases"><a href="#either-use-cases" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Either Use Cases</h3>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> openSite <span class="token operator">=</span> <span class="token punctuation">(</span>current_user<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>current_user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">renderpage</span><span class="token punctuation">(</span>current_user<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">showLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> openSite1 <span class="token operator">=</span> <span class="token punctuation">(</span>current_user<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token function">fromNullable</span><span class="token punctuation">(</span>current_user<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>showLogin<span class="token punctuation">,</span> renderpage<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> getPrefs <span class="token operator">=</span> user <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span>premium<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">loadPrefs</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>preferences<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> defaultPrefs
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> getPrefs1 <span class="token operator">=</span> user <span class="token operator">=></span>
    <span class="token punctuation">(</span>user<span class="token punctuation">.</span>premium <span class="token operator">?</span> <span class="token function">Right</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">Left</span><span class="token punctuation">(</span><span class="token string">'not premium'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>u <span class="token operator">=></span> u<span class="token punctuation">.</span>preferences<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> defaultPrefs<span class="token punctuation">,</span> prefs <span class="token operator">=></span> <span class="token function">loadPrefs</span><span class="token punctuation">(</span>prefs<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
      </div>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> streetName <span class="token operator">=</span> user <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> address <span class="token operator">=</span> user<span class="token punctuation">.</span>address
    <span class="token keyword">if</span> <span class="token punctuation">(</span>address<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> street <span class="token operator">=</span> address<span class="token punctuation">.</span>street
        <span class="token keyword">if</span> <span class="token punctuation">(</span>street<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> street<span class="token punctuation">.</span>name
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token string">'no street'</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> streetName1 <span class="token operator">=</span> user <span class="token operator">=></span>
    <span class="token function">fromNullable</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>address<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>a <span class="token operator">=></span> <span class="token function">fromNullable</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>street<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>s <span class="token operator">=></span> <span class="token function">fromNullable</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>e <span class="token operator">=></span> <span class="token string">'no street'</span><span class="token punctuation">,</span> n <span class="token operator">=></span> n<span class="token punctuation">)</span>
</code></pre>
      </div>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> concatUniq <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> ys<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> found <span class="token operator">=</span> ys<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>y <span class="token operator">=></span> y <span class="token operator">===</span> x<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span>
    <span class="token keyword">return</span> found <span class="token operator">?</span> ys <span class="token punctuation">:</span> ys<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> concatUniq1 <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> ys<span class="token punctuation">)</span> <span class="token operator">=></span>
    <span class="token function">fromNullable</span><span class="token punctuation">(</span>ys<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>y <span class="token operator">=></span> y <span class="token operator">===</span> x<span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> ys<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span> y <span class="token operator">=></span> ys<span class="token punctuation">)</span>
</code></pre>
      </div>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> wrapExamples <span class="token operator">=</span> example <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>example<span class="token punctuation">.</span>previewPath<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">try</span> <span class="token punctuation">{</span>
            example<span class="token punctuation">.</span>preview <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span>previewPath<span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> example
<span class="token punctuation">}</span>

<span class="token keyword">const</span> readFile <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token function">tryCatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> wrapExample <span class="token operator">=</span> example <span class="token operator">=></span>
    <span class="token function">fromNullable</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span>previewPath<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>readFile<span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> example<span class="token punctuation">,</span>
            preview <span class="token operator">=></span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> preview <span class="token punctuation">}</span><span class="token punctuation">,</span> example<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
      </div>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">const</span> parseDbUrl <span class="token operator">=</span> cfg <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> c <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>cfg<span class="token punctuation">)</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>c<span class="token punctuation">.</span>url<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> c<span class="token punctuation">.</span>url<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/postgres:\/\/([^:]+):([^@]+)@([^:]+):(\d+)\/(.+)/</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">null</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> parseDbUrl <span class="token operator">=</span> cfg <span class="token operator">=></span>
    <span class="token function">tryCatch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>cfg<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span>c <span class="token operator">=></span> <span class="token function">fromNullable</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>e <span class="token operator">=></span> <span class="token keyword">null</span><span class="token punctuation">,</span>
            u <span class="token operator">=></span> u<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/postgres:\/\/([^:]+):([^@]+)@([^:]+):(\d+)\/(.+)/</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre>
      </div>]]></description><link>https://reactjs.org/blog/2018/08/03/FP12-Either.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/08/03/FP12-Either.html</guid><pubDate>Thu, 02 Aug 2018 16:00:00 GMT</pubDate></item><item><title><![CDATA[FP11：Schrödinger's Maybe]]></title><description><![CDATA[<h3 id="schrödingers-maybe"><a href="#schr%C3%B6dingers-maybe" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schrödinger’s Maybe</h3>
<p></p>
<p>说实话上一章讲解的<code>Box</code> functor挺无聊的，通常我们称它为<code>Identity</code>，与<code>id</code>函数的作用相同（这里也是有数学上的联系的，我们会在适当时候加以说明）。除此之外，还有另外一种 functor，那就是实现了 map 函数的类似容器的数据类型，这种 functor 在调用 map 的时候能够提供非常有用的行为。现在让我们来定义一个这样的 functor。</p>
<p>Maybe Monad侧重于有效整合null-判断逻辑。Maybe是一个包含两个具体子类型的空类型(标记类型)</p>
<ul>
<li>Just(value)  — 表示值的容器</li>
<li>Nothing() — 表示要么没有值或者没有失败的附加信息，当然还可以应用函数到Nothing上</li>
</ul>
<p>这些字类型实现了<code>Identity</code> Functor的全部属性和方法，并且附加了一些独特的行为。Maybe的实现如下：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token keyword">class</span> <span class="token class-name">Maybe</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 容器类型(父类)</span>
    <span class="token keyword">static</span> <span class="token function">just</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Just</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token function">nothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Nothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">static</span> <span class="token keyword">of</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 由一个可为空的类型创建Maybe(即构造函数)</span>
        <span class="token keyword">return</span> a <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> Maybe<span class="token punctuation">.</span><span class="token function">just</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">:</span> Maybe<span class="token punctuation">.</span><span class="token function">nothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>

    <span class="token keyword">get</span> <span class="token function">isJust</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">get</span> <span class="token function">isNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// Just 子类型用于处理存在的值</span>
<span class="token keyword">class</span> <span class="token class-name">Just</span> <span class="token keyword">extends</span> <span class="token class-name">Maybe</span> <span class="token punctuation">{</span>       
    <span class="token function">constructor</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>$value <span class="token operator">=</span> val
    <span class="token punctuation">}</span>
    <span class="token function">map</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$value<span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 将映射函数作用于Just,变换其中的值，并存储回容器内</span>
    <span class="token punctuation">}</span>
    <span class="token function">filter</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        Maybe<span class="token punctuation">.</span><span class="token function">fromNullable</span><span class="token punctuation">(</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>$value<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$value <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// filter值</span>
    <span class="token punctuation">}</span>
    <span class="token function">getOrElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Monad提供默认的一元操作符，用于从中获取其值</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$value
    <span class="token punctuation">}</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$value
    <span class="token punctuation">}</span>
    <span class="token keyword">get</span> <span class="token function">isJust</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    <span class="token function">inspect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`Maybe.Just(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>$value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">// Nothing子类型用于为无值的情况提供保护</span>
<span class="token keyword">class</span> <span class="token class-name">Nothing</span> <span class="token keyword">extends</span> <span class="token class-name">Maybe</span> <span class="token punctuation">{</span>
    <span class="token function">map</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span>
    <span class="token punctuation">}</span>
    <span class="token function">getOrElse</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 忽略值返回other</span>
        <span class="token keyword">return</span> other
    <span class="token punctuation">}</span>
    <span class="token function">filter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$value
    <span class="token punctuation">}</span>
    <span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 任何试图直接从Nothing类型中取值的操作都会引发表征错误的信息</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'Can’t extract the value of a nothing'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">get</span> <span class="token function">isNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
    <span class="token function">inspect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token template-string"><span class="token string">`Maybe.Nothing`</span></span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
      </div>
<p><code>Maybe</code>看起来跟<code>Box</code>非常类似，但是有一点不同：<code>Maybe</code>会先检查自己的值是否为空，然后才调用传进来的函数。这样我们在使用<code>map</code>的时候就能避免恼人的空值了,因为再是空值的情况下，我们根本不会执行传递给map的映射函数，而是直接<code>return this</code>（注意这个实现出于教学目的做了简化）。</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code>Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"Malkovich Malkovich"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/a/ig</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//=> Maybe(['a', 'a'])</span>

Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/a/ig</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//=> Maybe(null)</span>

Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">"Boris"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">prop</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//=> Maybe(null)</span>

Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">"Dinah"</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">14</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">prop</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">//=> Maybe(24)</span>
</code></pre>
      </div>
<p>注意看，当传给<code>map</code>的值是<code>null</code>时，代码并没有爆出错误。这是因为每一次<code>Maybe</code>要调用函数的时候，都会先检查它自己的值是否为空。</p>
<p>这种点记法（dot notation syntax）已经足够函数式了，但是正如在第 1 部分指出的那样，我们更想保持一种 pointfree 的风格。碰巧的是，map 完全有能力以 curry 函数的方式来“代理”任何 functor：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// map :: Functor f => (a -> b) -> f a -> f b</span>
<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> anyFunctor<span class="token punctuation">)</span> <span class="token operator">=></span> anyFunctor<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
      </div>
<p>这样我们就可以像平常一样使用组合，同时也能正常使用 <code>map</code> 了，非常振奋人心。<code>ramda</code>的<code>map</code>也是这样。后面的章节中，我们将在点记法更有教育意义的时候使用点记法，在方便使用<code>pointfree</code>模式的时候就用 <code>pointfree</code>。你注意到了么？我在类型标签中偷偷引入了一个额外的标记：<code>Functor f =></code>。这个标记告诉我们<code>f</code>必须是一个<code>functor</code>。没什么复杂的，但我觉得有必要提一下。</p>
<h3 id="use-cases"><a href="#use-cases" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Use Cases</h3>
<p>实际当中，<code>Maybe</code>最常用在那些可能会无法成功返回结果的函数中，例如：查询数据库、在集合中查找、从服务器返回数据等</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// safeHead :: [a] -> Maybe(a)</span>
<span class="token keyword">const</span> safeHead <span class="token operator">=</span> xs <span class="token operator">=></span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>xs<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// streetName :: Object -> Maybe String</span>
<span class="token keyword">const</span> streetName <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">prop</span><span class="token punctuation">(</span><span class="token string">'street'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> safeHead<span class="token punctuation">,</span> <span class="token function">prop</span><span class="token punctuation">(</span><span class="token string">'addresses'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">streetName</span><span class="token punctuation">(</span><span class="token punctuation">{</span> addresses<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Nothing</span>

<span class="token function">streetName</span><span class="token punctuation">(</span><span class="token punctuation">{</span> addresses<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">{</span> street<span class="token punctuation">:</span> <span class="token string">'Shady Ln.'</span><span class="token punctuation">,</span> number<span class="token punctuation">:</span> <span class="token number">4201</span> <span class="token punctuation">}</span><span class="token punctuation">]</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Just('Shady Ln.')</span>
</code></pre>
      </div>
<p>safeHead 与一般的 _.head 类似，但是增加了类型安全保证。引入 Maybe 会发生一件非常有意思的事情，那就是我们被迫要与狡猾的 null 打交道了。safeHead 函数能够诚实地预告它可能的失败——失败真没什么可耻的——然后返回一个 Maybe 来通知我们相关信息。实际上不仅仅是通知，因为毕竟我们想要的值深藏在 Maybe 对象中，而且只能通过 map 来操作它。本质上，这是一种由 safeHead 强制执行的空值检查。有了这种检查，我们才能在夜里安然入睡，因为我们知道最不受人待见的 null 不会突然出现。类似这样的 API 能够把一个像纸糊起来的、脆弱的应用升级为实实在在的、健壮的应用，这样的 API 保证了更加安全的软件。</p>
<p>有时候函数可以明确返回一个 Maybe(null) 来表明失败，例如：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">// withdraw :: Number -> Account -> Maybe(Account)</span>
<span class="token keyword">const</span> withdraw <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token punctuation">(</span>amount<span class="token punctuation">,</span> <span class="token punctuation">{</span> balance <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span>
  Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>balance <span class="token operator">>=</span> amount <span class="token operator">?</span> <span class="token punctuation">{</span> balance<span class="token punctuation">:</span> balance <span class="token operator">-</span> amount <span class="token punctuation">}</span> <span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// This function is hypothetical, not implemented here... nor anywhere else.</span>
<span class="token comment" spellcheck="true">// updateLedger :: Account -> Account </span>
<span class="token keyword">const</span> updateLedger <span class="token operator">=</span> account <span class="token operator">=></span> account<span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// remainingBalance :: Account -> String</span>
<span class="token keyword">const</span> remainingBalance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> balance <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Your balance is $</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>balance<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">// finishTransaction :: Account -> String</span>
<span class="token keyword">const</span> finishTransaction <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>remainingBalance<span class="token punctuation">,</span> updateLedger<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token comment" spellcheck="true">// getTwenty :: Account -> Maybe(String)</span>
<span class="token keyword">const</span> getTwenty <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>finishTransaction<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token function">getTwenty</span><span class="token punctuation">(</span><span class="token punctuation">{</span> balance<span class="token punctuation">:</span> <span class="token number">200.00</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
<span class="token comment" spellcheck="true">// Just('Your balance is $180')</span>

<span class="token function">getTwenty</span><span class="token punctuation">(</span><span class="token punctuation">{</span> balance<span class="token punctuation">:</span> <span class="token number">10.00</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// Nothing</span>
</code></pre>
      </div>
<p>要是钱不够，<code>withdraw</code>就会对我们嗤之以鼻然后返回一个<code>Maybe(null)</code>。<code>withdraw</code>也显示出了它的多变性，使得我们后续的操作只能用<code>map</code>来进行。这个例子与前面例子不同的地方在于，这里的<code>null</code>是有意的。我们不用<code>Maybe(String)</code>，而是用 <code>Maybe(null)</code>来发送失败的信号，这样程序在收到信号后就能立刻停止执行。这一点很重要：如果<code>withdraw</code>失败了，<code>map</code>就会切断后续代码的执行，因为它根本就不会运行传递给它的函数，即<code>finishTransaction</code>。</p>
<p>这正是预期的效果：如果取款失败，我们并不想更新或者显示账户余额。</p>
<h3 id="releasing-the-value"><a href="#releasing-the-value" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Releasing the Value</h3>
<p>人们经常忽略的一个事实是：任何事物都有个最终尽头。那些会产生作用的函数，不管它们是发送 JSON 数据，还是在屏幕上打印东西，还是更改文件系统，还是别的什么，都要有一个结束。但是我们无法通过 return 把输出传递到外部世界，必须要运行这样或那样的函数才能传递出去。关于这一点，可以借用禅宗公案的口吻来叙述：“如果一个程序运行之后没有可观察到的作用，那它到底运行了没有？”。或者，运行之后达到自身的目的了没有？有可能它只是浪费了几个 CPU 周期然后就去睡觉了…</p>
<p>应用程序所做的工作就是获取、更改和保存数据直到不再需要它们，对数据做这些操作的函数有可能被 map 调用，这样的话数据就可以不用离开它温暖舒适的容器。讽刺的是，有一种常见的错误就是试图以各种方法删除 Maybe 里的值，好像这个不确定的值是魔鬼，删除它就能让它突然显形，然后一切罪恶都会得到宽恕似的（译者注：此处原文应该是源自圣经）。要知道，我们的值没有完成它的使命，很有可能是其他代码分支造成的。我们的代码，就像薛定谔的猫一样，在某个特定的时间点有两种状态，而且应该保持这种状况不变直到最后一个函数为止。这样，哪怕代码有很多逻辑性的分支，也能保证一种线性的工作流。</p>
<p>不过，对容器里的值来说，还是有个逃生口可以出去。也就是说，如果我们想返回一个自定义的值然后还能继续执行后面的代码的话，是可以做到的；要达到这一目的，可以借助一个帮助函数 maybe：</p>
<div class="gatsby-highlight">
      <pre class="gatsby-code-jsx"><code><span class="token comment" spellcheck="true">//  maybe :: b -> (a -> b) -> Maybe a -> b</span>
<span class="token keyword">var</span> maybe <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> f<span class="token punctuation">,</span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">isNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> x <span class="token punctuation">:</span> <span class="token function">f</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>__value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment" spellcheck="true">//  getTwenty :: Account -> String</span>
<span class="token keyword">var</span> getTwenty <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>
  <span class="token function">maybe</span><span class="token punctuation">(</span><span class="token string">"You're broke!"</span><span class="token punctuation">,</span> finishTransaction<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">withdraw</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>


<span class="token function">getTwenty</span><span class="token punctuation">(</span><span class="token punctuation">{</span> balance<span class="token punctuation">:</span> <span class="token number">200.00</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// "Your balance is $180.00"</span>

<span class="token function">getTwenty</span><span class="token punctuation">(</span><span class="token punctuation">{</span> balance<span class="token punctuation">:</span> <span class="token number">10.00</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">// "You're broke!"</span>
</code></pre>
      </div>
<p>这样就可以要么返回一个静态值（与 finishTransaction 返回值的类型一致），要么继续愉快地在没有 Maybe 的情况下完成交易。maybe 使我们得以避免普通 map 那种命令式的 <code>if/else</code> 语句：<code>if(x !== null) { return f(x) }else{ return null }</code>。</p>
<p>引入 Maybe 可能会在初期造成一些不适。<code>Swift</code> 和 <code>Scala</code> 用户知道我在说什么，因为这两门语言的核心库里就有 Maybe 的概念，只不过伪装成 Option(al) 罢了。被迫在任何情况下都进行空值检查（甚至有些时候我们可以确定某个值不会为空），的确让大部分人头疼不已。然而随着时间推移，空值检查会成为第二本能，说不定你还会感激它提供的安全性呢。不管怎么说，空值检查大多数时候都能防止在代码逻辑上偷工减料，让我们脱离危险。</p>
<p>编写不安全的软件就像用蜡笔小心翼翼地画彩蛋，画完之后把它们扔到大街上一样（意思是彩蛋非常易于寻找。来源于复活节习俗，人们会藏起一些彩蛋让孩子寻找），或者像用三只小猪警告过的材料盖个养老院一样（来源于“三只小猪”童话故事）。Maybe 能够非常有效地帮助我们增加函数的安全性。</p>
<p>有一点我必须要提及，否则就太不负责任了，那就是 Maybe 的“真正”实现会把它分为两种类型：一种是非空值，另一种是空值。这种实现允许我们遵守 map 的 parametricity 特性，因此 null 和 undefined 能够依然被 map 调用，functor 里的值所需的那种普遍性条件也能得到满足。所以你会经常看到 Some(x) / None 或者 Just(x) / Nothing 这样的容器类型在做空值检查，而不是 Maybe。</p>]]></description><link>https://reactjs.org/blog/2018/08/02/FP11-Maybe.html</link><guid isPermaLink="false">https://reactjs.org/blog/2018/08/02/FP11-Maybe.html</guid><pubDate>Wed, 01 Aug 2018 16:00:00 GMT</pubDate></item></channel></rss>