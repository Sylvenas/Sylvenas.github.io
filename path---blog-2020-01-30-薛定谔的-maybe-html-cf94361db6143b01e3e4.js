webpackJsonp([0xa83bef34c20b],{568:function(n,s){n.exports={data:{markdownRemark:{html:'<h3 id="副作用"><a href="#%E5%89%AF%E4%BD%9C%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>副作用</h3>\n<p>程序的可观察，而不是操作了一番然后睡觉去了</p>\n<p>上篇文章中引入范畴学中<code class="gatsby-code-text">Functor</code>的概念，核心内容就是把一个值放入到一个<code class="gatsby-code-text">Box</code>中，然后不停的通过<code class="gatsby-code-text">map</code>函数来映射变换其中的值，而这就是一个最简单的<code class="gatsby-code-text">Identity Functor</code>,但是管他呢，我们还是叫它Box吧(多么简单形象)！</p>\n<p>然后还举了个Either的例子，来说明Box理念在代码中实际用途，接下来介绍另外两个常用的<code class="gatsby-code-text">Box</code>:<strong><code class="gatsby-code-text">Maybe</code></strong>,<strong><code class="gatsby-code-text">IO</code></strong></p>\n<h3 id="schrödingers-maybe"><a href="#schr%C3%B6dingers-maybe" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Schrödinger’s Maybe</h3>\n<p><img src="./imgs/cat.jpeg" alt="薛定谔的猫"></p>\n<blockquote>\n<p>I call it my billion-dollar mistake. It was the invention of the null reference in 1965. — Tony Hoare</p>\n</blockquote>\n<p>在项目开发中无时不刻不在遇到<code class="gatsby-code-text">null</code>的问题,举个实际的例子，最近在做一个换肤的功能，需要根据用户的选择来动态的加载CSS主题样式，需要编写一个<code class="gatsby-code-text">getThemeForUser</code>函数，根据用户的之前的选择，从URL列表中中返回合适的URL，看个简单的代码描述：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>\n  id<span class="token punctuation">:</span> <span class="token string">\'hzxxxx\'</span><span class="token punctuation">,</span>\n  name<span class="token punctuation">:</span> <span class="token string">\'zhangsan\'</span><span class="token punctuation">,</span>\n  infos<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    theme<span class="token punctuation">:</span> <span class="token string">\'red\'</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> <span class="token constant">THEME_CSS_URLS</span> <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token string">\'default\'</span><span class="token punctuation">:</span> <span class="token string">\'https://xxx.com/theme-default.css\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'red\'</span><span class="token punctuation">:</span> <span class="token string">\'https://xxx.com/theme-red.css\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'dark\'</span><span class="token punctuation">:</span> <span class="token string">\'https://xxx.com/theme-dark.css\'</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> <span class="token function-variable function">getThemeForUser</span> <span class="token operator">=</span> user <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token comment">// TODO</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>在编写<code class="gatsby-code-text">getThemeForUser</code>函数之前，我们先考虑一下问题：</p>\n<ul>\n<li>用户可能根本没有选择主题，而是使用的默认主题，<code class="gatsby-code-text">infos</code>对象中<code class="gatsby-code-text">theme</code>的value可能为null/undefined</li>\n<li>user本身也可能为null，用户还没有登陆</li>\n<li>数据异常，给出的主题色，可能不在<code class="gatsby-code-text">THEME_CSS_URLS</code>中   </li>\n</ul>\n<p>那么现在我们不得不处理很多个null/undefined,我们尝试编写第一个版本的<code class="gatsby-code-text">getThemeForUser</code>函数：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">getThemeForUser</span> <span class="token operator">=</span> user <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 没有登录进来</span>\n    <span class="token keyword">return</span> <span class="token constant">THEME_CSS_URLS</span><span class="token punctuation">[</span><span class="token string">\'default\'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment">// 返回默认主题</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">if</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span>infos<span class="token punctuation">.</span>theme <span class="token operator">&amp;&amp;</span> user<span class="token punctuation">.</span>infos<span class="token punctuation">.</span>theme <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token constant">THEME_CSS_URLS</span><span class="token punctuation">[</span>user<span class="token punctuation">.</span>infos<span class="token punctuation">.</span>theme<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 如果存在主题</span>\n      <span class="token keyword">return</span> <span class="token constant">THEME_CSS_URLS</span><span class="token punctuation">[</span>user<span class="token punctuation">.</span>infos<span class="token punctuation">.</span>theme<span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token constant">THEME_CSS_URLS</span><span class="token punctuation">[</span><span class="token string">\'default\'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n  <span class="token keyword">return</span> <span class="token constant">THEME_CSS_URLS</span><span class="token punctuation">[</span><span class="token string">\'default\'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">getThemeForUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// => \'https://xxx.com/theme-red.css\'</span></code></pre>\n      </div>\n<blockquote>\n<p>类似这样的代码在前端项目中，随处可见；有人认为很多的if判断增强了JavaScript代码的健壮性，但是反过来说，也可以认为这是一段简单的代码，打上各种补丁之后，终于可以正常运转了(我不认为这是让代码更健壮的方案，反而更像是一段温室中的代码)</p>\n</blockquote>\n<p>再举一个更普遍的例子：很多时候服务端接口文档，明确写了返回值为<code class="gatsby-code-text">Array</code>类型，但是没有值的时候，会直接给一个<code class="gatsby-code-text">null</code>而不是一个<code class="gatsby-code-text">empty Array</code>，这个时候客户端如果不做校验，直接作为<code class="gatsby-code-text">Array</code>类型来处理，<code class="gatsby-code-text">Uncaught TypeError</code>的错误是不可避免的；或者某个嵌套的JSON结构中，不知道哪一层就会出现<code class="gatsby-code-text">null</code>，我们总不能一直作出这样的判断吧<code class="gatsby-code-text">if(response &amp;&amp; response.a &amp;&amp; response.a.b ...)</code>!</p>\n<p>为此经常这段代码简直就是<strong>薛定谔的猫</strong>，根据数据库数据的不同返回的结构完全不可预知，客户端只有在拿到数据的那一刻，才能确定下来！</p>\n<p>现在我们面临的问题就是我们无法提前预知到底什么时候会出现<code class="gatsby-code-text">null/undefined</code>，如果出现的情况下，我们又该如何优雅而准确的处理<code class="gatsby-code-text">null/undefined</code>的问题！</p>\n<p>为此薛定谔的Maybe出场的时候到了，来看一看另一个Box：<strong>Maybe</strong></p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">Just</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n  map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Just</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n  fold<span class="token punctuation">:</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  getOrElse<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> x<span class="token punctuation">,</span>\n  inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Maybe.Just(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> <span class="token function-variable function">Nothing</span> <span class="token operator">=</span> x <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n  map<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">Nothing</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  fold<span class="token punctuation">:</span> <span class="token punctuation">(</span>f<span class="token punctuation">,</span> g<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">,</span>\n  getOrElse<span class="token punctuation">:</span> v <span class="token operator">=></span> v<span class="token punctuation">,</span>\n  inspect<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token template-string"><span class="token string">`Maybe.Nothing`</span></span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> <span class="token function-variable function">Maybe</span> <span class="token operator">=</span> x <span class="token operator">=></span>\n  x <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token function">Just</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">:</span> <span class="token function">Nothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>Maybe的实现会把类型分为两类，一类是非空值，另一类是空值，所以经常会看到<code class="gatsby-code-text">Some(x)/None</code>或者<code class="gatsby-code-text">Just(x)/Nothing</code>这样的实现。</p>\n<blockquote>\n<p>Java8 和 scale中分别成为<code class="gatsby-code-text">Optional</code>和<code class="gatsby-code-text">Option</code>,他们将Just和Nothing称为Some和None,本质上并没有什么区别</p>\n</blockquote>\n<p>一般来说Maybe会提供一个<code class="gatsby-code-text">getOrElse</code>函数，用来做出获取到值(Just)则给出正确的值，如果没有取到则提供一个默认值,Nothing会把传进来的otherValue作为回退方案。</p>\n<p>下面看一下Maybe的基本用法：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token constant">R</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'ramda\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> match <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>match<span class="token punctuation">;</span>\n\n<span class="token function">Maybe</span><span class="token punctuation">(</span><span class="token string">\'hello world\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/o/ig</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// => Maybe.Just(o,o)</span>\n<span class="token function">Maybe</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/a/ig</span><span class="token punctuation">)</span>  <span class="token comment">// => Maybe.Nothing</span></code></pre>\n      </div>\n<blockquote>\n<p>这里引入了<a href="https://github.com/ramda/ramda">Ramda.js</a>,提供了很多函数式风格的封装，避免了我们重复造轮子，但是他们一般不会提供函数式编程的核心的数学概念，比如：<code class="gatsby-code-text">Monad、functor、Foldable</code></p>\n<p>实现了<a href="https://github.com/fantasyland/fantasy-land"><code class="gatsby-code-text">Fantasy-Land</code></a>规范的库,比如<a href="https://github.com/ramda/ramda-fantasy"><code class="gatsby-code-text">ramda-fantasy</code></a>,<a href="https://github.com/origamitower/folktale"><code class="gatsby-code-text">folktale</code></a>等,他们的实现比较工程化和严谨(适合正式的项目中引入)，但这里为了方便理解，我们选择继续扩展我们的<strong>Box</strong>,而不会引入这些类库</p>\n</blockquote>\n<p>现在尝试用<code class="gatsby-code-text">Maybe</code>来重写一下<code class="gatsby-code-text">getThemeForUser</code>函数：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token constant">R</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'ramda\'</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> path <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>path\n<span class="token keyword">const</span> curry <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>curry\n\n<span class="token keyword">const</span> <span class="token function-variable function">getThemeForUser</span> <span class="token operator">=</span> user <span class="token operator">=></span>\n  <span class="token function">Maybe</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">path</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">\'infos\'</span><span class="token punctuation">,</span> <span class="token string">\'theme\'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>maybeGetTheme<span class="token punctuation">,</span> maybeGetTheme<span class="token punctuation">)</span>\n\n\n<span class="token keyword">const</span> maybeGetTheme <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span>\n  <span class="token punctuation">(</span>urls<span class="token punctuation">,</span> themeName<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">Maybe</span><span class="token punctuation">(</span>urls<span class="token punctuation">[</span>themeName<span class="token punctuation">]</span><span class="token punctuation">)</span>\n<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token constant">THEME_CSS_URLS</span><span class="token punctuation">)</span>\n\n\n<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">getThemeForUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOrElse</span><span class="token punctuation">(</span><span class="token constant">THEME_CSS_URLS</span><span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// => https://xxx.com/theme-red.css</span></code></pre>\n      </div>\n<blockquote>\n<p><code class="gatsby-code-text">getThemeForUser</code>函数中最后为何使用<code class="gatsby-code-text">fold</code>而不是<code class="gatsby-code-text">map</code>呢？这是因为<code class="gatsby-code-text">maybeGetTheme</code>函数的入参是<code class="gatsby-code-text">themeName</code>,而<code class="gatsby-code-text">getThemeForUser</code>函数的返回值是<code class="gatsby-code-text">Maybe(themeName)</code>；</p>\n<p>关于<code class="gatsby-code-text">fold</code>的两个一样的参数，在没有引入<code class="gatsby-code-text">chain</code>函数之前，我们暂时继续使用<code class="gatsby-code-text">flod</code>函数把<code class="gatsby-code-text">themeName</code>从<code class="gatsby-code-text">Maybe(themeName)</code>中释放出来,后面会和嵌套的<code class="gatsby-code-text">tryCatch</code>问题一起给出解决方案，现在先暂时放下这个问题</p>\n<p>使用柯里化的<code class="gatsby-code-text">maybeGetTheme</code>函数，避免访问全局变量，并再次使用<code class="gatsby-code-text">Maybe</code>包装可能为空的数据，最后使用<code class="gatsby-code-text">getOrElse</code>取出Maybe中的值</p>\n</blockquote>\n<p>Maybe和Either中的<code class="gatsby-code-text">fromNullable</code>看上去非常类似，至少从代码上来看是这样的，但是现在必须要说明一点的是：Either更过的时候会被用来处理逻辑分支以及异常恢复，而Maybe则用来处理空值检查比较多，在使用理念上不同。</p>\n<p>一个常见的用法是<code class="gatsby-code-text">xxx.getOrElse(throw new Error(&#39;Fail&#39;))</code>将结果是一个Nothing的Maybe转回一个异常，一般的经验法则则是在没有合理的方案能捕获异常时将其抛出；如果异常是一种可恢复的错误，使用Either会更加灵活</p>\n<p>引入<code class="gatsby-code-text">Maybe</code>可能会造成一些不适，熟悉Scala的用户应该知道<code class="gatsby-code-text">Option</code>，或者Java中的<code class="gatsby-code-text">Optional</code>,是完全类似的概念；Scale中被迫在任何情况下都进行空值检查，的确让人头疼不已。随着时间的推移，空值检查会成为第二本能，说不定你还会感激它提供的安全性呢。不管怎么说，空值检查大多数时候都能防止在代码逻辑上偷工减料，让我们脱离危险。</p>\n<h3 id="甩锅侠io"><a href="#%E7%94%A9%E9%94%85%E4%BE%A0io" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>甩锅侠IO</h3>\n<h4 id="保持纯与副作用"><a href="#%E4%BF%9D%E6%8C%81%E7%BA%AF%E4%B8%8E%E5%89%AF%E4%BD%9C%E7%94%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>保持纯与副作用</h4>\n<p>我们知道函数式编程的理念中，函数要保持“纯”的概念，即不能修改外部的变量，仅仅依赖于函数入参；也不能产生任何与以上可观察的副作用或输出，比如典型的读写操作。从代码编写者的角度来看，如果一段程序运行之后没有可观察到的作用，那他到底运行了没有？或者运行之后有没有实现代码的目的？有可能它只是浪费了几个CPU周期之后就去睡大觉了！！！</p>\n<p>从JavaScript语言的诞生之初就不可避免地需要能够不断变化的，共享的，有状态的DOM互相作用；如果无法输入输出任何数据，那么数据库有什么用处呢？如果无法从网络请求信息，我们的页面又该如何展示？没有<code class="gatsby-code-text">side effect</code>我们几乎寸步难行。上述的任何一个操作，都会产生副作用，违反引用透明性，我们似乎陷入了两难的境地！</p>\n<blockquote>\n<p>世間安得雙全法，不負如來不負卿</p>\n</blockquote>\n<p><strong>如何在<code class="gatsby-code-text">keep pure</code>的前提下，又能妥善的处理<code class="gatsby-code-text">side effect</code>呢？</strong></p>\n<p>答案是用数学的思维：<strong>作弊</strong>！</p>\n<ul>\n<li><strong>Dependency injection(依赖注入)</strong>：把函数中不纯的部分，踢出去，作为参数传递进来</li>\n<li><strong>IO Functor/</strong>:把产生<code class="gatsby-code-text">side effect</code>的部分包裹起来,带着这个保护壳参与运算，直到需要结果时再打开运行</li>\n</ul>\n<h4 id="dependency-injection"><a href="#dependency-injection" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Dependency injection</h4>\n<p>依赖注入式我们处理副作用的第一种方法，我们把代码中任何不纯的部分从函数中剔除，然后我们将他们作为传递进来，看一段代码：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">logSomething</span> <span class="token operator">=</span> something <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> dt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toISOString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dt<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>something<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> something<span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p><code class="gatsby-code-text">logSomething</code>函数有两个不纯的因素：首先创建了一个动态的Date,然后记录到console！因此不仅执行了IO,而且每一次执行的结果也都不一样。那么如何将这个函数变得pure呢？通过依赖注入我们可以把不纯的部分作为参数，所以现在函数应该被修改为接受三个参数的函数：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">function</span> <span class="token function">logSomething</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> cnsl<span class="token punctuation">,</span> something<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> dt <span class="token operator">=</span> d<span class="token punctuation">.</span><span class="token function">toISOString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> cnsl<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>dt<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">: </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>something<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>如此这般logSomething函数就可以做到相同的输入，对应相同的输出了：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> something <span class="token operator">=</span> <span class="token string">"idiot !"</span>\n<span class="token keyword">const</span> d <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token function">logSomething</span><span class="token punctuation">(</span>d<span class="token punctuation">,</span> console<span class="token punctuation">,</span> something<span class="token punctuation">)</span></code></pre>\n      </div>\n<p>看到这里，你可能会想，这简直蠢爆了！就像在假装无知的说：“我不知道调用cnsl对象上的log会执行IO,只是其他人把它传给了我！”</p>\n<p>尽管如此，它并不是一个单纯的傻瓜，至少这种思想可以延伸出来一个思路： </p>\n<ul>\n<li><strong>把不纯的部分剥离出来,让不纯的代码远离核心的logSomething函数</strong></li>\n<li><strong>缩小了不确定性的范围，目前看起来只有log函数不纯</strong></li>\n<li><strong>副作用集中管理，如果反复的缩小不确定的范围，我们甚至可以把不纯的代码推到代码的边缘，保证核心的pure和referential transparency</strong></li>\n</ul>\n<p>缺点在于：</p>\n<ul>\n<li>会导致方法签名过长，logSomething从一个参数变成了三个参数</li>\n<li>传参的链路过长，可能导致多个函数在传递一长串的参数</li>\n</ul>\n<h4 id="io-functor"><a href="#io-functor" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>IO Functor</h4>\n<p>现在我们来看看另外一种解决思路：IO Functor。在开始之前，我们先回顾一下JavaScript中的函数：由于函数的一等性和高阶性，JavaScript函数具有<strong>值的行为</strong>，也就是说，函数就是一个基于输入的切尚未求值的不可变的值，或者可以认为一个函数本身就是一个等待计算的惰性的值。</p>\n<p>回想一下，我们前面一篇中说的，Box理念，既然函数只是<strong>惰性的值</strong>，我们何不把函数也包裹进Box中，等到需要的时候，在取出来！看代码：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">LazyBox</span> <span class="token operator">=</span> g <span class="token operator">=></span> <span class="token punctuation">(</span><span class="token punctuation">{</span>\n\tmap<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">LazyBox</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n\tfold<span class="token punctuation">:</span> f <span class="token operator">=></span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<blockquote>\n<p><code class="gatsby-code-text">map: f =&gt; LazyBox(() =&gt; f(g()))</code>，也可以使用<code class="gatsby-code-text">const compose = (...fns) =&gt; (...args) =&gt; fns.reduceRight((res, fn) =&gt; [fn.call(null, ...res)], args)[0]</code>和<code class="gatsby-code-text">map: f =&gt; LazyBox(compose(f, g))</code>的结合，并且更为合理;但是此处为了保持便于理解和代码简洁，没有采用</p>\n</blockquote>\n<p>注意观察，我们没有调用fold函数，解封其中的值之前,map函数所做的一直都是在组合函数，函数并没有被实际的调用:</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">nextChartFromNumberString</span> <span class="token operator">=</span> str <span class="token operator">=></span>\n\t<span class="token function">LazyBox</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> str<span class="token punctuation">)</span>\n\t\t<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'hahaha\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\t\t<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>r <span class="token operator">=></span> <span class="token function">parseInt</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span>\n\t\t<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">=></span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>\n\t\t<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">=></span> String<span class="token punctuation">.</span><span class="token function">fromCharCode</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">nextChartFromNumberString</span><span class="token punctuation">(</span><span class="token string">\' 64\'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span>  <span class="token comment">// => { map: [Function: map], fold: [Function: fold] },</span>\n<span class="token comment">// 而并没有打印出\'hahaha\' </span></code></pre>\n      </div>\n<blockquote>\n<p>这一特性有点类似递归，在未满足终止条件之前(没用调用fold之前)，递归调用会在栈中不断的堆叠，直到满足终止条件(调用fold函数)，才真正的开始计算</p>\n<p>同样类似与递归，可能会出现Maximum call stack size exceeded的错误</p>\n<p>IO也和Rxjs中的<code class="gatsby-code-text">Observable</code>有很多相似之处，两者都是惰性的，在调用<code class="gatsby-code-text">subscribe</code>之前<code class="gatsby-code-text">Observable</code>也不会执行，在调用subscribe之后</p>\n</blockquote>\n<p>再看一个读取文件的例子：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token function-variable function">readFile</span> <span class="token operator">=</span> <span class="token punctuation">(</span>filename<span class="token punctuation">,</span> enc<span class="token punctuation">)</span> <span class="token operator">=></span>\n\tfs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span>filename<span class="token punctuation">,</span> enc<span class="token punctuation">)</span>\n\n\n<span class="token keyword">const</span> content <span class="token operator">=</span> <span class="token function">LazyBox</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">\'config.json\'</span><span class="token punctuation">,</span> <span class="token string">\'utf-8\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\t<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>str <span class="token operator">=></span> str<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex">/8/g</span><span class="token punctuation">,</span> <span class="token string">\'6\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\t<span class="token punctuation">.</span><span class="token function">fold</span><span class="token punctuation">(</span>x <span class="token operator">=></span> x<span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>content<span class="token punctuation">)</span>  <span class="token comment">// => {"post":6666}</span></code></pre>\n      </div>\n<p>在没有调用fold函数之前，我们的代码都是纯的；flod函数就像打开潘多拉魔盒的双手；通过LazyBox我们把可能会弄脏双手的代码扔给了最后的fold，甩锅成功！</p>\n<p>可以看到，我们这里使用的是同步的读取文件的例子，现在我们解决了<code class="gatsby-code-text">side effect</code>的问题，但是异步呢？异步该如何解决呢？不要着急，等我们介绍完了monad之后，会给出解决方案</p>\n<blockquote>\n<p>看到这里，是不是想起来了React中的useEffect</p>\n<p>诚然，副作用依然存在，并没有消除，但是可以通过类似的方式，让大部分的代码保持纯的特性，享受纯函数带来的引用透明的好处</p>\n</blockquote>\n<h3 id="关于functor的定律"><a href="#%E5%85%B3%E4%BA%8Efunctor%E7%9A%84%E5%AE%9A%E5%BE%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>关于Functor的定律</h3>\n<ul>\n<li>\n<p>必须是无副作用的。若映射<code class="gatsby-code-text">identity</code>(<code class="gatsby-code-text">x =&gt; x</code>)函数可以获取上下文中相同的值，既可以证明Functor是无副作用的。\n<code class="gatsby-code-text">Box(&#39;hello world&#39;).map(identity) // =&gt; Box(hello world)</code></p>\n</li>\n<li>\n<p>必须是可组合的。这个属性的意思是多个map函数的组合，与分别map函数的结果是一样的</p>\n</li>\n</ul>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> <span class="token constant">R</span> <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'ramda\'</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> reverse <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>reverse\n<span class="token keyword">const</span> toUpper <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>toUpper\n<span class="token keyword">const</span> compose <span class="token operator">=</span> <span class="token constant">R</span><span class="token punctuation">.</span>compose\n\n<span class="token function">Box</span><span class="token punctuation">(</span><span class="token string">\'hello world\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>reverse<span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>toUpper<span class="token punctuation">)</span>  <span class="token comment">// => Box(DLROW OLLEH)</span>\n\n<span class="token function">Box</span><span class="token punctuation">(</span><span class="token string">\'hello world\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">compose</span><span class="token punctuation">(</span>toUpper<span class="token punctuation">,</span> reverse<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<h3 id="summary"><a href="#summary" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Summary</h3>\n<p>关于Functor的介绍暂时告一段落，我们已经介绍了几个常用的Functor:<code class="gatsby-code-text">Either</code>、<code class="gatsby-code-text">Maybe</code>、<code class="gatsby-code-text">IO</code>等等，但是其实根据应用场景的不同，我们可以创造出无数个Functor，比如：<code class="gatsby-code-text">tree</code>、<code class="gatsby-code-text">list</code>、<code class="gatsby-code-text">map</code>等等；</p>\n<p>并且介绍了如果在保持pure的同时，处理side effect的两个方案：<code class="gatsby-code-text">Dependency injection</code>与<code class="gatsby-code-text">Lazy Function</code></p>\n<p>同时记住我们抛出的几个尚未解决的问题？</p>\n<ul>\n<li>如何解决嵌套的try-catch</li>\n<li>异步函数的组合</li>\n<li>chain函数又是什么</li>\n</ul>\n<p>下面几节，将会解决这几个问题！</p>',
frontmatter:{title:"薛定谔的 Maybe - IO",img:"./img/2014-09-15.jpg",author:["Sylvenas"],excerpt:null,catalogue:null},fields:{date:"January 29, 2020",path:"blog/monad/2020-01-30-薛定谔的Maybe.md",slug:"/blog/2020/01/30/薛定谔的Maybe.html"}},allMarkdownRemark:{edges:[{node:{frontmatter:{title:"React Hooks 原理及实现"},fields:{slug:"/blog/2021/03/30/react-hooks.html"}}},{node:{frontmatter:{title:"被讨厌的勇气"},fields:{slug:"/blog/2020/05/14/被讨厌的勇气.html"}}},{node:{frontmatter:{title:"自然变换 - Natural Transformation"},fields:{slug:"/blog/2020/05/02/自然变换.html"}}},{node:{frontmatter:{title:"遍历与队列 - Traversable"},fields:{slug:"/blog/2020/04/25/遍历与队列.html"}}},{node:{frontmatter:{title:"加法是自然之道 - Monoid"},fields:{slug:"/blog/2020/03/02/加法是自然之道.html"}}},{node:{frontmatter:{title:"俄罗斯套娃娃 - Monad"},fields:{slug:"/blog/2020/02/12/俄罗斯套娃娃.html"}}},{node:{frontmatter:{title:"纪念刘和珍君"},fields:{slug:"/blog/2020/02/07/记念刘和珍君.html"}}},{node:{frontmatter:{title:"应用函子 - Applicative"},fields:{slug:"/blog/2020/02/05/应用函子.html"}}},{node:{frontmatter:{title:"动物庄园"},fields:{slug:"/blog/2020/02/01/动物庄园.html"}}},{node:{frontmatter:{title:"薛定谔的 Maybe - IO"},fields:{slug:"/blog/2020/01/30/薛定谔的Maybe.html"}}}]}},pathContext:{slug:"/blog/2020/01/30/薛定谔的Maybe.html"}}}});