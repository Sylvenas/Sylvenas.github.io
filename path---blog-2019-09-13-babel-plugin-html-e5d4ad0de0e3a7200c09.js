webpackJsonp([0xc6e7de4fb434],{563:function(n,s){n.exports={data:{markdownRemark:{html:'<h2 id="babel-简介"><a href="#babel-%E7%AE%80%E4%BB%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>babel 简介</h2>\n<p>一句话阐述什么是 babel:\nbabel 是一个主要用于将 ES2015+版本的代码编译成向下兼容(比如 ES5/ES3)js 版本的编译器。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// Babel Input: ES2015 arrow function</span>\n<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>n <span class="token operator">=></span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Babel Output: ES5 equivalent</span>\n<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>babel 编译的核心流程是：</p>\n<ul>\n<li>先把代码解析为 AST 语法树，</li>\n<li>遍历 AST 语法树并执行操作，</li>\n<li>最后根据规则生成代码。</li>\n</ul>\n<p>流程不复杂，复杂的是如何操作 AST 语法树，以及如何编写 babel 的插件。网上有很多帖子在讲如何编写 babel 插件，但是讲的都比较浅显，看过之后并不能真正意义上去编写 babel 插件。在实际的项目中，我们需要的插件不仅仅是替换字符串或者打印出什么那么简单，接下来本文会实现一个自动引入 <a href="https://reactjs.org/docs/error-boundaries.html">ErrorBoundary</a>,并包裹 jsx 的 plugin，来实际说明 babel-plugin 的开发过程</p>\n<h2 id="abstract-syntax-tree"><a href="#abstract-syntax-tree" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Abstract Syntax Tree</h2>\n<h3 id="词法分析和语法分析"><a href="#%E8%AF%8D%E6%B3%95%E5%88%86%E6%9E%90%E5%92%8C%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>词法分析和语法分析</h3>\n<p>JavaScript 是解释型语言，一般通过 <code class="gatsby-code-text">词法分析 -&gt; 语法分析 -&gt; 语法树</code>，就可以开始解释执行了</p>\n<p>词法分析：也叫扫描，是将字符流转换为记号流(tokens)，它会读取我们的代码然后按照一定的规则合成一个个的标识</p>\n<p>比如说：<code class="gatsby-code-text">var a = 2</code> ，这段代码通常会被分解成 <code class="gatsby-code-text">var</code>、<code class="gatsby-code-text">a</code>、<code class="gatsby-code-text">=</code>、<code class="gatsby-code-text">2</code></p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token punctuation">[</span>\n  <span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">"Keyword"</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token string">"var"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">"Identifier"</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token string">"a"</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">"Punctuator"</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token string">"="</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">"Numeric"</span><span class="token punctuation">,</span> value<span class="token punctuation">:</span> <span class="token string">"2"</span> <span class="token punctuation">}</span>\n<span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>当词法分析源代码的时候，它会一个一个字符的读取代码，所以很形象地称之为<strong>扫描</strong> - scans。当它遇到空格、操作符，或者特殊符号的时候，它会认为一个话已经完成了。</p>\n<p>语法分析：也称解析器，将词法分析出来的数组转换成树的形式，同时验证语法。语法如果有错的话，抛出语法错误。\n语法分析成 <strong>抽象语法树</strong>（Abstract Syntax Tree） ，我们可以在<a href="https://astexplorer.net/">这里</a>在线查看 JavaScript 代码转换为 抽象语法树的结果。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsxon"><code class="gatsby-code-jsxon">{\n  &quot;type&quot;: &quot;Program&quot;,\n  &quot;body&quot;: [\n    {\n      &quot;type&quot;: &quot;VariableDeclaration&quot;,\n      &quot;declarations&quot;: [\n        {\n          &quot;type&quot;: &quot;VariableDeclarator&quot;,\n          &quot;id&quot;: {\n            &quot;type&quot;: &quot;Identifier&quot;,\n            &quot;name&quot;: &quot;a&quot;\n          },\n          &quot;init&quot;: {\n            &quot;type&quot;: &quot;Literal&quot;,\n            &quot;value&quot;: 2,\n            &quot;raw&quot;: &quot;2&quot;\n          }\n        }\n      ],\n      &quot;kind&quot;: &quot;var&quot;\n    }\n  ],\n  &quot;sourceType&quot;: &quot;script&quot;\n}</code></pre>\n      </div>\n<p>Abstract Syntax Tree 简称 AST，是源代码的抽象语法结构的树状表现形式。webpack、eslint 等很多工具库的核心都是通过抽象语法书这个概念来实现对代码的检查、分析等操作。今天我为大家分享一下 JavaScript 这类解释型语言的抽象语法树的概念。</p>\n<p>我们常用的浏览器就是通过将 js 代码转化为抽象语法树来进行下一步的分析等其他操作。所以将 js 转化为抽象语法树更利于程序的分析。</p>\n<h2 id="babel-与-ast"><a href="#babel-%E4%B8%8E-ast" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>babel 与 AST</h2>\n<p>babel 转换代码其实本质上就是遍历与操作 AST\nbabel 的工作过程:\nbabel 的处理过程主要为 3 个：解析(parse)、转换(transform)、生成(generate)。</p>\n<ul>\n<li>解析：主要包含两个过程：词法分析和语法分析，输入是代码字符串，输出是 AST。</li>\n<li>转换：处理 AST。处理工具、插件等就是在这个过程中介入，将代码按照需求进行转换。</li>\n<li>生成：遍历 AST，输出代码字符串。</li>\n</ul>\n<p>解析和生成过程，都有 babel 都为我们处理得很好了，我们要做的就是在 <strong>转换</strong> 过程中修改 AST，进行个性化的定制开发。</p>\n<h3 id="babel-plugin-简介"><a href="#babel-plugin-%E7%AE%80%E4%BB%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>babel plugin 简介</h3>\n<p>babel 使用一种 <strong>访问者模式</strong> 来遍历整棵语法树，即遍历进入到每一个 <code class="gatsby-code-text">Node</code> 节点时，可以说我们在「访问」这个节点。访问者就是一个对象，定义了在一个树状结构中获取具体节点的方法。简单来说，我们可以在访问者中，使用 <code class="gatsby-code-text">Node</code> 的 <code class="gatsby-code-text">type</code> 来定义一个 <code class="gatsby-code-text">hook</code> 函数，每一次遍历到对应 <code class="gatsby-code-text">type</code> 的 <code class="gatsby-code-text">Node</code> 时，<code class="gatsby-code-text">hook</code> 函数就会被触发，我们可以在这个 <code class="gatsby-code-text">hook</code> 函数中，修改、查看、替换、删除这个节点。说起来很抽象，直接看下面的内容吧。</p>\n<h3 id="引入自定义-plugin"><a href="#%E5%BC%95%E5%85%A5%E8%87%AA%E5%AE%9A%E4%B9%89-plugin" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>引入自定义 plugin</h3>\n<p>项目中，一般使用 <code class="gatsby-code-text">.babelrc</code> 来配置 babel，如下：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsxon"><code class="gatsby-code-jsxon">{\n  &quot;presets&quot;: [[&quot;es2015&quot;], [&quot;stage-0&quot;]]\n}</code></pre>\n      </div>\n<p>上面的配置中，只有两个预设，并没有使用插件。首先加上插件的配置。由于是在本地开发，插件直接写的本地的<code class="gatsby-code-text">相对地址</code>:</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsxon"><code class="gatsby-code-jsxon">{\n  &quot;presets&quot;: [[&quot;es2015&quot;], [&quot;stage-0&quot;]],\n  &quot;plugins&quot;: [&quot;./my-babel-plugin&quot;]\n}</code></pre>\n      </div>\n<h3 id="babel-plugin-的雏形"><a href="#babel-plugin-%E7%9A%84%E9%9B%8F%E5%BD%A2" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>babel plugin 的雏形</h3>\n<p>在引入 plugin 之后，下一步就是要写 <code class="gatsby-code-text">my-babel-plugin</code> 的具体实现了,<code class="gatsby-code-text">my-babel-plugin.js</code> 的模版代码如下</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">module<span class="token punctuation">.</span><span class="token function-variable function">exports</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">{</span> types<span class="token punctuation">:</span> t <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token punctuation">{</span>\n    visitor<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n\n  <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>我们可以看到模块需要返回一个函数，而函数的返回值为包含 visitor 属性的对象，也就是我们上文提到的访问者对象；</p>\n<p>函数的参数为 babel 对象，对象中的 <code class="gatsby-code-text">types</code> 是一个用于 AST 节点的 Lodash 式工具库，它包含了构造、验证以及变换 AST 节点的方法。 该工具库包含考虑周到的工具方法，对编写处理 AST 逻辑非常有用。我们单独把这个 <code class="gatsby-code-text">types</code> 拿出来。</p>\n<h3 id="自动引入-errorboundary-组件"><a href="#%E8%87%AA%E5%8A%A8%E5%BC%95%E5%85%A5-errorboundary-%E7%BB%84%E4%BB%B6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>自动引入 ErrorBoundary 组件</h3>\n<p>借助 <a href="https://babeljs.io/docs/en/babel-template">@babel/template</a> ，可以直接把字符串格式的 JS 代码块，转换为 AST，然后在每个文件退出的时候，自动引入 <code class="gatsby-code-text">ErrorBoundary</code> 组件</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">const</span> babelTemplate <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"@babel/template"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">const</span> t <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"babel-types"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">const</span> visitor <span class="token operator">=</span> <span class="token punctuation">{</span>\n  Program<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// Import ErrorBoundary at the beginning of the file</span>\n    <span class="token function">exit</span><span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// string code is converted to AST</span>\n      <span class="token keyword">const</span> impstm <span class="token operator">=</span> template<span class="token punctuation">.</span><span class="token keyword">default</span><span class="token punctuation">.</span><span class="token function">ast</span><span class="token punctuation">(</span>\n        <span class="token string">"import ErrorBoundary from \'$components/ErrorBoundary\'"</span>\n      <span class="token punctuation">)</span><span class="token punctuation">;</span>\n      path<span class="token punctuation">.</span>node<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">unshift</span><span class="token punctuation">(</span>impstm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<blockquote>\n<p><code class="gatsby-code-text">$components/ErrorBoundary</code> 路径需要配合 webpack <code class="gatsby-code-text">alias</code> 使用</p>\n</blockquote>\n<h3 id="包裹返回的-jsx"><a href="#%E5%8C%85%E8%A3%B9%E8%BF%94%E5%9B%9E%E7%9A%84-jsx" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>包裹返回的 jsx</h3>\n<ul>\n<li>添加对 return 表达式的监听</li>\n<li>首先排除父函数是不是 render 函数的 return 表达式， return 的内容不是 jsx 的表达式</li>\n<li>动态的创建 JSX openingElement &#x26; closeElement，包裹 原返回的 jsx，并插入到 AST 树中（记得删除原 jsx）</li>\n</ul>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">visitor <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token comment">// Wrap return jsxElement</span>\n  <span class="token function">ReturnStatement</span> <span class="token punctuation">(</span>path<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">const</span> parentFunc <span class="token operator">=</span> path<span class="token punctuation">.</span><span class="token function">getFunctionParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> oldJsx <span class="token operator">=</span> path<span class="token punctuation">.</span>node<span class="token punctuation">.</span>argument<span class="token punctuation">;</span>\n    <span class="token keyword">if</span> <span class="token punctuation">(</span>\n      <span class="token operator">!</span> oldJsx <span class="token operator">||</span>\n      <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">!</span> parentFunc<span class="token punctuation">.</span>node<span class="token punctuation">.</span>key <span class="token operator">||</span> parentFunc<span class="token punctuation">.</span>node<span class="token punctuation">.</span>key<span class="token punctuation">.</span>name<span class="token operator">!</span> <span class="token operator">==</span> <span class="token string">"render"</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>\n        oldJsx<span class="token punctuation">.</span>type<span class="token operator">!</span> <span class="token operator">==</span> <span class="token string">"JSXElement"</span><span class="token punctuation">)</span>\n    <span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n\n    <span class="token comment">// Create the component tree wrapped by ErrorBoundary</span>\n    <span class="token keyword">const</span> openingElement <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">JSXOpeningElement</span> <span class="token punctuation">(</span>\n      t<span class="token punctuation">.</span><span class="token function">JSXIdentifier</span> <span class="token punctuation">(</span><span class="token string">"ErrorBoundary"</span><span class="token punctuation">)</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> closingElement <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">JSXClosingElement</span> <span class="token punctuation">(</span>\n      t<span class="token punctuation">.</span><span class="token function">JSXIdentifier</span> <span class="token punctuation">(</span><span class="token string">"ErrorBoundary"</span><span class="token punctuation">)</span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token keyword">const</span> newJsx <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">JSXElement</span> <span class="token punctuation">(</span>openingElement<span class="token punctuation">,</span> closingElement<span class="token punctuation">,</span> oldJsx<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n    <span class="token comment">// insert new jxsElement and delete old</span>\n    <span class="token keyword">let</span> newReturnStm <span class="token operator">=</span> t<span class="token punctuation">.</span><span class="token function">returnStatement</span> <span class="token punctuation">(</span>newJsx<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    path<span class="token punctuation">.</span><span class="token function">remove</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    path<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>newReturnStm<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<blockquote>\n<p>babel 遍历 AST 的算法是递归深度优先算法，在监测到每一个 return 表达式的时候，都会触发钩子函数。</p>\n</blockquote>\n<h3 id="转换结果"><a href="#%E8%BD%AC%E6%8D%A2%E7%BB%93%E6%9E%9C" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>转换结果</h3>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">class</span> <span class="token class-name">Button</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>button<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n↓ ↓ ↓ ↓ ↓ ↓\n\n<span class="token keyword">import</span> ErrorBoundary <span class="token keyword">from</span> <span class="token string">\'$components/ErrorBoundary\'</span>\n<span class="token keyword">class</span> <span class="token class-name">Button</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>\n  <span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">(</span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ErrorBoundary</span><span class="token punctuation">></span></span>\n        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span><span class="token punctuation">></span></span>button<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">></span></span>\n      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ErrorBoundary</span><span class="token punctuation">></span></span>\n    <span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<h2 id="参考资料"><a href="#%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>参考资料</h2>\n<ul>\n<li><a href="https://github.com/jamiebuilds/babel-handbook/blob/master/translations/zh-Hans/plugin-handbook.md">babel-handbook</a></li>\n<li><a href="https://babeljs.io/docs/en/babel-template">babel-template</a></li>\n<li><a href="https://github.com/babel/babel/blob/master/packages/babel-types/src/definitions/core.js">babel-types</a></li>\n</ul>',frontmatter:{title:"babel plugin",img:"./img/2015-03-25.jpg",author:["Sylvenas"],excerpt:null,catalogue:null},fields:{date:"September 12, 2019",path:"blog/bundlers/2019-09-13-babel-plugin.md",slug:"/blog/2019/09/13/babel-plugin.html"}},allMarkdownRemark:{edges:[{node:{frontmatter:{title:"React Hooks 原理及实现"},fields:{slug:"/blog/2021/03/30/react-hooks.html"}}},{node:{frontmatter:{title:"npm package依赖管理"},fields:{slug:"/blog/2021/03/03/npm-package.html"}}},{node:{frontmatter:{title:"被讨厌的勇气"},fields:{slug:"/blog/2020/05/14/被讨厌的勇气.html"}}},{node:{frontmatter:{title:"自然变换 - Natural Transformation"},fields:{slug:"/blog/2020/05/02/自然变换.html"}}},{node:{frontmatter:{title:"遍历与队列 - Traversable"},fields:{slug:"/blog/2020/04/25/遍历与队列.html"}}},{node:{frontmatter:{title:"加法是自然之道 - Monoid"},fields:{slug:"/blog/2020/03/02/加法是自然之道.html"}}},{node:{frontmatter:{title:"俄罗斯套娃娃 - Monad"},fields:{slug:"/blog/2020/02/12/俄罗斯套娃娃.html"}}},{node:{frontmatter:{title:"纪念刘和珍君"},fields:{slug:"/blog/2020/02/07/记念刘和珍君.html"}}},{node:{frontmatter:{title:"应用函子 - Applicative"},fields:{slug:"/blog/2020/02/05/应用函子.html"}}},{node:{frontmatter:{title:"动物庄园"},fields:{slug:"/blog/2020/02/01/动物庄园.html"}}}]}},pathContext:{slug:"/blog/2019/09/13/babel-plugin.html"}}}});