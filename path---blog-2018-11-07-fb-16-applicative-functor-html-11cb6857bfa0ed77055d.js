webpackJsonp([0x5bb85b6bf843],{515:function(n,s){n.exports={data:{markdownRemark:{html:'<h3 id="applicative-functor"><a href="#applicative-functor" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Applicative Functor</h3>\n<h4 id="应用-applicative-functor"><a href="#%E5%BA%94%E7%94%A8-applicative-functor" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>应用 applicative functor</h4>\n<p>考虑到其函数式的出身，<strong>applicative functor</strong> 这个名称堪称简单明了。函数式程序员最为人诟病的一点就是，总喜欢搞一些稀奇古怪的命名，比如 <code class="gatsby-code-text">mappend</code> 或者 <code class="gatsby-code-text">liftA4</code>。诚然，此类名称出现在数学实验室是再自然不过的，但是放在其他任何语境下，这些概念就都像是扮作达斯维达去汽车餐馆搞怪的人。</p>\n<p>无论如何，applicative 这个名字应该能够向我们表明一些事实，告诉我们作为一个接口，它能为我们带来什么：那就是让不同 functor 可以相互应用（apply）的能力。</p>\n<p>然而，你可能会问了，为何一个正常的、理性的人，比如你自己，会做这种“让不同 functor 相互应用”的事？而且，“相互应用”到底<em>是什么意思</em>？</p>\n<p>要回答这些问题，我们可以从下面这个场景讲起，可能你已经碰到过这种场景了。假设有两个同类型的 functor，我们想把这两者作为一个函数的两个参数传递过去来调用这个函数。简单的例子比如让两个 <code class="gatsby-code-text">Container</code> 的值相加：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 这样是行不通的，因为 2 和 3 都藏在瓶子里。</span>\n<span class="token function">add</span><span class="token punctuation">(</span>Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">//NaN</span>\n\n<span class="token comment">// 使用可靠的 map 函数试试</span>\n<span class="token keyword">const</span> container_of_add_2 <span class="token operator">=</span> <span class="token function">map</span><span class="token punctuation">(</span>add<span class="token punctuation">,</span> Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Container(add(2))</span></code></pre>\n      </div>\n<p>这时候我们创建了一个 <code class="gatsby-code-text">Container</code>，它内部的值是一个局部调用的（partially applied）的函数。确切点讲就是，我们想让 <code class="gatsby-code-text">Container(add(2))</code> 中的 <code class="gatsby-code-text">add(2)</code> 应用到 <code class="gatsby-code-text">Container(3)</code> 中的 <code class="gatsby-code-text">3</code> 上来完成调用。也就是说，我们想把一个 functor 应用到另一个上。</p>\n<p>巧的是，完成这种任务的工具已经存在了，即 <code class="gatsby-code-text">chain</code> 函数。我们可以先 <code class="gatsby-code-text">chain</code> 然后再 <code class="gatsby-code-text">map</code> 那个局部调用的 <code class="gatsby-code-text">add(2)</code>，就像这样：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span>two<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>只不过，这种方式有一个问题，那就是 monad 的顺序执行问题：所有的代码都只会在前一个 monad 执行完毕之后才执行。想想看，我们的这两个值足够强健且相互独立，如果仅仅为了满足 monad 的顺序要求而延迟 <code class="gatsby-code-text">Container(3)</code> 的创建，我觉得是非常没有必要的。</p>\n<p>事实上，当遇到这种问题的时候，要是能够无需借助这些不必要的函数和变量，以一种简明扼要的方式把一个 functor 的值应用到另一个上去就好了。</p>\n<h3 id="瓶中之船"><a href="#%E7%93%B6%E4%B8%AD%E4%B9%8B%E8%88%B9" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>瓶中之船</h3>\n<img src="images/ship_in_a_bottle.jpg" alt="http://hollycarden.deviantart.com" />\n<p><code class="gatsby-code-text">ap</code> 就是这样一种函数，能够把一个 functor 的函数值应用到另一个 functor 的值上。把这句话快速地说上 5 遍。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Container(5)</span>\n\n<span class="token comment">// all together now</span>\nContainer<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Container<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Container(5)</span></code></pre>\n      </div>\n<p>这样就大功告成了，而且代码干净整洁。可以看到，<code class="gatsby-code-text">Container(3)</code> 从嵌套的 monad 函数的牢笼中释放了出来。需要再次强调的是，本例中的 <code class="gatsby-code-text">add</code> 是被 <code class="gatsby-code-text">map</code> 所局部调用（partially apply）的，所以 <code class="gatsby-code-text">add</code> 必须是一个 curry 函数。</p>\n<p>可以这样定义一个 <code class="gatsby-code-text">ap</code> 函数：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Container<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">ap</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>other_container<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> other_container<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>__value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>记住，<code class="gatsby-code-text">this.__value</code> 是一个函数，将会接收另一个 functor 作为参数，所以我们只需 <code class="gatsby-code-text">map</code> 它。由此我们可以得出 applicative functor 的定义：</p>\n<blockquote>\n<p>applicative functor 是实现了 <code class="gatsby-code-text">ap</code> 方法的 pointed functor</p>\n</blockquote>\n<p>注意 <code class="gatsby-code-text">pointed</code> 这个前提，这是非常重要的一个前提，下面的例子会说明这一点。</p>\n<p>讲到这里，我已经感受到你的疑虑了（也或者是困惑和恐惧）；心态开放点嘛，<code class="gatsby-code-text">ap</code> 还是很有用的。在深入理解这个概念之前，我们先来探索一个特性。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token constant">F</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">F</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token constant">F</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p>这行代码翻译成人类语言就是，map 一个 <code class="gatsby-code-text">f</code> 等价于 <code class="gatsby-code-text">ap</code> 一个值为 <code class="gatsby-code-text">f</code> 的 functor。或者更好的译法是，你既可以把 <code class="gatsby-code-text">x</code> 放到容器里然后调用 <code class="gatsby-code-text">map(f)</code>，也可以同时让 <code class="gatsby-code-text">f</code> 和 <code class="gatsby-code-text">x</code> 发生 lift（参看第 8 章），然后对他们调用 <code class="gatsby-code-text">ap</code>。这让我们能够以一种从左到右的方式编写代码：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Maybe(5)</span>\n\nTask<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Task(5)</span></code></pre>\n      </div>\n<p>细心的读者可能发现了，上述代码中隐约有普通函数调用的影子。没关系，我们稍后会学习 <code class="gatsby-code-text">ap</code> 的 pointfree 版本；暂时先把这当作此类代码的推荐写法。通过使用 <code class="gatsby-code-text">of</code>，每一个值都被输送到了各个容器里的奇幻之地，就像是在另一个平行世界里，每个程序都可以是异步的或者是 null 或者随便什么值，而且不管是什么，<code class="gatsby-code-text">ap</code> 都能在这个平行世界里针对这些值应用各种各样的函数。这就像是在一个瓶子中造船。</p>\n<p>你注意到没？上例中我们使用了 <code class="gatsby-code-text">Task</code>，这是 applicative functor 主要的用武之地。现在我们来看一个更深入的例子。</p>\n<h3 id="协调与激励"><a href="#%E5%8D%8F%E8%B0%83%E4%B8%8E%E6%BF%80%E5%8A%B1" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>协调与激励</h3>\n<p>假设我们要创建一个旅游网站，既需要获取游客目的地的列表，还需要获取地方事件的列表。这两个请求就是相互独立的 api 调用。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// Http.get :: String -> Task Error HTML</span>\n\n<span class="token keyword">var</span> renderPage <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>destinations<span class="token punctuation">,</span> events<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* render page */</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nTask<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>renderPage<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">\'/destinations\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">\'/events\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment">// Task("&lt;div>some page with dest and events&lt;/div>")</span></code></pre>\n      </div>\n<p>两个请求将会同时立即执行，当两者的响应都返回之后，<code class="gatsby-code-text">renderPage</code> 就会被调用。这与 monad 版本的那种必须等待前一个任务完成才能继续执行后面的操作完全不同。本来我们就无需根据目的地来获取事件，因此也就不需要依赖顺序执行。</p>\n<p>再次强调，因为我们是使用局部调用的函数来达成上述结果的，所以必须要保证 <code class="gatsby-code-text">renderpage</code> 是 curry 函数，否则它就不会一直等到两个 <code class="gatsby-code-text">Task</code> 都完成。而且如果你碰巧自己做过类似的事，那你一定会感激 <code class="gatsby-code-text">applicative functor</code> 这个异常简洁的接口的。这就是那种能够让我们离“奇点”（singularity）更近一步的优美代码。</p>\n<p>再来看另外一个例子。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 帮助函数：</span>\n<span class="token comment">// ==============</span>\n<span class="token comment">//  $ :: String -> IO DOM</span>\n<span class="token keyword">var</span> <span class="token function-variable function">$</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">IO</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>selector<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">//  getVal :: String -> IO String</span>\n<span class="token keyword">var</span> getVal <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span><span class="token function">map</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">prop</span><span class="token punctuation">(</span><span class="token string">\'value\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span> $<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">// Example:</span>\n<span class="token comment">// ===============</span>\n<span class="token comment">//  signIn :: String -> String -> Bool -> User</span>\n<span class="token keyword">var</span> signIn <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">,</span> remember_me<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">/* signing in */</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>signIn<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">getVal</span><span class="token punctuation">(</span><span class="token string">\'#email\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">getVal</span><span class="token punctuation">(</span><span class="token string">\'#password\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// IO({id: 3, email: "gg@allin.com"})</span></code></pre>\n      </div>\n<p><code class="gatsby-code-text">signIn</code> 是一个接收 3 个参数的 curry 函数，因此我们需要调用 <code class="gatsby-code-text">ap</code> 3 次。在每一次的 <code class="gatsby-code-text">ap</code> 调用中，<code class="gatsby-code-text">signIn</code> 就收到一个参数然后运行，直到所有的参数都传进来，它也就执行完毕了。我们可以继续扩展这种模式，处理任意多的参数。另外，左边两个参数在使用 <code class="gatsby-code-text">getVal</code> 调用后自然而然地成为了一个 <code class="gatsby-code-text">IO</code>，但是最右边的那个却需要手动 <code class="gatsby-code-text">lift</code>，然后变成一个 <code class="gatsby-code-text">IO</code>，这是因为 <code class="gatsby-code-text">ap</code> 需要调用者及其参数都属于同一类型。</p>\n<h3 id="lift"><a href="#lift" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>lift</h3>\n<p>我们来试试以一种 pointfree 的方式调用 applicative functor。因为 <code class="gatsby-code-text">map</code> 等价于 <code class="gatsby-code-text">of/ap</code>，那么我们就可以定义无数个能够 <code class="gatsby-code-text">ap</code> 通用函数。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> liftA2 <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> functor1<span class="token punctuation">,</span> functor2<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> functor1<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor2<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token keyword">var</span> liftA3 <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> functor1<span class="token punctuation">,</span> functor2<span class="token punctuation">,</span> functor3<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> functor1<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor2<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>functor3<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token comment">//liftA4, etc</span></code></pre>\n      </div>\n<p><code class="gatsby-code-text">liftA2</code> 是个奇怪的名字，听起来像是破败工厂里挑剔的货运电梯，或者伪豪华汽车公司的个性车牌。不过你要是真正理解了，那么它的含义也就不证自明了：让那些小代码块发生 lift，成为 applicative functor 中的一员。</p>\n<p>刚开始我也觉得这种 2-3-4 的写法没什么意义，看起来又丑又没有必要，毕竟我们可以在 JavaScript 中检查函数的参数数量然后再动态地构造这样的函数。不过，局部调用（partially apply）<code class="gatsby-code-text">liftA(N)</code> 本身，有时也能发挥它的用处，这样的话，参数数量就固定了。</p>\n<p>来看看实际用例：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// checkEmail :: User -> Either String Email</span>\n<span class="token comment">// checkName :: User -> Either String String</span>\n\n<span class="token comment">//  createUser :: Email -> String -> IO User</span>\n<span class="token keyword">var</span> createUser <span class="token operator">=</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>email<span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">/* creating... */</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\nEither<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>createUser<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">checkEmail</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">checkName</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Left("invalid email")</span>\n\n<span class="token function">liftA2</span><span class="token punctuation">(</span>createUser<span class="token punctuation">,</span> <span class="token function">checkEmail</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">checkName</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Left("invalid email")</span></code></pre>\n      </div>\n<p><code class="gatsby-code-text">createUser</code> 接收两个参数，因此我们使用的是 <code class="gatsby-code-text">liftA2</code>。上述两个语句是等价的，但是使用了 <code class="gatsby-code-text">liftA2</code> 的版本没有提到 <code class="gatsby-code-text">Either</code>，这就使得它更加通用灵活，因为不必与特定的数据类型耦合在一起。</p>\n<p>我们试试以这种方式重写前一个例子：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token function">liftA2</span><span class="token punctuation">(</span>add<span class="token punctuation">,</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// Maybe(5)</span>\n\n<span class="token function">liftA2</span><span class="token punctuation">(</span>renderPage<span class="token punctuation">,</span> Http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">\'/destinations\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Http<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">\'/events\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment">// Task("&lt;div>some page with dest and events&lt;/div>")</span>\n\n<span class="token function">liftA3</span><span class="token punctuation">(</span>signIn<span class="token punctuation">,</span> <span class="token function">getVal</span><span class="token punctuation">(</span><span class="token string">\'#email\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getVal</span><span class="token punctuation">(</span><span class="token string">\'#password\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token comment">// IO({id: 3, email: "gg@allin.com"})</span></code></pre>\n      </div>\n<h3 id="操作符"><a href="#%E6%93%8D%E4%BD%9C%E7%AC%A6" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>操作符</h3>\n<p>在 haskell、scala、PureScript 以及 swift 等语言中，开发者可以创建自定义的中缀操作符（infix operators），所以你能看到到这样的语法：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-hs"><code class="gatsby-code-hs">-- haskell\nadd &lt;$&gt; Right 2 &lt;*&gt; Right 3</code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// JavaScript</span>\n<span class="token function">map</span><span class="token punctuation">(</span>add<span class="token punctuation">,</span> <span class="token function">Right</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token function">Right</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p><code class="gatsby-code-text">&lt;$&gt;</code> 就是 <code class="gatsby-code-text">map</code>（亦即 <code class="gatsby-code-text">fmap</code>），<code class="gatsby-code-text">&lt;*&gt;</code> 不过就是 <code class="gatsby-code-text">ap</code>。这样的语法使得开发者可以以一种更自然的风格来书写函数式应用，而且也能减少一些括号。</p>\n<h3 id="免费开瓶器"><a href="#%E5%85%8D%E8%B4%B9%E5%BC%80%E7%93%B6%E5%99%A8" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>免费开瓶器</h3>\n<img src="images/canopener.jpg" alt="http://breannabeckmeyer.com/drawing.html" />\n<p>我们尚未对衍生函数（derived function）着墨过多。不过看到本书介绍的所有这些接口都互相依赖并遵守一些定律，那么我们就可以根据一些强接口来定义一些弱接口了。</p>\n<p>比如，我们知道一个 applicative 首先是一个 functor，所以如果已经有一个 applicative 实例的话，毫无疑问可以依此定义一个 functor。</p>\n<p>这种完美的计算上的大和谐（computational harmony）之所以存在，是因为我们在跟一个数学“框架”打交道。哪怕是莫扎特在小时候就下载了 ableton（译者注：一款专业的音乐制作软件），他的钢琴也不可能弹得更好。</p>\n<p>前面提到过，<code class="gatsby-code-text">of/ap</code> 等价于 <code class="gatsby-code-text">map</code>，那么我们就可以利用这点来定义 <code class="gatsby-code-text">map</code>：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 从 of/ap 衍生出的 map</span>\n<span class="token constant">X</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">map</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>constructor<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span></code></pre>\n      </div>\n<p>monad 可以说是处在食物链的顶端，因此如果已经有了一个 <code class="gatsby-code-text">chain</code> 函数，那么就可以免费得到 functor 和 applicative：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 从 chain 衍生出的 map</span>\n<span class="token constant">X</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">map</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">var</span> m <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>\n  <span class="token keyword">return</span> m<span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> m<span class="token punctuation">.</span>constructor<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// 从 chain/map 衍生出的 ap</span>\n<span class="token constant">X</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">ap</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>other<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">chain</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> other<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<p>定义一个 monad，就既能得到 applicative 也能得到 functor。这一点非常强大，相当于这些“开瓶器”全都是免费的！我们甚至可以审查一个数据类型，然后自动化这个过程。</p>\n<p>应该要指出来的一点是，<code class="gatsby-code-text">ap</code> 的魅力有一部分就来自于并行的能力，所以通过 <code class="gatsby-code-text">chain</code> 来定义它就失去了这种优化。即便如此，开发者在设计出最佳实现的过程中就能有一个立即可用的接口，也是很好的。</p>\n<p>为啥不直接使用 monad？因为最好用合适的力量来解决合适的问题，一分不多，一分不少。这样就能通过排除可能的功能性来做到最小化认知负荷。因为这个原因，相比 monad，我们更倾向于使用 applicative。</p>\n<p>向下的嵌套结构使得 monad 拥有串行计算、变量赋值和暂缓后续执行等独特的能力。不过见识到 applicative 的实际用例之后，你就不必再考虑上面这些问题了。</p>\n<p>下面，来看看理论知识。</p>\n<h3 id="定律"><a href="#%E5%AE%9A%E5%BE%8B" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>定律</h3>\n<p>就像我们探索过的其他数学结构一样，我们在日常编码中也依赖 applicative functor 一些有用的特性。首先，你应该知道 applicative functor 是“组合关闭”（closed under composition）的，意味着 <code class="gatsby-code-text">ap</code> 永远不会改变容器类型（另一个胜过 monad 的原因）。这并不是说我们无法拥有多种不同的作用——我们还是可以把不同的类型压栈的，只不过我们知道它们将会在整个应用的过程中保持不变。</p>\n<p>下面的例子可以说明这一点：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">  <span class="token keyword">var</span> tOfM <span class="token operator">=</span> <span class="token function">compose</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">,</span> Maybe<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token function">liftA2</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>concat<span class="token punctuation">,</span> <span class="token function">tOfM</span><span class="token punctuation">(</span><span class="token string">\'Rainy Days and Mondays\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">tOfM</span><span class="token punctuation">(</span><span class="token string">\' always get me down\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token comment">// Task(Maybe(Rainy Days and Mondays always get me down))</span></code></pre>\n      </div>\n<p>你看，不必担心不同的类型会混合在一起。</p>\n<p>该去看看我们最喜欢的范畴学定律了：<em>同一律</em>（identity）。</p>\n<h3 id="同一律（identity）"><a href="#%E5%90%8C%E4%B8%80%E5%BE%8B%EF%BC%88identity%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同一律（identity）</h3>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 同一律</span>\n<span class="token constant">A</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">==</span> v</code></pre>\n      </div>\n<p>是的，对一个 functor 应用 <code class="gatsby-code-text">id</code> 函数不会改变 <code class="gatsby-code-text">v</code> 里的值。比如：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> v <span class="token operator">=</span> Identity<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"Pillow Pets"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nIdentity<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token operator">==</span> v</code></pre>\n      </div>\n<p><code class="gatsby-code-text">Identity.of(id)</code> 的“无用性”让我不禁莞尔。这里有意思的一点是，就像我们之前证明了的，<code class="gatsby-code-text">of/ap</code> 等价于 <code class="gatsby-code-text">map</code>，因此这个同一律遵循的是 functor 的同一律：<code class="gatsby-code-text">map(id) == id</code>。</p>\n<p>使用这些定律的优美之处在于，就像一个富有激情的幼儿园健身教练让所有的小朋友都能愉快地一块玩耍一样，它们能够强迫所有的接口都能完美结合。</p>\n<h3 id="同态（homomorphism）"><a href="#%E5%90%8C%E6%80%81%EF%BC%88homomorphism%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>同态（homomorphism）</h3>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 同态</span>\n<span class="token constant">A</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">A</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<p><em>同态</em>就是一个能够保持结构的映射（structure preserving map）。实际上，functor 就是一个在不同范畴间的同态，因为 functor 在经过映射之后保持了原始范畴的结构。</p>\n<p>事实上，我们不过是把普通的函数和值放进了一个容器，然后在里面进行各种计算。所以，不管是把所有的计算都放在容器里（等式左边），还是先在外面进行计算然后再放到容器里（等式右边），其结果都是一样的。</p>\n<p>一个简单例子：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx">Either<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>toUpper<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Either<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"oreos"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> Either<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">toUpper</span><span class="token punctuation">(</span><span class="token string">"oreos"</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<h3 id="互换（interchange）"><a href="#%E4%BA%92%E6%8D%A2%EF%BC%88interchange%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>互换（interchange）</h3>\n<p>互换（interchange）表明的是选择让函数在 <code class="gatsby-code-text">ap</code> 的左边还是右边发生 lift 是无关紧要的。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 互换</span>\nv<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token constant">A</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span></code></pre>\n      </div>\n<p>这里有个例子：</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> v <span class="token operator">=</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>reverse<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token string">\'Sparklehorse\'</span><span class="token punctuation">;</span>\n\nv<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> Task<span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span></code></pre>\n      </div>\n<h3 id="组合（composition）"><a href="#%E7%BB%84%E5%90%88%EF%BC%88composition%EF%BC%89" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>组合（composition）</h3>\n<p>最后是组合。组合不过是在检查标准的函数组合是否适用于容器内部的函数调用。</p>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token comment">// 组合</span>\n<span class="token constant">A</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>compose<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">==</span> u<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>\n      </div>\n<div class="gatsby-highlight">\n      <pre class="gatsby-code-jsx"><code class="gatsby-code-jsx"><span class="token keyword">var</span> u <span class="token operator">=</span> <span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>toUpper<span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> v <span class="token operator">=</span> <span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token string">"&amp; beyond"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token keyword">var</span> w <span class="token operator">=</span> <span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span><span class="token string">"blood bath "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n<span class="token constant">IO</span><span class="token punctuation">.</span><span class="token keyword">of</span><span class="token punctuation">(</span>_<span class="token punctuation">.</span>compose<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>u<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span> <span class="token operator">==</span> u<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>v<span class="token punctuation">.</span><span class="token function">ap</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre>\n      </div>\n<h3 id="总结"><a href="#%E6%80%BB%E7%BB%93" aria-hidden="true" class="anchor"><svg aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>总结</h3>\n<p>处理多个 functor 作为参数的情况，是 applicative functor 一个非常好的应用场景。借助 applicative functor，我们能够在 functor 的世界里调用函数。尽管已经可以通过 monad 达到这个目的，但在不需要 monad 的特定功能的时候，我们还是更倾向于使用 applicative functor。</p>\n<p>至此我们已经基本介绍完容器的 api 了，我们学会了如何对函数调用 <code class="gatsby-code-text">map</code>、<code class="gatsby-code-text">chain</code> 和 <code class="gatsby-code-text">ap</code>。下一章，我们将学习如何更好地处理多个 functor，以及如何以一种原则性的方式拆解它们。</p>',
frontmatter:{title:"FP16：Applicative Functor",img:"./img/2018-11-07.jpeg",author:["Sylvenas"],excerpt:null,catalogue:null},fields:{date:"November 06, 2018",path:"blog/functional/2018-11-07-FB16-Applicative-Functor.md",slug:"/blog/2018/11/07/FB16-Applicative-Functor.html"}},allMarkdownRemark:{edges:[{node:{frontmatter:{title:"移动端适配方案rem & vh、vw"},fields:{slug:"/blog/2019/05/27/mobile-css.html"}}},{node:{frontmatter:{title:"移动端开发基础知识"},fields:{slug:"/blog/2019/05/24/mobile.html"}}},{node:{frontmatter:{title:"How JavaScript Work: 内存管理/垃圾收集/内存泄漏"},fields:{slug:"/blog/2019/02/05/menory-management.html"}}},{node:{frontmatter:{title:"前端资源加载优先级"},fields:{slug:"/blog/2019/01/12/load-priority.html"}}},{node:{frontmatter:{title:"FP18：Semigroup"},fields:{slug:"/blog/2018/12/13/FP18-Semigroup.html"}}},{node:{frontmatter:{title:"FP17：Transform Naturally"},fields:{slug:"/blog/2018/12/11/FP17-Transform-Naturally.html"}}},{node:{frontmatter:{title:"How JavaScript Work: 引擎、运行时、调用栈概述"},fields:{slug:"/blog/2018/11/12/overview-of-the-engine-the-runtime-the-call-stack.html"}}},{node:{frontmatter:{title:"FP16：Applicative Functor"},fields:{slug:"/blog/2018/11/07/FB16-Applicative-Functor.html"}}},{node:{frontmatter:{title:"FP15：Monad-2"},fields:{slug:"/blog/2018/09/11/FB15-Monad-2.html"}}},{node:{frontmatter:{title:"FP14：Monad-1"},fields:{slug:"/blog/2018/09/02/FP14-Monad-1.html"}}}]}},pathContext:{slug:"/blog/2018/11/07/FB16-Applicative-Functor.html"}}}});